From 3516abb8cb0ed925782730dd8fb6f8ce91ef6a24 Mon Sep 17 00:00:00 2001
From: Cosimo Cecchi <cosimo@endlessm.com>
Date: Mon, 28 Nov 2016 14:41:15 +0100
Subject: [PATCH 001/154] arg: don't crash when asked to convert a null strv to
 an array

In that case, return an empty array.

https://phabricator.endlessm.com/T14337

https://bugzilla.gnome.org/show_bug.cgi?id=775679
---
 installed-tests/js/testEverythingBasic.js | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/installed-tests/js/testEverythingBasic.js b/installed-tests/js/testEverythingBasic.js
index de3ef1a5..3b198456 100644
--- a/installed-tests/js/testEverythingBasic.js
+++ b/installed-tests/js/testEverythingBasic.js
@@ -601,6 +601,11 @@ describe('Life, the Universe and Everything', function () {
         }
     });
 
+    it('correctly converts a NULL strv in a GValue to an empty array', function() {
+        let v = Regress.test_null_strv_in_gvalue();
+        expect(v.length).toEqual(0);
+    });
+
     describe('wrong type for GObject', function () {
         let wrongObject, wrongBoxed, subclassObject;
         beforeEach(function () {

From 4825d4dd87fce130a764b310ffe69b44257be6de Mon Sep 17 00:00:00 2001
From: Tom Schoonjans <Tom.Schoonjans@me.com>
Date: Mon, 24 Apr 2017 22:42:28 -0700
Subject: [PATCH 002/154] arg: Include headers for std::abs()

Required for compiling with clang on macOS.

https://bugzilla.gnome.org/show_bug.cgi?id=780350
---
 gi/arg.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/gi/arg.cpp b/gi/arg.cpp
index d3963b8d..056ace38 100644
--- a/gi/arg.cpp
+++ b/gi/arg.cpp
@@ -23,6 +23,9 @@
 
 #include <config.h>
 
+#include <cstdlib>
+#include <cmath>
+
 #include "arg.h"
 #include "gtype.h"
 #include "object.h"

From 22c5e8cd1fbf16f8ceb3d76df3706cbda2825247 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Claudio=20Andr=C3=A9?= <claudioandre.br@gmail.com>
Date: Wed, 26 Apr 2017 17:29:56 -0300
Subject: [PATCH 003/154] maintenance: modernize shell scripts

It is possible to use a static analysis tool to improve all scripts robustness and safety.

https://bugzilla.gnome.org/show_bug.cgi?id=781806
---
 installed-tests/scripts/testCommandLine.sh | 24 ++++++++++++------------
 installed-tests/scripts/testWarnings.sh    |  6 +++---
 2 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/installed-tests/scripts/testCommandLine.sh b/installed-tests/scripts/testCommandLine.sh
index c51a302d..2e0d55e8 100755
--- a/installed-tests/scripts/testCommandLine.sh
+++ b/installed-tests/scripts/testCommandLine.sh
@@ -1,9 +1,9 @@
 #!/bin/sh
 
 if test "$GJS_USE_UNINSTALLED_FILES" = "1"; then
-    gjs="$TOP_BUILDDIR"/gjs-console
+    gjs="$TOP_BUILDDIR/gjs-console"
 else
-    gjs=gjs-console
+    gjs="gjs-console"
 fi
 
 # This JS script should exit immediately with code 42. If that is not working,
@@ -31,7 +31,7 @@ total=0
 
 report () {
     exit_code=$?
-    total=`expr $total + 1`
+    total=$((total + 1))
     if test $exit_code -eq 0; then
         echo "ok $total - $1"
     else
@@ -41,7 +41,7 @@ report () {
 
 report_xfail () {
     exit_code=$?
-    total=`expr $total + 1`
+    total=$((total + 1))
     if test $exit_code -ne 0; then
         echo "ok $total - $1"
     else
@@ -65,39 +65,39 @@ report "System.exit() should still exit across an FFI boundary"
 # gjs --help prints GJS help
 "$gjs" --help >/dev/null
 report "--help should succeed"
-test -n "`"$gjs" --help`"
+test -n "$("$gjs" --help)"
 report "--help should print something"
 
 # print GJS help even if it's not the first argument
 "$gjs" -I . --help >/dev/null
 report "should succeed when --help is not first arg"
-test -n "`"$gjs" -I . --help`"
+test -n "$("$gjs" -I . --help)"
 report "should print something when --help is not first arg"
 
 # --help before a script file name prints GJS help
 "$gjs" --help help.js >/dev/null
 report "--help should succeed before a script file"
-test -n "`"$gjs" --help help.js`"
+test -n "$("$gjs" --help help.js)"
 report "--help should print something before a script file"
 
 # --help before a -c argument prints GJS help
 script='imports.system.exit(1)'
 "$gjs" --help -c "$script" >/dev/null
 report "--help should succeed before -c"
-test -n "`"$gjs" --help -c "$script"`"
+test -n "$("$gjs" --help -c "$script")"
 report "--help should print something before -c"
 
 # --help after a script file name is passed to the script
 "$gjs" -I sentinel help.js --help
 report "--help after script file should be passed to script"
-test -z "`"$gjs" -I sentinel help.js --help`"
+test -z "$("$gjs" -I sentinel help.js --help)"
 report "--help after script file should not print anything"
 
 # --help after a -c argument is passed to the script
 script='if(ARGV[0] !== "--help") imports.system.exit(1)'
 "$gjs" -c "$script" --help
 report "--help after -c should be passed to script"
-test -z "`"$gjs" -c "$script" --help`"
+test -z "$("$gjs" -c "$script" --help)"
 report "--help after -c should not print anything"
 
 # -I after a program is not consumed by GJS
@@ -116,14 +116,14 @@ rm -f foo/coverage.lcov
 # --version works
 "$gjs" --version >/dev/null
 report "--version should work"
-test -n "`"$gjs" --version`"
+test -n "$("$gjs" --version)"
 report "--version should print something"
 
 # --version after a script goes to the script
 script='if(ARGV[0] !== "--version") imports.system.exit(1)'
 "$gjs" -c "$script" --version
 report "--version after -c should be passed to script"
-test -z "`"$gjs" -c "$script" --version`"
+test -z "$("$gjs" -c "$script" --version)"
 report "--version after -c should not print anything"
 
 rm -f exit.js help.js
diff --git a/installed-tests/scripts/testWarnings.sh b/installed-tests/scripts/testWarnings.sh
index f95dd9ab..ebf3143c 100755
--- a/installed-tests/scripts/testWarnings.sh
+++ b/installed-tests/scripts/testWarnings.sh
@@ -1,16 +1,16 @@
 #!/bin/sh
 
 if test "$GJS_USE_UNINSTALLED_FILES" = "1"; then
-    gjs="$TOP_BUILDDIR"/gjs-console
+    gjs="$TOP_BUILDDIR/gjs-console"
 else
-    gjs=gjs-console
+    gjs="gjs-console"
 fi
 
 total=0
 
 report () {
     exit_code=$?
-    total=`expr $total + 1`
+    total=$((total + 1))
     if test $exit_code -eq 0; then
         echo "ok $total - $1"
     else

From 7d0c3f558558ecaa021956945cce9e7d6b731ee9 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Fri, 28 Apr 2017 00:08:27 -0700
Subject: [PATCH 004/154] modules/console: Update fancy error reporter to
 mozjs38

It turns out the error reporter was copied almost verbatim from an
internal SpiderMonkey function, js::PrintError(). By copying in a newer
version from SpiderMonkey 38, we get the latest improvements: along with
the line number, the character column of the error is also printed.

https://bugzilla.gnome.org/show_bug.cgi?id=781882
---
 modules/console.cpp | 59 ++++++++++++++++++++++++++---------------------------
 1 file changed, 29 insertions(+), 30 deletions(-)

diff --git a/modules/console.cpp b/modules/console.cpp
index c1de9e50..eb8a2c82 100644
--- a/modules/console.cpp
+++ b/modules/console.cpp
@@ -60,25 +60,25 @@
 static void
 gjs_console_error_reporter(JSContext *cx, const char *message, JSErrorReport *report)
 {
-    int i, j, k, n;
-    char *prefix, *tmp;
-    const char *ctmp;
+    /* Code modified from SpiderMonkey js/src/jscntxt.cpp, js::PrintError() */
 
     if (!report) {
         fprintf(stderr, "%s\n", message);
+        fflush(stderr);
         return;
     }
 
-    prefix = NULL;
+    char *prefix = nullptr;
     if (report->filename)
         prefix = g_strdup_printf("%s:", report->filename);
     if (report->lineno) {
-        tmp = prefix;
-        prefix = g_strdup_printf("%s%u: ", tmp ? tmp : "", report->lineno);
+        char *tmp = prefix;
+        prefix = g_strdup_printf("%s%u:%u ", tmp ? tmp : "", report->lineno,
+                                 report->column);
         g_free(tmp);
     }
     if (JSREPORT_IS_WARNING(report->flags)) {
-        tmp = prefix;
+        char *tmp = prefix;
         prefix = g_strdup_printf("%s%swarning: ",
                                  tmp ? tmp : "",
                                  JSREPORT_IS_STRICT(report->flags) ? "strict " : "");
@@ -86,7 +86,8 @@ gjs_console_error_reporter(JSContext *cx, const char *message, JSErrorReport *re
     }
 
     /* embedded newlines -- argh! */
-    while ((ctmp = strchr(message, '\n')) != NULL) {
+    const char *ctmp;
+    while ((ctmp = strchr(message, '\n')) != 0) {
         ctmp++;
         if (prefix)
             fputs(prefix, stderr);
@@ -99,31 +100,29 @@ gjs_console_error_reporter(JSContext *cx, const char *message, JSErrorReport *re
         fputs(prefix, stderr);
     fputs(message, stderr);
 
-    if (!report->linebuf) {
-        fputc('\n', stderr);
-        goto out;
-    }
-
-    /* report->linebuf usually ends with a newline. */
-    n = strlen(report->linebuf);
-    fprintf(stderr, ":\n%s%s%s%s",
-            prefix,
-            report->linebuf,
-            (n > 0 && report->linebuf[n-1] == '\n') ? "" : "\n",
-            prefix);
-    n = ((char*)report->tokenptr) - ((char*) report->linebuf);
-    for (i = j = 0; i < n; i++) {
-        if (report->linebuf[i] == '\t') {
-            for (k = (j + 8) & ~7; j < k; j++) {
-                fputc('.', stderr);
+    if (report->linebuf) {
+        /* report->linebuf usually ends with a newline. */
+        int n = strlen(report->linebuf);
+        fprintf(stderr, ":\n%s%s%s%s",
+                prefix,
+                report->linebuf,
+                (n > 0 && report->linebuf[n-1] == '\n') ? "" : "\n",
+                prefix);
+        n = report->tokenptr - report->linebuf;
+        for (int i = 0, j = 0; i < n; i++) {
+            if (report->linebuf[i] == '\t') {
+                for (int k = (j + 8) & ~7; j < k; j++) {
+                    fputc('.', stderr);
+                }
+                continue;
             }
-            continue;
+            fputc('.', stderr);
+            j++;
         }
-        fputc('.', stderr);
-        j++;
+        fputc('^', stderr);
     }
-    fputs("^\n", stderr);
- out:
+    fputc('\n', stderr);
+    fflush(stderr);
     g_free(prefix);
 }
 

From 7acc534836b68a1fd2163aacd96b5261cdb63fdd Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 20:23:02 -0500
Subject: [PATCH 005/154] jsapi-util-args: Mark functions as always-inline

On GCC, we get warnings about the inline functions causing too much code
growth. However, we do want these functions always inlined, since they're
in a header file.

Previously we dealt with the warnings by increasing --param
inline-unit-growth, but that causes other warnings on Clang since Clang
doesn't have that parameter. I also noticed that it requires different
values on other versions of GCC, so it's not a very good solution.

Instead, we use the always_inline attribute on GCC, which causes the
functions to be inlined regardless of the compiler's inlining heuristics.

https://bugzilla.gnome.org/show_bug.cgi?id=780350
---
 cjs/jsapi-util-args.h | 18 +++++++++++++++++-
 configure.ac          |  2 --
 2 files changed, 17 insertions(+), 3 deletions(-)

diff --git a/cjs/jsapi-util-args.h b/cjs/jsapi-util-args.h
index 7cd39261..c572fab0 100644
--- a/cjs/jsapi-util-args.h
+++ b/cjs/jsapi-util-args.h
@@ -30,6 +30,13 @@
 #include "jsapi-util.h"
 #include "jsapi-wrapper.h"
 
+#ifdef __GNUC__
+#define GNUC_ALWAYS_INLINE __attribute__((always_inline))
+#else
+#define GNUC_ALWAYS_INLINE
+#endif
+
+GNUC_ALWAYS_INLINE
 static inline bool
 check_nullable(const char*& fchar,
                const char*& fmt_string)
@@ -46,6 +53,7 @@ check_nullable(const char*& fchar,
 
 /* This preserves the previous behaviour of gjs_parse_args(), but maybe we want
  * to use JS::ToBoolean instead? */
+GNUC_ALWAYS_INLINE
 static inline void
 assign(JSContext      *cx,
        char            c,
@@ -64,6 +72,7 @@ assign(JSContext      *cx,
 
 /* This preserves the previous behaviour of gjs_parse_args(), but maybe we want
  * to box primitive types instead of throwing? */
+GNUC_ALWAYS_INLINE
 static inline void
 assign(JSContext              *cx,
        char                    c,
@@ -82,6 +91,7 @@ assign(JSContext              *cx,
     ref.set(&value.toObject());
 }
 
+GNUC_ALWAYS_INLINE
 static inline void
 assign(JSContext      *cx,
        char            c,
@@ -103,7 +113,7 @@ assign(JSContext      *cx,
         throw g_strdup_printf("Wrong type for %c, got char**", c);
     }
 }
-
+GNUC_ALWAYS_INLINE
 static inline void
 assign(JSContext      *cx,
        char            c,
@@ -119,6 +129,7 @@ assign(JSContext      *cx,
         throw g_strdup("Couldn't convert to integer");
 }
 
+GNUC_ALWAYS_INLINE
 static inline void
 assign(JSContext      *cx,
        char            c,
@@ -139,6 +150,7 @@ assign(JSContext      *cx,
     *ref = num;
 }
 
+GNUC_ALWAYS_INLINE
 static inline void
 assign(JSContext      *cx,
        char            c,
@@ -154,6 +166,7 @@ assign(JSContext      *cx,
         throw g_strdup("Couldn't convert to 64-bit integer");
 }
 
+GNUC_ALWAYS_INLINE
 static inline void
 assign(JSContext      *cx,
        char            c,
@@ -173,6 +186,7 @@ assign(JSContext      *cx,
  * prevent instantiation for any other types besides pointer-to-enum */
 template<typename T,
          typename std::enable_if<std::is_enum<T>::value, int>::type = 0>
+GNUC_ALWAYS_INLINE
 static inline void
 assign(JSContext      *cx,
        char            c,
@@ -198,6 +212,7 @@ template<typename T,
 static inline void
 free_if_necessary(T param_ref) {}
 
+GNUC_ALWAYS_INLINE
 static inline void
 free_if_necessary(JS::MutableHandleObject param_ref)
 {
@@ -207,6 +222,7 @@ free_if_necessary(JS::MutableHandleObject param_ref)
     param_ref.set(NULL);
 }
 
+GNUC_ALWAYS_INLINE
 static inline void
 free_if_necessary(char **param_ref)
 {
diff --git a/configure.ac b/configure.ac
index 8976b5d7..ea6ffe2d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -229,8 +229,6 @@ AS_IF([test "x$with_dbus_tests" != "xno"], [
 ])
 AM_CONDITIONAL([DBUS_TESTS], [test "x$with_dbus_tests" != "xno"])
 
-AX_APPEND_COMPILE_FLAGS(['--param inline-unit-growth=50'])
-
 AC_SUBST([gjsjsdir], [\${datadir}/cjs-1.0])
 
 dnl automake 1.11/1.12 defines this but does not substitute it

From 6a9aae541b29dd1347a8b60efdfad5f60b5c9a84 Mon Sep 17 00:00:00 2001
From: Patrick Griffis <tingping@tingping.se>
Date: Fri, 28 Apr 2017 04:54:18 -0400
Subject: [PATCH 006/154] package: Support running Meson projects from source

The run_target() function in Meson sets these variables allowing
you to simply create a target that can be ran with ninja.

See also: http://mesonbuild.com/Reference-manual.html#run_target

https://bugzilla.gnome.org/show_bug.cgi?id=781883
---
 modules/package.js | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/modules/package.js b/modules/package.js
index fa1d5a82..ca167c2d 100644
--- a/modules/package.js
+++ b/modules/package.js
@@ -59,6 +59,11 @@ function _runningFromSource() {
     return binary.equal(sourceBinary);
 }
 
+function _runningFromMesonSource() {
+    return GLib.getenv('MESON_BUILD_ROOT') &&
+           GLib.getenv('MESON_SOURCE_ROOT');
+}
+
 function _makeNamePath(name) {
     return '/' + name.replace('.', '/', 'g');
 }
@@ -132,6 +137,23 @@ function init(params) {
         pkgdatadir = GLib.build_filenamev([_base, 'data']);
         localedir = GLib.build_filenamev([_base, 'po']);
         moduledir = GLib.build_filenamev([_base, 'src']);
+    } else if (_runningFromMesonSource()) {
+        log('Running from Meson, using local files');
+        let bld = GLib.getenv('MESON_BUILD_ROOT');
+        let src = GLib.getenv('MESON_SOURCE_ROOT');
+
+        pkglibdir = libpath = girpath = GLib.build_filenamev([bld, 'lib']);
+        pkgdatadir = GLib.build_filenamev([bld, 'data']);
+        localedir = GLib.build_filenamev([bld, 'po']);
+
+        try {
+            let resource = Gio.Resource.load(GLib.build_filenamev([bld, 'src',
+                                                                  name + '.src.gresource']));
+            resource._register();
+            moduledir = 'resource://' + _makeNamePath(name) + '/js';
+        } catch(e) {
+            moduledir = GLib.build_filenamev([src, 'src']);
+        }
     } else {
         _base = prefix;
         pkglibdir = GLib.build_filenamev([libdir, _pkgname]);

From 5e1a30a530a24331fbdc8722667317e40eac6405 Mon Sep 17 00:00:00 2001
From: Patrick Griffis <tingping@tingping.se>
Date: Tue, 2 May 2017 08:36:02 -0400
Subject: [PATCH 008/154] package: Fix initSubmodule() with Meson.

Meson enforces that submodules go under a subprojects directory.

https://bugzilla.gnome.org/show_bug.cgi?id=782065
---
 modules/package.js | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/modules/package.js b/modules/package.js
index ca167c2d..87bbe6b2 100644
--- a/modules/package.js
+++ b/modules/package.js
@@ -44,6 +44,7 @@ var localedir;
 /*< private >*/
 let _pkgname;
 let _base;
+let _submoduledir;
 
 function _findEffectiveEntryPointName() {
     let entryPoint = System.programInvocationName;
@@ -131,6 +132,7 @@ function init(params) {
         log('Running from source tree, using local files');
         // Running from source directory
         _base = GLib.get_current_dir();
+        _submoduledir = _base;
         pkglibdir = GLib.build_filenamev([_base, 'lib']);
         libpath = GLib.build_filenamev([pkglibdir, '.libs']);
         girpath = pkglibdir;
@@ -145,6 +147,7 @@ function init(params) {
         pkglibdir = libpath = girpath = GLib.build_filenamev([bld, 'lib']);
         pkgdatadir = GLib.build_filenamev([bld, 'data']);
         localedir = GLib.build_filenamev([bld, 'po']);
+        _submoduledir = GLib.build_filenamev([bld, 'subprojects']);
 
         try {
             let resource = Gio.Resource.load(GLib.build_filenamev([bld, 'src',
@@ -259,8 +262,12 @@ function initSubmodule(name) {
     if (moduledir != pkgdatadir) {
         // Running from source tree, add './name' to search paths
 
-        let submoduledir = GLib.build_filenamev([_base, name]);
-        let libpath = GLib.build_filenamev([submoduledir, '.libs']);
+        let submoduledir = GLib.build_filenamev([_submoduledir, name]);
+        let libpath;
+        if (_runningFromMesonSource())
+            libpath = submoduledir;
+        else
+            libpath = GLib.build_filenamev([submoduledir, '.libs']);
         GIRepository.Repository.prepend_search_path(submoduledir);
         GIRepository.Repository.prepend_library_path(libpath);
     } else {

From e595569a34136e00f975b669e0d72f652d4d3fd5 Mon Sep 17 00:00:00 2001
From: Patrick Griffis <tingping@tingping.se>
Date: Tue, 2 May 2017 08:51:39 -0400
Subject: [PATCH 009/154] package: Don't rely upon directory configuration for
 initSubmodule()

This leads to an incorrect state where `moduledir` is a gresource
path and initSubmodule() then behaves like it is being ran from
within source.

https://bugzilla.gnome.org/show_bug.cgi?id=782065
---
 modules/package.js | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/modules/package.js b/modules/package.js
index 87bbe6b2..ca4dfe82 100644
--- a/modules/package.js
+++ b/modules/package.js
@@ -259,7 +259,7 @@ function initFormat() {
 }
 
 function initSubmodule(name) {
-    if (moduledir != pkgdatadir) {
+    if (_runningFromMesonSource() || _runningFromSource()) {
         // Running from source tree, add './name' to search paths
 
         let submoduledir = GLib.build_filenamev([_submoduledir, name]);

From 8b23159cf404bb9aa46f6605b05841314a5171d1 Mon Sep 17 00:00:00 2001
From: Patrick Griffis <tingping@tingping.se>
Date: Tue, 2 May 2017 09:33:58 -0400
Subject: [PATCH 010/154] package: Set GSETTINGS_SCHEMA_DIR when ran from
 source

This allows using GSettings without having it installed.

https://bugzilla.gnome.org/show_bug.cgi?id=782069
---
 modules/package.js | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/modules/package.js b/modules/package.js
index ca4dfe82..93adce4f 100644
--- a/modules/package.js
+++ b/modules/package.js
@@ -139,6 +139,8 @@ function init(params) {
         pkgdatadir = GLib.build_filenamev([_base, 'data']);
         localedir = GLib.build_filenamev([_base, 'po']);
         moduledir = GLib.build_filenamev([_base, 'src']);
+
+        GLib.setenv('GSETTINGS_SCHEMA_DIR', pkgdatadir, true);
     } else if (_runningFromMesonSource()) {
         log('Running from Meson, using local files');
         let bld = GLib.getenv('MESON_BUILD_ROOT');
@@ -149,6 +151,7 @@ function init(params) {
         localedir = GLib.build_filenamev([bld, 'po']);
         _submoduledir = GLib.build_filenamev([bld, 'subprojects']);
 
+        GLib.setenv('GSETTINGS_SCHEMA_DIR', pkgdatadir, true);
         try {
             let resource = Gio.Resource.load(GLib.build_filenamev([bld, 'src',
                                                                   name + '.src.gresource']));

From 8cf3e41de31be2488c3fe9dc135ffd77e0936954 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Mon, 1 May 2017 23:16:43 -0700
Subject: [PATCH 011/154] build: Autodetect SpiderMonkey's debug mode

We currently check whether JS_DEBUG was defined in js-config.h in order to
decide whether to define DEBUG. (It's a long-standing bug in SpiderMonkey
headers that you have to define DEBUG before including them if SpiderMonkey
is in debug mode.)

That will not be possible in SpiderMonkey 52. In an effort to mitigate the
bug, it will error out if you include js-config.h without defining DEBUG
when you are supposed to (or having defined DEBUG when you are not supposed
to.) So, our method of checking will not work anymore.

Instead, run a configure-time check that generates an #error if JS_DEBUG is
defined in js-config.h, and define a symbol in config.h. This check will
also work in the SpiderMonkey 52 case, since including js-config.h will
also error out if JS_DEBUG is defined.

https://bugzilla.gnome.org/show_bug.cgi?id=781429
---
 cjs/jsapi-wrapper.h |  7 +++++--
 configure.ac        | 17 +++++++++++++++++
 2 files changed, 22 insertions(+), 2 deletions(-)

diff --git a/cjs/jsapi-wrapper.h b/cjs/jsapi-wrapper.h
index 9c64ec6c..11bdadbd 100644
--- a/cjs/jsapi-wrapper.h
+++ b/cjs/jsapi-wrapper.h
@@ -25,13 +25,16 @@
 #ifndef GJS_JSAPI_WRAPPER_H
 #define GJS_JSAPI_WRAPPER_H
 
-#include <js-config.h>  /* SpiderMonkey's #defines that affect public API */
+#include <config.h>
+
 /* COMPAT: SpiderMonkey headers in some places use DEBUG instead of JS_DEBUG */
 /* https://bugzilla.mozilla.org/show_bug.cgi?id=1261161 */
-#if defined(JS_DEBUG) && JS_DEBUG
+#ifdef HAVE_DEBUG_SPIDERMONKEY
 #define DEBUG 1
 #endif
 
+#include <js-config.h>  /* SpiderMonkey's #defines that affect public API */
+
 #if defined(__clang__) || __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)
 #pragma GCC system_header
 #endif
diff --git a/configure.ac b/configure.ac
index ea6ffe2d..352dc236 100644
--- a/configure.ac
+++ b/configure.ac
@@ -199,6 +199,23 @@ AC_ARG_ENABLE([Bsymbolic],
 AS_IF([test "x$enable_Bsymbolic" != "xno"],
   [AX_APPEND_LINK_FLAGS([-Bsymbolic-functions])])
 
+dnl If SpiderMonkey was compiled with --enable-debug, then we need to define
+dnl -DDEBUG before including js-config.h.
+AC_MSG_CHECKING([whether SpiderMonkey was configured with --enable-debug])
+CPPFLAGS_save="$CPPFLAGS"
+CPPFLAGS="$GJS_CFLAGS"
+AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
+#include <js-config.h>
+#ifdef JS_DEBUG
+#error debug yes, if we didn't already error out due to DEBUG not being defined
+#endif
+]])], [AC_MSG_RESULT([no])], [
+  AC_DEFINE([HAVE_DEBUG_SPIDERMONKEY], [1],
+    [Define to 1 if SpiderMonkey was compiled with --enable-debug])
+  AC_MSG_RESULT([yes])
+])
+CPPFLAGS="$CPPFLAGS_save"
+
 dnl If SpiderMonkey was compiled with this configure option, then GJS needs to
 dnl be compiled with it as well, because we inherit from a SpiderMonkey class in
 dnl jsapi-constructor-proxy.cpp. See build/autoconf/compiler-opts.m4 in mozjs31.

From f808dc3e478c83cf37d8df1825c097d535bcbb72 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 2 May 2017 21:02:47 -0700
Subject: [PATCH 012/154] context: Use GThread to determine owner thread

The thread facilities are going away in SpiderMonkey 52, so we use GThread
to determine a context's owner thread in order to be able to check it
later. (g_thread_self() will still work if GLib didn't create the thread.)

https://bugzilla.gnome.org/show_bug.cgi?id=781429
---
 cjs/context.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/cjs/context.cpp b/cjs/context.cpp
index 0c563d1d..d1532c43 100644
--- a/cjs/context.cpp
+++ b/cjs/context.cpp
@@ -69,7 +69,7 @@ struct _GjsContext {
     JSRuntime *runtime;
     JSContext *context;
     JS::Heap<JSObject*> global;
-    intptr_t owner_thread;
+    GThread *owner_thread;
 
     char *program_name;
 
@@ -487,7 +487,7 @@ gjs_context_constructed(GObject *object)
     js_context->runtime = gjs_runtime_ref();
 
     JS_AbortIfWrongThread(js_context->runtime);
-    js_context->owner_thread = JS_GetCurrentThread();
+    js_context->owner_thread = g_thread_self();
 
     js_context->context = JS_NewContext(js_context->runtime, 8192 /* stack chunk size */);
     if (js_context->context == NULL)
@@ -666,7 +666,7 @@ context_reset_exit(GjsContext *js_context)
 bool
 _gjs_context_get_is_owner_thread(GjsContext *js_context)
 {
-    return js_context->owner_thread == JS_GetCurrentThread();
+    return js_context->owner_thread == g_thread_self();
 }
 
 /**

From bca18ee8a0e8935fd4d13349825189dc9067f204 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 2 May 2017 21:26:09 -0700
Subject: [PATCH 013/154] jsapi-constructor-proxy: Inherit from js::Wrapper

js::DirectProxyHandler and js::Wrapper are supposedly the same, except
that js::Wrapper can expose the object it's wrapping to C++ code. We don't
use that functionality. However, js::DirectProxyHandler is being removed
in SpiderMonkey 52 in favour of js::Wrapper, so it makes sense to switch.

https://bugzilla.gnome.org/show_bug.cgi?id=781429
---
 cjs/jsapi-constructor-proxy.cpp | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/cjs/jsapi-constructor-proxy.cpp b/cjs/jsapi-constructor-proxy.cpp
index 0a2569c5..6bb59b25 100644
--- a/cjs/jsapi-constructor-proxy.cpp
+++ b/cjs/jsapi-constructor-proxy.cpp
@@ -23,9 +23,11 @@
  * Authored by: Philip Chimento <philip@endlessm.com>
  */
 
+#include "jsapi-wrapper.h"
+#include <jswrapper.h>
+
 #include "jsapi-constructor-proxy.h"
 #include "jsapi-util.h"
-#include "jsapi-wrapper.h"
 #include "mem.h"
 #include "util/log.h"
 
@@ -64,8 +66,6 @@
  */
 
 static const char constructor_proxy_create_name[] = "__private_GjsConstructorProxy";
-/* This char's address is an arbitrary identifier for use in debugging */
-static const char constructor_proxy_family = 'p';
 
 enum {
     SLOT_PROTO,
@@ -74,7 +74,7 @@ enum {
 /* This class is the C++ equivalent of a proxy handler object. In JS, that is
  * the second argument passed to the "new Proxy(target, handler)" constructor.
  */
-class GjsConstructorHandler : public js::DirectProxyHandler {
+class GjsConstructorHandler : public js::Wrapper {
     static inline JSObject *
     proto(JS::HandleObject proxy)
     {
@@ -83,7 +83,7 @@ class GjsConstructorHandler : public js::DirectProxyHandler {
 
 public:
     GjsConstructorHandler()
-    : js::DirectProxyHandler(&constructor_proxy_family, true /* hasPrototype */)
+    : js::Wrapper(0 /* flags */, true /* hasPrototype */)
     { }
 
     bool

From 698fbbe63f885900621c294dcd845f65e2f84f4e Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 2 May 2017 21:27:50 -0700
Subject: [PATCH 014/154] system: Switch from JS::CallReceiver to JS::CallArgs

JS::CallReceiver is going away in SpiderMonkey 52. It was a version of
JS::CallArgs that didn't care about the number of arguments passed to the
function. We already use JS::CallArgs everywhere else, so this is not a
problem.

https://bugzilla.gnome.org/show_bug.cgi?id=781429
---
 modules/system.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/modules/system.cpp b/modules/system.cpp
index 11fcec7c..80bcb8eb 100644
--- a/modules/system.cpp
+++ b/modules/system.cpp
@@ -130,7 +130,7 @@ gjs_clear_date_caches(JSContext *context,
                       unsigned   argc,
                       JS::Value *vp)
 {
-    JS::CallReceiver rec = JS::CallReceiverFromVp(vp);
+    JS::CallArgs rec = JS::CallArgsFromVp(argc, vp);
     JS_BeginRequest(context);
 
     // Workaround for a bug in SpiderMonkey where tzset is not called before

From 20b699d142a72a1ac49cc54b207d9d963676c009 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 2 May 2017 21:12:06 -0700
Subject: [PATCH 015/154] coverage: Root using context, not runtime

JSRuntime is going away in SpiderMonkey 52, so we should stop using the
constructor of JS::Rooted<T> that takes JSRuntime instead of JSContext.
There were a few instances where it was used.

https://bugzilla.gnome.org/show_bug.cgi?id=781429
---
 cjs/coverage.cpp | 30 ++++++++++++------------------
 1 file changed, 12 insertions(+), 18 deletions(-)

diff --git a/cjs/coverage.cpp b/cjs/coverage.cpp
index 7a89c2e6..3a1598c2 100644
--- a/cjs/coverage.cpp
+++ b/cjs/coverage.cpp
@@ -995,12 +995,11 @@ gjs_serialize_statistics(GjsCoverage *coverage)
 {
     GjsCoveragePrivate *priv = (GjsCoveragePrivate *) gjs_coverage_get_instance_private(coverage);
     JSContext *js_context = (JSContext *) gjs_context_get_native_context(priv->context);
-    JSRuntime *js_runtime = JS_GetRuntime(js_context);
 
     JSAutoRequest ar(js_context);
     JSAutoCompartment ac(js_context, priv->coverage_statistics);
     JS::RootedObject rooted_priv(js_context, priv->coverage_statistics);
-    JS::RootedValue string_value_return(js_runtime);
+    JS::RootedValue string_value_return(js_context);
 
     if (!JS_CallFunctionName(js_context, rooted_priv, "stringify",
                              JS::HandleValueArray::empty(),
@@ -1068,7 +1067,7 @@ gjs_deserialize_cache_to_object(GjsCoverage *coverage,
     JSContext *context = (JSContext *) gjs_context_get_native_context(priv->context);
     JSAutoRequest ar(context);
     JSAutoCompartment ac(context, priv->coverage_statistics);
-    JS::RootedObject global_object(JS_GetRuntime(context),
+    JS::RootedObject global_object(context,
                                    JS_GetGlobalForObject(context, priv->coverage_statistics));
     return gjs_deserialize_cache_to_object_for_compartment(context, global_object, cache_data);
 }
@@ -1086,7 +1085,7 @@ gjs_fetch_statistics_from_js(GjsCoverage *coverage,
     g_array_set_clear_func(file_statistics_array,
                            gjs_coverage_statistics_file_statistics_clear);
 
-    JS::RootedObject rooted_coverage_statistics(JS_GetRuntime(js_context),
+    JS::RootedObject rooted_coverage_statistics(js_context,
                                                 priv->coverage_statistics);
 
     char **file_iter = coverage_files;
@@ -1429,7 +1428,6 @@ coverage_get_file_checksum(JSContext *context,
                            JS::Value *vp)
 {
     JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
-    JSRuntime *runtime = JS_GetRuntime(context);
     GFile *file = get_file_from_call_args_filename(context, args);
 
     if (!file)
@@ -1445,9 +1443,7 @@ coverage_get_file_checksum(JSContext *context,
         return false;
     }
 
-    JS::RootedString rooted_checksum(runtime, JS_NewStringCopyZ(context,
-                                                                checksum));
-    args.rval().setString(rooted_checksum);
+    args.rval().setString(JS_NewStringCopyZ(context, checksum));
 
     g_object_unref(file);
     g_free(checksum);
@@ -1548,7 +1544,7 @@ gjs_inject_value_into_coverage_compartment(GjsCoverage     *coverage,
     JSAutoRequest ar(js_context);
     JSAutoCompartment ac(js_context, priv->coverage_statistics);
 
-    JS::RootedObject coverage_global_scope(JS_GetRuntime(js_context),
+    JS::RootedObject coverage_global_scope(js_context,
                                            JS_GetGlobalForObject(js_context, priv->coverage_statistics));
 
     if (!JS_SetProperty(js_context, coverage_global_scope, property,
@@ -1568,14 +1564,12 @@ gjs_wrap_root_importer_in_compartment(JSContext *context,
 {
     JSAutoRequest ar(context);
     JSAutoCompartment ac(context, compartment);
-    JS::RootedValue importer (JS_GetRuntime(context),
-                              gjs_get_global_slot(context,
-                                                  GJS_GLOBAL_SLOT_IMPORTS));
+    JS::RootedValue importer(context,
+        gjs_get_global_slot(context, GJS_GLOBAL_SLOT_IMPORTS));
 
-    g_assert (!importer.isUndefined());
+    g_assert(importer.isObject());
 
-    JS::RootedObject wrapped_importer(JS_GetRuntime(context),
-                                      importer.toObjectOrNull());
+    JS::RootedObject wrapped_importer(context, &importer.toObject());
     if (!JS_WrapObject(context, &wrapped_importer)) {
         return NULL;
     }
@@ -1597,7 +1591,7 @@ bootstrap_coverage(GjsCoverage *coverage)
     JSObject *debuggee = gjs_get_import_global(context);
     JS::CompartmentOptions options;
     options.setVersion(JSVERSION_LATEST);
-    JS::RootedObject debugger_compartment(JS_GetRuntime(context),
+    JS::RootedObject debugger_compartment(context,
         JS_NewGlobalObject(context, &coverage_global_class, NULL,
                            JS::FireOnNewGlobalHook, options));
     {
@@ -1630,7 +1624,7 @@ bootstrap_coverage(GjsCoverage *coverage)
             return false;
         }
 
-        JS::RootedObject wrapped_importer(JS_GetRuntime(context),
+        JS::RootedObject wrapped_importer(context,
                                           gjs_wrap_root_importer_in_compartment(context,
                                                                                 debugger_compartment));;
 
@@ -1777,7 +1771,7 @@ gjs_clear_js_side_statistics_from_coverage_object(GjsCoverage *coverage)
         JSAutoRequest ar(js_context);
         JSAutoCompartment ac(js_context, priv->coverage_statistics);
         JS::RootedObject rooted_priv(js_context, priv->coverage_statistics);
-        JS::RootedValue rval(JS_GetRuntime(js_context));
+        JS::RootedValue rval(js_context);
         if (!JS_CallFunctionName(js_context, rooted_priv, "deactivate",
                                  JS::HandleValueArray::empty(), &rval)) {
             gjs_log_exception(js_context);

From e3df3586e64f4e62c177346c89c7de46a161c486 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Florian=20M=C3=BCllner?= <fmuellner@gnome.org>
Date: Fri, 3 Mar 2017 21:01:21 +0100
Subject: [PATCH 016/154] package: Add checkSymbol() to check for symbol
 availability

GI allows to specify the API version to import, but not a minimum
version of said API. This can lead to hard to track down bugs at
runtime, in particular when the failure doesn't trigger a warning
or exception (for example when setting a non-existent GObject
property).
To address this, add a checkSymbols() method that test whether a
library can be imported and contains a particular symbol.

https://bugzilla.gnome.org/show_bug.cgi?id=779593
---
 Makefile-test.am                  |  1 +
 installed-tests/js/testPackage.js | 83 +++++++++++++++++++++++++++++++++++++++
 modules/package.js                | 57 +++++++++++++++++++++++++++
 3 files changed, 141 insertions(+)
 create mode 100644 installed-tests/js/testPackage.js

diff --git a/Makefile-test.am b/Makefile-test.am
index d9a1efa7..b351f167 100644
--- a/Makefile-test.am
+++ b/Makefile-test.am
@@ -238,6 +238,7 @@ common_jstests_files =						\
 	installed-tests/js/testMainloop.js			\
 	installed-tests/js/testMetaClass.js			\
 	installed-tests/js/testNamespace.js			\
+	installed-tests/js/testPackage.js			\
 	installed-tests/js/testParamSpec.js			\
 	installed-tests/js/testSignals.js			\
 	installed-tests/js/testSystem.js			\
diff --git a/installed-tests/js/testPackage.js b/installed-tests/js/testPackage.js
new file mode 100644
index 00000000..bcaf3db4
--- /dev/null
+++ b/installed-tests/js/testPackage.js
@@ -0,0 +1,83 @@
+const Pkg = imports.package;
+
+describe('Package module', function () {
+    it('finds an existing library', function () {
+        expect(Pkg.checkSymbol('Regress', '1.0')).toEqual(true);
+    });
+
+    it('doesn\'t find a non-existent library', function () {
+        expect(Pkg.checkSymbol('Rägräss', '1.0')).toEqual(false);
+    });
+
+    it('finds a function', function () {
+        expect(Pkg.checkSymbol('Regress', '1.0', 'get_variant')).toEqual(true);
+    });
+
+    it('doesn\'t find a non-existent function', function () {
+        expect(Pkg.checkSymbol('Regress', '1.0', 'get_väriänt')).toEqual(false);
+    });
+
+    it('finds a class', function () {
+        expect(Pkg.checkSymbol('Regress', '1.0', 'TestObj')).toEqual(true);
+    });
+
+    it('doesn\'t find a non-existent class', function () {
+        expect(Pkg.checkSymbol('Regress', '1.0', 'TestNoObj')).toEqual(false);
+    });
+
+    it('finds a property', function () {
+        expect(Pkg.checkSymbol('Regress', '1.0', 'TestObj.bare')).toEqual(true);
+    });
+
+    it('doesn\'t find a non-existent property', function () {
+        expect(Pkg.checkSymbol('Regress', '1.0', 'TestObj.bäre')).toEqual(false);
+    });
+
+    it('finds a static function', function () {
+        expect(Pkg.checkSymbol('Regress', '1.0', 'TestObj.static_method')).toEqual(true);
+    });
+
+    it('doesn\'t find a non-existent static function', function () {
+        expect(Pkg.checkSymbol('Regress', '1.0', 'TestObj.stätic_methöd')).toEqual(false);
+    });
+
+    it('finds a method', function () {
+        expect(Pkg.checkSymbol('Regress', '1.0', 'TestObj.null_out')).toEqual(true);
+    });
+
+    it('doesn\'t find a non-existent method', function () {
+        expect(Pkg.checkSymbol('Regress', '1.0', 'TestObj.nüll_out')).toEqual(false);
+    });
+
+    it('finds an interface', function () {
+        expect(Pkg.checkSymbol('GIMarshallingTests', '1.0', 'Interface')).toEqual(true);
+    });
+
+    it('doesn\'t find a non-existent interface', function () {
+        expect(Pkg.checkSymbol('GIMarshallingTests', '1.0', 'Interfäce')).toEqual(false);
+    });
+
+    it('finds an interface method', function () {
+        expect(Pkg.checkSymbol('GIMarshallingTests', '1.0', 'Interface.test_int8_in')).toEqual(true);
+    });
+
+    it('doesn\'t find a non-existent interface method', function () {
+        expect(Pkg.checkSymbol('GIMarshallingTests', '1.0', 'Interface.test_int42_in')).toEqual(false);
+    });
+
+    it('finds an enum value', function () {
+        expect(Pkg.checkSymbol('Regress', '1.0', 'TestEnum.VALUE1')).toEqual(true);
+    });
+
+    it('doesn\'t find a non-existent enum value', function () {
+        expect(Pkg.checkSymbol('Regress', '1.0', 'TestEnum.value1')).toEqual(false);
+    });
+
+    it('finds a constant', function () {
+        expect(Pkg.checkSymbol('Regress', '1.0', 'BOOL_CONSTANT')).toEqual(true);
+    });
+
+    it('doesn\'t find a non-existent constant', function () {
+        expect(Pkg.checkSymbol('Regress', '1.0', 'BööL_CONSTANT')).toEqual(false);
+    });
+});
diff --git a/modules/package.js b/modules/package.js
index 93adce4f..03fceaae 100644
--- a/modules/package.js
+++ b/modules/package.js
@@ -26,6 +26,7 @@
 const GLib = imports.gi.GLib;
 const GIRepository = imports.gi.GIRepository;
 const Gio = imports.gi.Gio;
+const GObject = imports.gi.GObject;
 const System = imports.system;
 
 const Gettext = imports.gettext;
@@ -246,6 +247,62 @@ function require(libs) {
     }
 }
 
+/**
+ * checkSymbol:
+ * @lib: an external dependency to import
+ * @version: optional version of the dependency
+ * @symbol: optional symbol to check for
+ *
+ * Check whether an external GI typelib can be imported
+ * and provides @symbol.
+ *
+ * Symbols may refer to
+ *  - global functions         ('main_quit')
+ *  - classes                  ('Window')
+ *  - class / instance methods ('IconTheme.get_default' / 'IconTheme.has_icon')
+ *  - GObject properties       ('Window.default_height')
+ *
+ * Returns: %true if @lib can be imported and provides @symbol, %false otherwise
+ */
+function checkSymbol(lib, version, symbol) {
+    let Lib = null;
+
+    if (version)
+        imports.gi.versions[lib] = version;
+
+    try {
+        Lib = imports.gi[lib];
+    } catch(e) {
+        return false;
+    }
+
+    if (!symbol)
+        return true; // Done
+
+    let [klass, sym] = symbol.split('.');
+    if (klass === symbol) // global symbol
+        return (typeof Lib[symbol] !== 'undefined');
+
+    let obj = Lib[klass];
+    if (typeof obj === 'undefined')
+        return false;
+
+    if (typeof obj[sym] !== 'undefined' ||
+        (obj.prototype && typeof obj.prototype[sym] !== 'undefined'))
+        return true; // class- or object method
+
+    // GObject property
+    let pspec = null;
+    if (GObject.type_is_a(obj.$gtype, GObject.TYPE_INTERFACE)) {
+        let iface = GObject.type_default_interface_ref(obj.$gtype);
+        pspec = GObject.Object.interface_find_property(iface, sym);
+    } else if (GObject.type_is_a(obj.$gtype, GObject.TYPE_OBJECT)) {
+        pspec = GObject.Object.find_property.call(obj.$gtype, sym);
+    }
+
+    return (pspec !== null);
+}
+
 function initGettext() {
     Gettext.bindtextdomain(_pkgname, localedir);
     Gettext.textdomain(_pkgname);

From c34070aa4efdb598ca6a9f24284468b7e9552f63 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Florian=20M=C3=BCllner?= <fmuellner@gnome.org>
Date: Fri, 3 Mar 2017 21:01:21 +0100
Subject: [PATCH 017/154] package: Add requireSymbol() method

While the existing require() method provides a convenient way
to check for hard dependencies, it only tests whether a particular
typelib can be imported. The newly added checkSymbol() method on
the other hand allows for finer-grained tests, but leaves it to
the caller to check the return value. Fill that gap by providing
a requireSymbol() method that wraps checkSymbol() to error out
when the dependency is not satisfied.

https://bugzilla.gnome.org/show_bug.cgi?id=779593
---
 modules/package.js | 27 ++++++++++++++++-----------
 1 file changed, 16 insertions(+), 11 deletions(-)

diff --git a/modules/package.js b/modules/package.js
index 03fceaae..5a5cd22a 100644
--- a/modules/package.js
+++ b/modules/package.js
@@ -232,18 +232,23 @@ function run(module) {
  * indicates any version.
  */
 function require(libs) {
-    for (let l in libs) {
-        let version = libs[l];
-
-        if (version != '')
-            imports.gi.versions[l] = version;
+    for (let l in libs)
+        requireSymbol(l, libs[l]);
+}
 
-        try {
-            imports.gi[l];
-        } catch(e) {
-            printerr('Unsatisfied dependency: ' + e.message);
-            System.exit(1);
-        }
+/**
+ * requireSymbol:
+ *
+ * As checkSymbol(), but exit with an error if the
+ * dependency cannot be satisfied.
+ */
+function requireSymbol(lib, version, symbol) {
+    if (!checkSymbol(lib, version, symbol)) {
+        if (symbol)
+            printerr(`Unsatisfied dependency: No ${symbol} in ${lib}`);
+        else
+            printerr(`Unsatisfied dependency: ${lib}`);
+        System.exit(1);
     }
 }
 

From 973582b80f26d6d2c57e25b77ccfe2960f0c03b2 Mon Sep 17 00:00:00 2001
From: Patrick Griffis <tingping@tingping.se>
Date: Sun, 7 May 2017 22:06:59 -0400
Subject: [PATCH 018/154] overrides: Implement Gio.ListStore[Symbol.iterator]

https://bugzilla.gnome.org/show_bug.cgi?id=782310
---
 Makefile-test.am              |  1 +
 installed-tests/js/testGio.js | 30 ++++++++++++++++++++++++++++++
 modules/overrides/Gio.js      | 11 +++++++++++
 3 files changed, 42 insertions(+)
 create mode 100644 installed-tests/js/testGio.js

diff --git a/Makefile-test.am b/Makefile-test.am
index b351f167..509b5925 100644
--- a/Makefile-test.am
+++ b/Makefile-test.am
@@ -231,6 +231,7 @@ common_jstests_files =						\
 	installed-tests/js/testGObjectClass.js			\
 	installed-tests/js/testGObjectInterface.js		\
 	installed-tests/js/testGTypeClass.js			\
+	installed-tests/js/testGio.js				\
 	installed-tests/js/testImporter.js			\
 	installed-tests/js/testInterface.js			\
 	installed-tests/js/testLang.js				\
diff --git a/installed-tests/js/testGio.js b/installed-tests/js/testGio.js
new file mode 100644
index 00000000..107221dc
--- /dev/null
+++ b/installed-tests/js/testGio.js
@@ -0,0 +1,30 @@
+const Gio = imports.gi.Gio;
+const GObject = imports.gi.GObject;
+const Lang = imports.lang;
+
+const Foo = new Lang.Class({
+    Name: 'Foo',
+    Extends: GObject.Object,
+    _init: function (value) {
+        this.parent();
+        this.value = value;
+    }
+});
+
+describe('ListStore iterator', function () {
+    let list;
+
+    beforeEach(function () {
+        list = new Gio.ListStore({item_type: Foo});
+        for (let i = 0; i < 100; i++) {
+            list.append(new Foo(i));
+        }
+    });
+
+    it('ListStore iterates', function () {
+        let i = 0;
+        for (let f of list) {
+            expect(f.value).toBe(i++);
+        }
+    });
+});
\ No newline at end of file
diff --git a/modules/overrides/Gio.js b/modules/overrides/Gio.js
index 3801da05..7f3ae275 100644
--- a/modules/overrides/Gio.js
+++ b/modules/overrides/Gio.js
@@ -340,6 +340,14 @@ function _wrapJSObject(interfaceInfo, jsObj) {
     return impl;
 }
 
+function* _listModelIterator() {
+    let _index = 0;
+    const _len = this.get_n_items();
+    while (_index < _len) {
+        yield this.get_item(_index++);
+    }
+}
+
 function _init() {
     Gio = this;
 
@@ -391,4 +399,7 @@ function _init() {
 
     Gio.DBusExportedObject = CjsPrivate.DBusImplementation;
     Gio.DBusExportedObject.wrapJSObject = _wrapJSObject;
+
+    // ListStore
+    Gio.ListStore.prototype[Symbol.iterator] = _listModelIterator;
 }

From 612cdefcea113b7b9602ec3164b049df0f1c3c63 Mon Sep 17 00:00:00 2001
From: Juan Pablo Ugarte <ugarte@endlessm.com>
Date: Wed, 15 Mar 2017 17:57:53 +0000
Subject: [PATCH 020/154] modules/system.cpp: added dumpHeapComplete() method

---
 modules/system.cpp | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/modules/system.cpp b/modules/system.cpp
index 80bcb8eb..b09f5e9c 100644
--- a/modules/system.cpp
+++ b/modules/system.cpp
@@ -96,6 +96,30 @@ gjs_breakpoint(JSContext *context,
     return true;
 }
 
+static bool
+gjs_dump_heap(JSContext *cx,
+              unsigned   argc,
+              JS::Value *vp)
+{
+    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
+    char *filename = nullptr;
+
+    if (!gjs_parse_call_args(cx, "dumpHeap", args, "|F", "filename", &filename))
+        return false;
+
+    if (filename) {
+        FILE *fp = fopen(filename, "a");
+        js::DumpHeapComplete(JS_GetRuntime(cx), fp, js::IgnoreNurseryObjects);
+        fclose(fp);
+        g_free(filename);
+    } else {
+        js::DumpHeapComplete(JS_GetRuntime(cx), stdout, js::IgnoreNurseryObjects);
+    }
+
+    args.rval().setUndefined();
+    return true;
+}
+
 static bool
 gjs_gc(JSContext *context,
        unsigned   argc,
@@ -148,6 +172,7 @@ static JSFunctionSpec module_funcs[] = {
     JS_FS("addressOf", gjs_address_of, 1, GJS_MODULE_PROP_FLAGS),
     JS_FS("refcount", gjs_refcount, 1, GJS_MODULE_PROP_FLAGS),
     JS_FS("breakpoint", gjs_breakpoint, 0, GJS_MODULE_PROP_FLAGS),
+    JS_FS("dumpHeap", gjs_dump_heap, 1, GJS_MODULE_PROP_FLAGS),
     JS_FS("gc", gjs_gc, 0, GJS_MODULE_PROP_FLAGS),
     JS_FS("exit", gjs_exit, 0, GJS_MODULE_PROP_FLAGS),
     JS_FS("clearDateCaches", gjs_clear_date_caches, 0, GJS_MODULE_PROP_FLAGS),

From d7f93d20def672da4abb8464d43957a2c6a82bc2 Mon Sep 17 00:00:00 2001
From: Chun-wei Fan <fanchunwei@src.gnome.org>
Date: Wed, 19 Apr 2017 23:35:48 +0800
Subject: [PATCH 021/154] Use std::unique_ptr instead of g_autofree/g_autoptr()

This completes the transition of the code to std::unique_ptr so that we
can be assured that we use JS_free() on items that are acquired via
pass-by-reference via SpiderMonkey APIs, and thus we can remove more of
the g_free() calls on those as SpiderMonkey may switch to a different
allocation/deallocation implementation internally (which is currently
free()).

https://bugzilla.gnome.org/show_bug.cgi?id=777597
---
 cjs/byteArray.cpp         |  29 ++++--------
 cjs/context.cpp           |   9 ++--
 cjs/coverage.cpp          |  29 ++++++------
 cjs/importer.cpp          |  36 +++++----------
 cjs/jsapi-util-args.h     |   9 +++-
 cjs/jsapi-util-string.cpp |  23 ++++------
 cjs/jsapi-util.cpp        |  65 +++++++++++++--------------
 cjs/jsapi-util.h          |  61 ++++++++++++++++++++++++--
 cjs/runtime.cpp           |  19 +++-----
 cjs/stack.cpp             |   5 +--
 gi/arg.cpp                |  49 +++++++++------------
 gi/boxed.cpp              |  23 +++-------
 gi/fundamental.cpp        |  12 ++---
 gi/interface.cpp          |   9 +---
 gi/ns.cpp                 |   7 +--
 gi/object.cpp             | 109 +++++++++++++++++-----------------------------
 gi/param.cpp              |   4 +-
 gi/repo.cpp               |   6 +--
 gi/union.cpp              |   9 +---
 gi/value.cpp              |   4 +-
 test/gjs-tests.cpp        |   6 +--
 21 files changed, 228 insertions(+), 295 deletions(-)

diff --git a/cjs/byteArray.cpp b/cjs/byteArray.cpp
index 3f551509..89211e0b 100644
--- a/cjs/byteArray.cpp
+++ b/cjs/byteArray.cpp
@@ -405,7 +405,7 @@ to_string_func(JSContext *context,
                JS::Value *vp)
 {
     GJS_GET_PRIV(context, argc, vp, argv, to, ByteArrayInstance, priv);
-    char *encoding;
+    GjsAutoJSChar encoding(context);
     bool encoding_is_utf8;
     gchar *data;
 
@@ -422,13 +422,7 @@ to_string_func(JSContext *context,
          * doesn't matter much though. encoding_is_utf8 is
          * just an optimization anyway.
          */
-        if (strcmp(encoding, "UTF-8") == 0) {
-            encoding_is_utf8 = true;
-            g_free(encoding);
-            encoding = NULL;
-        } else {
-            encoding_is_utf8 = false;
-        }
+        encoding_is_utf8 = (strcmp(encoding, "UTF-8") == 0);
     } else {
         encoding_is_utf8 = true;
     }
@@ -461,7 +455,6 @@ to_string_func(JSContext *context,
                            NULL, /* bytes read */
                            &bytes_written,
                            &error);
-        g_free(encoding);
         if (u16_str == NULL) {
             /* frees the GError */
             gjs_throw_g_error(context, error);
@@ -534,7 +527,7 @@ from_string_func(JSContext *context,
 {
     JS::CallArgs argv = JS::CallArgsFromVp (argc, vp);
     ByteArrayInstance *priv;
-    char *encoding;
+    GjsAutoJSChar encoding(context);
     bool encoding_is_utf8;
     JS::RootedObject obj(context, byte_array_new(context));
 
@@ -562,13 +555,7 @@ from_string_func(JSContext *context,
          * doesn't matter much though. encoding_is_utf8 is
          * just an optimization anyway.
          */
-        if (strcmp(encoding, "UTF-8") == 0) {
-            encoding_is_utf8 = true;
-            g_free(encoding);
-            encoding = NULL;
-        } else {
-            encoding_is_utf8 = false;
-        }
+        encoding_is_utf8 = (strcmp(encoding, "UTF-8") == 0);
     } else {
         encoding_is_utf8 = true;
     }
@@ -577,15 +564,16 @@ from_string_func(JSContext *context,
         /* optimization? avoids iconv overhead and runs
          * libmozjs hardwired utf16-to-utf8.
          */
-        char *utf8 = NULL;
+        GjsAutoJSChar utf8(context);
         if (!gjs_string_to_utf8(context,
                                 argv[0],
                                 &utf8))
             return false;
 
         g_byte_array_set_size(priv->array, 0);
-        g_byte_array_append(priv->array, (guint8*) utf8, strlen(utf8));
-        g_free(utf8);
+        g_byte_array_append(priv->array,
+                            reinterpret_cast<const guint8*>(utf8.get()),
+                            strlen(utf8));
     } else {
         JSString *str = argv[0].toString();  /* Rooted by argv */
         GError *error = NULL;
@@ -623,7 +611,6 @@ from_string_func(JSContext *context,
             }
         }
 
-        g_free(encoding);
         if (encoded == NULL) {
             /* frees the GError */
             gjs_throw_g_error(context, error);
diff --git a/cjs/context.cpp b/cjs/context.cpp
index d1532c43..6f0ed2e9 100644
--- a/cjs/context.cpp
+++ b/cjs/context.cpp
@@ -119,7 +119,6 @@ gjs_log(JSContext *context,
         JS::Value *vp)
 {
     JS::CallArgs argv = JS::CallArgsFromVp (argc, vp);
-    char *s;
 
     if (argc != 1) {
         gjs_throw(context, "Must pass a single argument to log()");
@@ -140,13 +139,12 @@ gjs_log(JSContext *context,
         return true;
     }
 
+    GjsAutoJSChar s(context);
     if (!gjs_string_to_utf8(context, JS::StringValue(jstr), &s)) {
         JS_EndRequest(context);
         return false;
     }
-
-    g_message("JS LOG: %s", s);
-    g_free(s);
+    g_message("JS LOG: %s", s.get());
 
     JS_EndRequest(context);
     argv.rval().setUndefined();
@@ -190,7 +188,6 @@ gjs_print_parse_args(JSContext *context,
                      char     **buffer)
 {
     GString *str;
-    gchar *s;
     guint n;
 
     JS_BeginRequest(context);
@@ -204,6 +201,7 @@ gjs_print_parse_args(JSContext *context,
         exc_state.restore();
 
         if (jstr != NULL) {
+            GjsAutoJSChar s(context);
             if (!gjs_string_to_utf8(context, JS::StringValue(jstr), &s)) {
                 JS_EndRequest(context);
                 g_string_free(str, true);
@@ -211,7 +209,6 @@ gjs_print_parse_args(JSContext *context,
             }
 
             g_string_append(str, s);
-            g_free(s);
             if (n < (argv.length()-1))
                 g_string_append_c(str, ' ');
         } else {
diff --git a/cjs/coverage.cpp b/cjs/coverage.cpp
index 3a1598c2..c474efad 100644
--- a/cjs/coverage.cpp
+++ b/cjs/coverage.cpp
@@ -493,11 +493,11 @@ get_executed_lines_for(JSContext        *context,
 
 static void
 init_covered_function(GjsCoverageFunction *function,
-                      char                *key,
+                      const char          *key,
                       unsigned int        line_number,
                       unsigned int        hit_count)
 {
-    function->key = key;
+    function->key = g_strdup(key);
     function->line_number = line_number;
     function->hit_count = hit_count;
 }
@@ -543,7 +543,7 @@ convert_and_insert_function_decl(GArray         *array,
                                      &function_name_property_value))
         return false;
 
-    char *utf8_string;
+    GjsAutoJSChar utf8_string(context);
 
     if (function_name_property_value.isString()) {
         if (!gjs_string_to_utf8(context,
@@ -552,9 +552,7 @@ convert_and_insert_function_decl(GArray         *array,
             gjs_throw(context, "Failed to convert function_name to string");
             return false;
         }
-    } else if (function_name_property_value.isNull()) {
-        utf8_string = NULL;
-    } else {
+    } else if (!function_name_property_value.isNull()) {
         gjs_throw(context, "Unexpected type for function_name");
         return false;
     }
@@ -869,14 +867,14 @@ get_covered_files(GjsCoverage *coverage)
     files = g_new0(char *, n_files + 1);
     JS::RootedValue element(context);
     for (uint32_t i = 0; i < n_files; i++) {
-        char *file;
+        GjsAutoJSChar file(context);
         if (!JS_GetElement(context, files_obj, i, &element))
             goto error;
 
         if (!gjs_string_to_utf8(context, element, &file))
             goto error;
 
-        files[i] = file;
+        files[i] = file.copy();
     }
 
     files[n_files] = NULL;
@@ -1012,7 +1010,7 @@ gjs_serialize_statistics(GjsCoverage *coverage)
         return NULL;
 
     /* Free'd by g_bytes_new_take */
-    char *statistics_as_json_string = NULL;
+    GjsAutoJSChar statistics_as_json_string(js_context);
 
     if (!gjs_string_to_utf8(js_context,
                             string_value_return.get(),
@@ -1021,8 +1019,12 @@ gjs_serialize_statistics(GjsCoverage *coverage)
         return NULL;
     }
 
-    return g_bytes_new_take((guint8 *) statistics_as_json_string,
-                            strlen(statistics_as_json_string));
+    int json_string_len = strlen(statistics_as_json_string);
+    auto json_bytes =
+        reinterpret_cast<uint8_t*>(statistics_as_json_string.copy());
+
+    return g_bytes_new_take(json_bytes,
+                            json_string_len);
 }
 
 static JSString *
@@ -1333,7 +1335,7 @@ coverage_log(JSContext *context,
              JS::Value *vp)
 {
     JS::CallArgs argv = JS::CallArgsFromVp (argc, vp);
-    char *s;
+    GjsAutoJSChar s(context);
     JSExceptionState *exc_state;
 
     if (argc != 1) {
@@ -1366,8 +1368,7 @@ coverage_log(JSContext *context,
         return false;
     }
 
-    g_message("JS COVERAGE MESSAGE: %s", s);
-    g_free(s);
+    g_message("JS COVERAGE MESSAGE: %s", s.get());
 
     argv.rval().setUndefined();
     return true;
diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index 8a495b78..6f8c64d8 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -75,7 +75,7 @@ importer_to_string(JSContext *cx,
                                  &module_path))
         return false;
 
-    char *path = NULL;
+    GjsAutoJSChar path(cx);
     GjsAutoChar output;
 
     if (module_path.isNull()) {
@@ -83,11 +83,10 @@ importer_to_string(JSContext *cx,
     } else {
         if (!gjs_string_to_utf8(cx, module_path, &path))
             return false;
-        output = g_strdup_printf("[%s %s]", klass->name, path);
+        output = g_strdup_printf("[%s %s]", klass->name, path.get());
     }
 
     args.rval().setString(JS_NewStringCopyZ(cx, output));
-    g_free(path);
     return true;
 }
 
@@ -139,11 +138,10 @@ define_meta_properties(JSContext       *context,
         if (parent_module_path.isNull()) {
             module_path_buf = g_strdup(module_name);
         } else {
-            char *parent_path = NULL;
+            GjsAutoJSChar parent_path(context);
             if (!gjs_string_to_utf8(context, parent_module_path, &parent_path))
                 return false;
-            module_path_buf = g_strdup_printf("%s.%s", parent_path, module_name);
-            g_free(parent_path);
+            module_path_buf = g_strdup_printf("%s.%s", parent_path.get(), module_name);
         }
         module_path.setString(JS_NewStringCopyZ(context, module_path_buf));
     }
@@ -286,13 +284,12 @@ module_to_string(JSContext *cx,
 
     g_assert(!module_path.isNull());
 
-    char *path = NULL;
+    GjsAutoJSChar path(cx);
     if (!gjs_string_to_utf8(cx, module_path, &path))
         return false;
-    GjsAutoChar output = g_strdup_printf("[GjsModule %s]", path);
+    GjsAutoChar output = g_strdup_printf("[GjsModule %s]", path.get());
 
     args.rval().setString(JS_NewStringCopyZ(cx, output));
-    g_free(path);
     return true;
 }
 
@@ -514,7 +511,6 @@ do_import(JSContext       *context,
 {
     char *filename;
     char *full_path;
-    char *dirname = NULL;
     JS::RootedObject search_path(context);
     guint32 search_path_len;
     guint32 i;
@@ -556,6 +552,8 @@ do_import(JSContext       *context,
     }
 
     for (i = 0; i < search_path_len; ++i) {
+        GjsAutoJSChar dirname(context);
+
         elem.setUndefined();
         if (!JS_GetElement(context, search_path, i, &elem)) {
             /* this means there was an exception, while elem.isUndefined()
@@ -572,9 +570,6 @@ do_import(JSContext       *context,
             goto out;
         }
 
-        g_free(dirname);
-        dirname = NULL;
-
         if (!gjs_string_to_utf8(context, elem, &dirname))
             goto out; /* Error message already set */
 
@@ -628,7 +623,7 @@ do_import(JSContext       *context,
         if (!exists) {
             gjs_debug(GJS_DEBUG_IMPORTER,
                       "JS import '%s' not found in %s",
-                      name, dirname);
+                      name, dirname.get());
 
             g_object_unref(gfile);
             continue;
@@ -677,7 +672,6 @@ do_import(JSContext       *context,
 
     g_free(full_path);
     g_free(filename);
-    g_free(dirname);
 
     if (!result &&
         !JS_IsExceptionPending(context)) {
@@ -727,7 +721,7 @@ importer_enumerate(JSContext        *context,
 
     JS::RootedValue elem(context);
     for (i = 0; i < search_path_len; ++i) {
-        char *dirname = NULL;
+        GjsAutoJSChar dirname(context);
         char *init_path;
 
         elem.setUndefined();
@@ -757,7 +751,6 @@ importer_enumerate(JSContext        *context,
 
         /* new_for_commandline_arg handles resource:/// paths */
         GjsAutoUnref<GFile> dir = g_file_new_for_commandline_arg(dirname);
-        g_free(dirname);
         GjsAutoUnref<GFileEnumerator> direnum =
             g_file_enumerate_children(dir, G_FILE_ATTRIBUTE_STANDARD_TYPE,
                                       G_FILE_QUERY_INFO_NONE, NULL, NULL);
@@ -809,8 +802,8 @@ importer_resolve(JSContext        *context,
                  bool             *resolved)
 {
     Importer *priv;
-    char *name = NULL;
     jsid module_init_name;
+    GjsAutoJSChar name(context);
 
     module_init_name = gjs_context_get_const_string(context, GJS_STRING_MODULE_INIT);
     if (id == module_init_name) {
@@ -826,7 +819,6 @@ importer_resolve(JSContext        *context,
         strcmp(name, "toString") == 0 ||
         strcmp(name, "__iterator__") == 0) {
         *resolved = false;
-        g_free(name);
         return true;
     }
     priv = priv_from_js(context, obj);
@@ -837,18 +829,14 @@ importer_resolve(JSContext        *context,
     if (priv == NULL) {
         /* we are the prototype, or have the wrong class */
         *resolved = false;
-        g_free(name);
         return true;
     }
 
     JSAutoRequest ar(context);
-    if (!do_import(context, obj, priv, name)) {
-        g_free(name);
+    if (!do_import(context, obj, priv, name))
         return false;
-    }
 
     *resolved = true;
-    g_free(name);
     return true;
 }
 
diff --git a/cjs/jsapi-util-args.h b/cjs/jsapi-util-args.h
index c572fab0..1fb3ec79 100644
--- a/cjs/jsapi-util-args.h
+++ b/cjs/jsapi-util-args.h
@@ -103,15 +103,20 @@ assign(JSContext      *cx,
         *ref = NULL;
         return;
     }
+
+    GjsAutoJSChar tmp_ref(cx);
+
     if (c == 's') {
-        if (!gjs_string_to_utf8(cx, value, ref))
+        if (!gjs_string_to_utf8(cx, value, &tmp_ref))
             throw g_strdup("Couldn't convert to string");
     } else if (c == 'F') {
-        if (!gjs_string_to_filename(cx, value, ref))
+        if (!gjs_string_to_filename(cx, value, &tmp_ref))
             throw g_strdup("Couldn't convert to filename");
     } else {
         throw g_strdup_printf("Wrong type for %c, got char**", c);
     }
+
+    *ref = tmp_ref.copy();
 }
 GNUC_ALWAYS_INLINE
 static inline void
diff --git a/cjs/jsapi-util-string.cpp b/cjs/jsapi-util-string.cpp
index a0be7b8f..e01d5952 100644
--- a/cjs/jsapi-util-string.cpp
+++ b/cjs/jsapi-util-string.cpp
@@ -32,10 +32,9 @@
 bool
 gjs_string_to_utf8 (JSContext      *context,
                     const JS::Value value,
-                    char          **utf8_string_p)
+                    GjsAutoJSChar  *utf8_string_p)
 {
     gsize len;
-    char *bytes;
 
     JS_BeginRequest(context);
 
@@ -54,10 +53,7 @@ gjs_string_to_utf8 (JSContext      *context,
         return false;
     }
 
-    if (utf8_string_p) {
-        bytes = JS_EncodeStringToUTF8(context, str);
-        *utf8_string_p = bytes;
-    }
+    utf8_string_p->reset(context, JS_EncodeStringToUTF8(context, str));
 
     JS_EndRequest(context);
 
@@ -106,10 +102,11 @@ gjs_string_from_utf8(JSContext             *context,
 bool
 gjs_string_to_filename(JSContext      *context,
                        const JS::Value filename_val,
-                       char          **filename_string_p)
+                       GjsAutoJSChar  *filename_string_p)
 {
     GError *error;
-    gchar *tmp, *filename_string;
+    GjsAutoJSChar tmp(context);
+    char *filename_string;
 
     /* gjs_string_to_filename verifies that filename_val is a string */
 
@@ -122,12 +119,10 @@ gjs_string_to_filename(JSContext      *context,
     filename_string = g_filename_from_utf8(tmp, -1, NULL, NULL, &error);
     if (!filename_string) {
         gjs_throw_g_error(context, error);
-        g_free(tmp);
         return false;
     }
 
-    *filename_string_p = filename_string;
-    g_free(tmp);
+    filename_string_p->reset(context, filename_string);
     return true;
 }
 
@@ -352,7 +347,7 @@ gjs_string_from_ucs4(JSContext             *cx,
 bool
 gjs_get_string_id (JSContext       *context,
                    jsid             id,
-                   char           **name_p)
+                   GjsAutoJSChar   *name_p)
 {
     JS::RootedValue id_val(context);
 
@@ -362,7 +357,6 @@ gjs_get_string_id (JSContext       *context,
     if (id_val.isString()) {
         return gjs_string_to_utf8(context, id_val, name_p);
     } else {
-        *name_p = NULL;
         return false;
     }
 }
@@ -384,10 +378,9 @@ gjs_unichar_from_string (JSContext *context,
                          JS::Value  value,
                          gunichar  *result)
 {
-    char *utf8_str;
+    GjsAutoJSChar utf8_str(context);
     if (gjs_string_to_utf8(context, value, &utf8_str)) {
         *result = g_utf8_get_char(utf8_str);
-        g_free(utf8_str);
         return true;
     }
     return false;
diff --git a/cjs/jsapi-util.cpp b/cjs/jsapi-util.cpp
index 900b1b48..7c7de731 100644
--- a/cjs/jsapi-util.cpp
+++ b/cjs/jsapi-util.cpp
@@ -211,17 +211,15 @@ throw_property_lookup_error(JSContext       *cx,
     /* remember gjs_throw() is a no-op if JS_GetProperty()
      * already set an exception
      */
-    char *name;
+    GjsAutoJSChar name(cx);
     gjs_get_string_id(cx, property_name, &name);
 
     if (description)
-        gjs_throw(cx, "No property '%s' in %s (or %s)", name, description,
+        gjs_throw(cx, "No property '%s' in %s (or %s)", name.get(), description,
                   reason);
     else
-        gjs_throw(cx, "No property '%s' in object %p (or %s)", name,
+        gjs_throw(cx, "No property '%s' in object %p (or %s)", name.get(),
                   obj.address(), reason);
-
-    g_free(name);
 }
 
 /* Returns whether the object had the property; if the object did
@@ -302,8 +300,10 @@ gjs_object_require_property(JSContext       *cx,
                             char           **value)
 {
     JS::RootedValue prop_value(cx);
+    GjsAutoJSChar value_tmp(cx);
     if (JS_GetPropertyById(cx, obj, property_name, &prop_value) &&
-        gjs_string_to_utf8(cx, prop_value, value)) {
+        gjs_string_to_utf8(cx, prop_value, &value_tmp)) {
+        *value = value_tmp.copy();
         return true;
     }
 
@@ -432,7 +432,7 @@ gjs_string_readable (JSContext   *context,
                      JSString    *string)
 {
     GString *buf = g_string_new("");
-    char *chars;
+    GjsAutoJSChar chars(context);
 
     JS_BeginRequest(context);
 
@@ -454,7 +454,6 @@ gjs_string_readable (JSContext   *context,
         g_free(escaped);
     } else {
         g_string_append(buf, chars);
-        g_free(chars);
     }
 
     g_string_append_c(buf, '"');
@@ -565,11 +564,11 @@ static char *
 utf8_exception_from_non_gerror_value(JSContext      *cx,
                                      JS::HandleValue exc)
 {
-    char *utf8_exception = NULL;
+    GjsAutoJSChar utf8_exception(cx);
     JS::RootedString exc_str(cx, JS::ToString(cx, exc));
     if (exc_str != NULL)
         gjs_string_to_utf8(cx, JS::StringValue(exc_str), &utf8_exception);
-    return utf8_exception;
+    return utf8_exception.copy();
 }
 
 bool
@@ -577,7 +576,8 @@ gjs_log_exception_full(JSContext       *context,
                        JS::HandleValue  exc,
                        JS::HandleString message)
 {
-    char *utf8_exception, *utf8_message;
+    char *utf8_exception;
+    GjsAutoJSChar utf8_message(context);
     bool is_syntax;
 
     JS_BeginRequest(context);
@@ -596,7 +596,7 @@ gjs_log_exception_full(JSContext       *context,
                                              gerror->message);
         } else {
             JS::RootedValue js_name(context);
-            char *utf8_name;
+            GjsAutoJSChar utf8_name(context);
 
             if (gjs_object_get_property(context, exc_obj,
                                         GJS_STRING_NAME, &js_name) &&
@@ -611,8 +611,6 @@ gjs_log_exception_full(JSContext       *context,
 
     if (message != NULL)
         gjs_string_to_utf8(context, JS::StringValue(message), &utf8_message);
-    else
-        utf8_message = NULL;
 
     /* We log syntax errors differently, because the stack for those includes
        only the referencing module, but we want to print out the filename and
@@ -622,7 +620,7 @@ gjs_log_exception_full(JSContext       *context,
     if (is_syntax) {
         JS::RootedValue js_lineNumber(context), js_fileName(context);
         unsigned lineNumber;
-        char *utf8_fileName;
+        GjsAutoJSChar utf8_filename(context);
 
         gjs_object_get_property(context, exc_obj, GJS_STRING_LINE_NUMBER,
                                 &js_lineNumber);
@@ -630,50 +628,47 @@ gjs_log_exception_full(JSContext       *context,
                                 &js_fileName);
 
         if (js_fileName.isString())
-            gjs_string_to_utf8(context, js_fileName, &utf8_fileName);
+            gjs_string_to_utf8(context, js_fileName, &utf8_filename);
         else
-            utf8_fileName = g_strdup("unknown");
+            utf8_filename.reset(context, JS_strdup(context, "unknown"));
 
         lineNumber = js_lineNumber.toInt32();
 
-        if (utf8_message) {
-            g_critical("JS ERROR: %s: %s @ %s:%u", utf8_message, utf8_exception,
-                       utf8_fileName, lineNumber);
+        if (message != NULL) {
+            g_critical("JS ERROR: %s: %s @ %s:%u", utf8_message.get(), utf8_exception,
+                       utf8_filename.get(), lineNumber);
         } else {
             g_critical("JS ERROR: %s @ %s:%u", utf8_exception,
-                       utf8_fileName, lineNumber);
+                       utf8_filename.get(), lineNumber);
         }
 
-        g_free(utf8_fileName);
     } else {
-        char *utf8_stack;
+        GjsAutoJSChar utf8_stack(context);
         JS::RootedValue stack(context);
+        bool have_utf8_stack = false;
 
         if (exc.isObject() &&
             gjs_object_get_property(context, exc_obj, GJS_STRING_STACK,
                                     &stack) &&
-            stack.isString())
+            stack.isString()) {
             gjs_string_to_utf8(context, stack, &utf8_stack);
-        else
-            utf8_stack = NULL;
+            have_utf8_stack = true;
+        }
 
-        if (utf8_message) {
-            if (utf8_stack)
-                g_warning("JS ERROR: %s: %s\n%s", utf8_message, utf8_exception, utf8_stack);
+        if (message != nullptr) {
+            if (have_utf8_stack)
+                g_warning("JS ERROR: %s: %s\n%s", utf8_message.get(), utf8_exception, utf8_stack.get());
             else
-                g_warning("JS ERROR: %s: %s", utf8_message, utf8_exception);
+                g_warning("JS ERROR: %s: %s", utf8_message.get(), utf8_exception);
         } else {
-            if (utf8_stack)
-                g_warning("JS ERROR: %s\n%s", utf8_exception, utf8_stack);
+            if (have_utf8_stack)
+                g_warning("JS ERROR: %s\n%s", utf8_exception, utf8_stack.get());
             else
                 g_warning("JS ERROR: %s", utf8_exception);
         }
-
-        g_free(utf8_stack);
     }
 
     g_free(utf8_exception);
-    g_free(utf8_message);
 
     JS_EndRequest(context);
 
diff --git a/cjs/jsapi-util.h b/cjs/jsapi-util.h
index a0971647..0d268cd7 100644
--- a/cjs/jsapi-util.h
+++ b/cjs/jsapi-util.h
@@ -60,6 +60,61 @@ class GjsAutoUnref : public std::unique_ptr<T, decltype(&g_object_unref)> {
     }
 };
 
+class GjsJSFreeArgs {
+private:
+    JSContext *m_cx;
+
+public:
+    explicit GjsJSFreeArgs(JSContext *cx) : m_cx(cx)
+    {}
+
+    void operator() (char *str) {
+        JS_free(m_cx, str);
+    }
+
+    JSContext* get_context() {
+        return m_cx;
+    }
+
+    void set_context(JSContext *cx) {
+        m_cx = cx;
+    }
+};
+
+class GjsAutoJSChar {
+private:
+    std::unique_ptr<char, GjsJSFreeArgs> m_ptr;
+
+public:
+    GjsAutoJSChar(JSContext *cx, char *str = nullptr)
+    : m_ptr (str, GjsJSFreeArgs(cx)) {
+        g_assert(cx != nullptr);
+    }
+
+    operator const char*() {
+        return m_ptr.get();
+    }
+
+    const char* get() {
+        return m_ptr.get();
+    }
+
+    char* copy() {
+        /* Strings acquired by this should be g_free()'ed */
+        return g_strdup(m_ptr.get());
+    }
+
+    char* js_copy() {
+        /* Strings acquired by this should be JS_free()'ed */
+        return JS_strdup(m_ptr.get_deleter().get_context(), m_ptr.get());
+    }
+
+    void reset(JSContext *cx, char *str) {
+        m_ptr.get_deleter().set_context(cx);
+        m_ptr.reset(str);
+    }
+};
+
 G_BEGIN_DECLS
 
 #define GJS_UTIL_ERROR gjs_util_error_quark ()
@@ -184,7 +239,7 @@ void        gjs_error_reporter               (JSContext       *context,
 
 bool        gjs_string_to_utf8               (JSContext       *context,
                                               const JS::Value  string_val,
-                                              char           **utf8_string_p);
+                                              GjsAutoJSChar   *utf8_string_p);
 bool gjs_string_from_utf8(JSContext             *context,
                           const char            *utf8_string,
                           ssize_t                n_bytes,
@@ -192,7 +247,7 @@ bool gjs_string_from_utf8(JSContext             *context,
 
 bool        gjs_string_to_filename           (JSContext       *context,
                                               const JS::Value  string_val,
-                                              char           **filename_string_p);
+                                              GjsAutoJSChar   *filename_string_p);
 bool gjs_string_from_filename(JSContext             *context,
                               const char            *filename_string,
                               ssize_t                n_bytes,
@@ -214,7 +269,7 @@ bool gjs_string_from_ucs4(JSContext             *cx,
 
 bool        gjs_get_string_id                (JSContext       *context,
                                               jsid             id,
-                                              char           **name_p);
+                                              GjsAutoJSChar   *name_p);
 jsid        gjs_intern_string_to_id          (JSContext       *context,
                                               const char      *string);
 
diff --git a/cjs/runtime.cpp b/cjs/runtime.cpp
index 5a81638f..eb9677b5 100644
--- a/cjs/runtime.cpp
+++ b/cjs/runtime.cpp
@@ -57,7 +57,7 @@ gjs_locale_to_upper_case (JSContext *context,
                           JS::MutableHandleValue retval)
 {
     bool success = false;
-    char *utf8 = NULL;
+    GjsAutoJSChar utf8(context);
     char *upper_case_utf8 = NULL;
 
     if (!gjs_string_to_utf8(context, JS::StringValue(src), &utf8))
@@ -71,7 +71,6 @@ gjs_locale_to_upper_case (JSContext *context,
     success = true;
 
 out:
-    g_free(utf8);
     g_free(upper_case_utf8);
 
     return success;
@@ -83,7 +82,7 @@ gjs_locale_to_lower_case (JSContext *context,
                           JS::MutableHandleValue retval)
 {
     bool success = false;
-    char *utf8 = NULL;
+    GjsAutoJSChar utf8(context);
     char *lower_case_utf8 = NULL;
 
     if (!gjs_string_to_utf8(context, JS::StringValue(src), &utf8))
@@ -97,7 +96,6 @@ gjs_locale_to_lower_case (JSContext *context,
     success = true;
 
 out:
-    g_free(utf8);
     g_free(lower_case_utf8);
 
     return success;
@@ -109,22 +107,15 @@ gjs_locale_compare (JSContext *context,
                     JS::HandleString src_2,
                     JS::MutableHandleValue retval)
 {
-    bool success = false;
-    char *utf8_1 = NULL, *utf8_2 = NULL;
+    GjsAutoJSChar utf8_1(context), utf8_2(context);
 
     if (!gjs_string_to_utf8(context, JS::StringValue(src_1), &utf8_1) ||
         !gjs_string_to_utf8(context, JS::StringValue(src_2), &utf8_2))
-        goto out;
+        return false;
 
     retval.setInt32(g_utf8_collate(utf8_1, utf8_2));
 
-    success = true;
-
-out:
-    g_free(utf8_1);
-    g_free(utf8_2);
-
-    return success;
+    return true;
 }
 
 static bool
diff --git a/cjs/stack.cpp b/cjs/stack.cpp
index e49a77fd..00963931 100644
--- a/cjs/stack.cpp
+++ b/cjs/stack.cpp
@@ -89,7 +89,7 @@ gjs_context_print_stack_stderr(GjsContext *context)
 {
     JSContext *cx = (JSContext*) gjs_context_get_native_context(context);
     JS::RootedValue v_stack(cx);
-    char *stack;
+    GjsAutoJSChar stack(cx);
 
     g_printerr("== Stack trace for context %p ==\n", context);
 
@@ -101,8 +101,7 @@ gjs_context_print_stack_stderr(GjsContext *context)
         return;
     }
 
-    g_printerr("%s\n", stack);
-    g_free(stack);
+    g_printerr("%s\n", stack.get());
 }
 
 void
diff --git a/gi/arg.cpp b/gi/arg.cpp
index 056ace38..3912b637 100644
--- a/gi/arg.cpp
+++ b/gi/arg.cpp
@@ -416,7 +416,7 @@ value_to_ghashtable_key(JSContext      *cx,
 
 #define HANDLE_STRING(type, lctype)                                   \
     case GI_TYPE_TAG_##type: {                                        \
-        char *cstr;                                                   \
+        GjsAutoJSChar cstr(cx);                                       \
         JS::RootedValue str_val(cx, value);                           \
         if (!str_val.isString()) {                                    \
             JS::RootedString str(cx, JS::ToString(cx, str_val));      \
@@ -424,7 +424,7 @@ value_to_ghashtable_key(JSContext      *cx,
         }                                                             \
         if (!gjs_string_to_##lctype(cx, str_val, &cstr))              \
             return false;                                             \
-        *pointer_out = cstr;                                          \
+        *pointer_out = cstr.copy();                                   \
         break;                                                        \
     }
 
@@ -610,6 +610,8 @@ gjs_array_to_strv(JSContext   *context,
     result = g_new0(char *, length+1);
 
     for (i = 0; i < length; ++i) {
+        GjsAutoJSChar tmp_result(context);
+
         elem = JS::UndefinedValue();
         if (!JS_GetElement(context, array, i, &elem)) {
             g_free(result);
@@ -625,10 +627,11 @@ gjs_array_to_strv(JSContext   *context,
             g_strfreev(result);
             return false;
         }
-        if (!gjs_string_to_utf8(context, elem, (char **)&(result[i]))) {
+        if (!gjs_string_to_utf8(context, elem, &tmp_result)) {
             g_strfreev(result);
             return false;
         }
+        result[i] = tmp_result.copy();
     }
 
     *arr_p = result;
@@ -644,16 +647,17 @@ gjs_string_to_intarray(JSContext   *context,
                        gsize       *length)
 {
     GITypeTag element_type;
-    char *result;
     char16_t *result16;
 
     element_type = g_type_info_get_tag(param_info);
 
     if (element_type == GI_TYPE_TAG_INT8 || element_type == GI_TYPE_TAG_UINT8) {
+        GjsAutoJSChar result(context);
+
         if (!gjs_string_to_utf8(context, string_val, &result))
             return false;
-        *arr_p = result;
         *length = strlen(result);
+        *arr_p = result.copy();
         return true;
     }
 
@@ -1463,10 +1467,9 @@ gjs_value_to_g_argument(JSContext      *context,
         if (value.isNull()) {
             arg->v_pointer = NULL;
         } else if (value.isString()) {
-            char *filename_str;
+            GjsAutoJSChar filename_str(context);
             if (gjs_string_to_filename(context, value, &filename_str))
-                // doing this as a separate step to avoid type-punning
-                arg->v_pointer = filename_str;
+                arg->v_pointer = filename_str.copy();
             else
                 wrong = true;
         } else {
@@ -1479,10 +1482,9 @@ gjs_value_to_g_argument(JSContext      *context,
         if (value.isNull()) {
             arg->v_pointer = NULL;
         } else if (value.isString()) {
-            char *utf8_str;
+            GjsAutoJSChar utf8_str(context);
             if (gjs_string_to_utf8(context, value, &utf8_str))
-                // doing this as a separate step to avoid type-punning
-                arg->v_pointer = utf8_str;
+                arg->v_pointer = utf8_str.copy();
             else
                 wrong = true;
         } else {
@@ -2523,9 +2525,7 @@ gjs_object_from_g_hash (JSContext             *context,
                         GHashTable            *hash)
 {
     GHashTableIter iter;
-    char     *keyutf8 = NULL;
     GArgument keyarg, valarg;
-    bool result;
 
     // a NULL hash table becomes a null JS value
     if (hash==NULL) {
@@ -2542,41 +2542,32 @@ gjs_object_from_g_hash (JSContext             *context,
     JS::RootedValue keyjs(context), valjs(context);
     JS::RootedString keystr(context);
 
-    result = false;
-
     g_hash_table_iter_init(&iter, hash);
     while (g_hash_table_iter_next
            (&iter, &keyarg.v_pointer, &valarg.v_pointer)) {
         if (!gjs_value_from_g_argument(context, &keyjs,
                                        key_param_info, &keyarg,
                                        true))
-            goto out;
+            return false;
 
         keystr = JS::ToString(context, keyjs);
         if (!keystr)
-            goto out;
+            return false;
 
+        GjsAutoJSChar keyutf8(context);
         if (!gjs_string_to_utf8(context, JS::StringValue(keystr), &keyutf8))
-            goto out;
+            return false;
 
         if (!gjs_value_from_g_argument(context, &valjs,
                                        val_param_info, &valarg,
                                        true))
-            goto out;
+            return false;
 
         if (!JS_DefineProperty(context, obj, keyutf8, valjs, JSPROP_ENUMERATE))
-            goto out;
-
-        g_free(keyutf8);
-        keyutf8 = NULL;
+            return false;
     }
 
-    result = true;
-
- out:
-    if (keyutf8) g_free(keyutf8);
-
-    return result;
+    return true;
 }
 
 static const int64_t MAX_SAFE_INT64 =
diff --git a/gi/boxed.cpp b/gi/boxed.cpp
index 3a73870a..21643df3 100644
--- a/gi/boxed.cpp
+++ b/gi/boxed.cpp
@@ -122,7 +122,7 @@ boxed_resolve(JSContext       *context,
               bool            *resolved)
 {
     Boxed *priv;
-    char *name = NULL;
+    GjsAutoJSChar name(context);
 
     if (!gjs_get_string_id(context, id, &name)) {
         *resolved = false;
@@ -133,10 +133,8 @@ boxed_resolve(JSContext       *context,
     gjs_debug_jsprop(GJS_DEBUG_GBOXED, "Resolve prop '%s' hook obj %p priv %p",
                      name, obj.get(), priv);
 
-    if (priv == NULL) {
-        g_free(name);
+    if (priv == nullptr)
         return false; /* wrong class */
-    }
 
     if (priv->gboxed == NULL) {
         /* We are the prototype, so look for methods and other class properties */
@@ -164,7 +162,6 @@ boxed_resolve(JSContext       *context,
                 if (gjs_define_function(context, obj, priv->gtype,
                                         (GICallableInfo *)method_info) == NULL) {
                     g_base_info_unref( (GIBaseInfo*) method_info);
-                    g_free(name);
                     return false;
                 }
 
@@ -185,7 +182,6 @@ boxed_resolve(JSContext       *context,
          */
         *resolved = false;
     }
-    g_free(name);
     return true;
 }
 
@@ -283,7 +279,7 @@ boxed_init_from_props(JSContext   *context,
     JS::RootedId prop_id(context);
     for (ix = 0, length = ids.length(); ix < length; ix++) {
         GIFieldInfo *field_info;
-        char *name = NULL;
+        GjsAutoJSChar name(context);
 
         if (!gjs_get_string_id(context, ids[ix], &name))
             return false;
@@ -291,8 +287,7 @@ boxed_init_from_props(JSContext   *context,
         field_info = (GIFieldInfo *) g_hash_table_lookup(priv->field_map, name);
         if (field_info == NULL) {
             gjs_throw(context, "No field %s on boxed type %s",
-                      name, g_base_info_get_name((GIBaseInfo *)priv->info));
-            g_free(name);
+                      name.get(), g_base_info_get_name((GIBaseInfo *)priv->info));
             return false;
         }
 
@@ -300,17 +295,11 @@ boxed_init_from_props(JSContext   *context,
          * doesn't know that */
         prop_id = ids[ix];
         if (!gjs_object_require_property(context, props, "property list",
-                                         prop_id, &value)) {
-            g_free(name);
+                                         prop_id, &value))
             return false;
-        }
 
-        if (!boxed_set_field_from_value(context, priv, field_info, value)) {
-            g_free(name);
+        if (!boxed_set_field_from_value(context, priv, field_info, value))
             return false;
-        }
-
-        g_free(name);
     }
 
     return true;
diff --git a/gi/fundamental.cpp b/gi/fundamental.cpp
index e750fc2d..f6748849 100644
--- a/gi/fundamental.cpp
+++ b/gi/fundamental.cpp
@@ -241,7 +241,7 @@ fundamental_instance_resolve_interface(JSContext       *context,
                                        JS::HandleObject obj,
                                        bool            *resolved,
                                        Fundamental     *proto_priv,
-                                       char            *name)
+                                       const char      *name)
 {
     GIFunctionInfo *method_info;
     bool ret;
@@ -301,7 +301,7 @@ fundamental_instance_resolve(JSContext       *context,
                              bool            *resolved)
 {
     FundamentalInstance *priv;
-    char *name = NULL;
+    GjsAutoJSChar name(context);
 
     if (!gjs_get_string_id(context, id, &name)) {
         *resolved = false;
@@ -313,10 +313,8 @@ fundamental_instance_resolve(JSContext       *context,
                      "Resolve prop '%s' hook obj %p priv %p",
                      name, obj.get(), priv);
 
-    if (priv == NULL) {
-        g_free(name);
+    if (priv == nullptr)
         return false; /* wrong class */
-    }
 
     if (!fundamental_is_prototype(priv)) {
         /* We are an instance, not a prototype, so look for
@@ -327,7 +325,6 @@ fundamental_instance_resolve(JSContext       *context,
          * hooks, not this resolve hook.
          */
         *resolved = false;
-        g_free(name);
         return true;
     }
 
@@ -356,7 +353,6 @@ fundamental_instance_resolve(JSContext       *context,
                           g_base_info_get_name((GIBaseInfo *) proto_priv->info));
                 g_base_info_unref((GIBaseInfo *) method_info);
                 *resolved = false;
-                g_free(name);
                 return true;
             }
 
@@ -369,7 +365,6 @@ fundamental_instance_resolve(JSContext       *context,
             if (gjs_define_function(context, obj, proto_priv->gtype,
                                     method_info) == NULL) {
                 g_base_info_unref((GIBaseInfo *) method_info);
-                g_free(name);
                 return false;
             }
 
@@ -384,7 +379,6 @@ fundamental_instance_resolve(JSContext       *context,
     bool status =
         fundamental_instance_resolve_interface(context, obj, resolved,
                                                proto_priv, name);
-    g_free(name);
     return status;
 }
 
diff --git a/gi/interface.cpp b/gi/interface.cpp
index bd44a19e..43573791 100644
--- a/gi/interface.cpp
+++ b/gi/interface.cpp
@@ -112,7 +112,7 @@ interface_resolve(JSContext       *context,
                   bool            *resolved)
 {
     Interface *priv;
-    char *name = NULL;
+    GjsAutoJSChar name(context);
     GIFunctionInfo *method_info;
 
     if (!gjs_get_string_id(context, id, &name)) {
@@ -122,17 +122,14 @@ interface_resolve(JSContext       *context,
 
     priv = priv_from_js(context, obj);
 
-    if (priv == NULL) {
-        g_free(name);
+    if (priv == nullptr)
         return false;
-    }
 
     /* If we have no GIRepository information then this interface was defined
      * from within GJS. In that case, it has no properties that need to be
      * resolved from within C code, as interfaces cannot inherit. */
     if (priv->info == NULL) {
         *resolved = false;
-        g_free(name);
         return true;
     }
 
@@ -144,7 +141,6 @@ interface_resolve(JSContext       *context,
                                     priv->gtype,
                                     (GICallableInfo*)method_info) == NULL) {
                 g_base_info_unref((GIBaseInfo*)method_info);
-                g_free(name);
                 return false;
             }
 
@@ -158,7 +154,6 @@ interface_resolve(JSContext       *context,
         *resolved = false;
     }
 
-    g_free(name);
     return true;
 }
 
diff --git a/gi/ns.cpp b/gi/ns.cpp
index c5aed31d..362314bc 100644
--- a/gi/ns.cpp
+++ b/gi/ns.cpp
@@ -55,7 +55,7 @@ ns_resolve(JSContext       *context,
            bool            *resolved)
 {
     Ns *priv;
-    char *name = NULL;
+    GjsAutoJSChar name(context);
     GIRepository *repo;
     GIBaseInfo *info;
     bool defined;
@@ -69,7 +69,6 @@ ns_resolve(JSContext       *context,
     if (strcmp(name, "valueOf") == 0 ||
         strcmp(name, "toString") == 0) {
         *resolved = false;
-        g_free(name);
         return true;
     }
 
@@ -80,7 +79,6 @@ ns_resolve(JSContext       *context,
 
     if (priv == NULL) {
         *resolved = false;  /* we are the prototype, or have the wrong class */
-        g_free(name);
         return true;
     }
 
@@ -89,7 +87,6 @@ ns_resolve(JSContext       *context,
     info = g_irepository_find_by_name(repo, priv->gi_namespace, name);
     if (info == NULL) {
         *resolved = false; /* No property defined, but no error either */
-        g_free(name);
         return true;
     }
 
@@ -107,14 +104,12 @@ ns_resolve(JSContext       *context,
                   g_base_info_get_name(info));
 
         g_base_info_unref(info);
-        g_free(name);
         return false;
     }
 
     /* we defined the property in this object? */
     g_base_info_unref(info);
     *resolved = defined;
-    g_free(name);
     return true;
 }
 
diff --git a/gi/object.cpp b/gi/object.cpp
index 51ef8343..8b67896f 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -391,8 +391,7 @@ object_instance_get_prop(JSContext              *context,
                          JS::MutableHandleValue  value_p)
 {
     ObjectInstance *priv;
-    char *name;
-    bool ret = true;
+    GjsAutoJSChar name(context);
 
     if (!gjs_get_string_id(context, id, &name))
         return true; /* not resolved, but no error */
@@ -402,28 +401,23 @@ object_instance_get_prop(JSContext              *context,
                      "Get prop '%s' hook obj %p priv %p",
                      name, obj.get(), priv);
 
-    if (priv == NULL) {
+    if (priv == nullptr)
         /* If we reach this point, either object_instance_new_resolve
          * did not throw (so name == "_init"), or the property actually
          * exists and it's not something we should be concerned with */
-        goto out;
-    }
+        return true;
+
     if (priv->gobj == NULL) /* prototype, not an instance. */
-        goto out;
+        return true;
 
-    ret = get_prop_from_g_param(context, obj, priv, name, value_p);
-    if (!ret)
-        goto out;
+    if (!get_prop_from_g_param(context, obj, priv, name, value_p))
+        return false;
 
     if (!value_p.isUndefined())
-        goto out;
+        return true;
 
     /* Fall back to fields */
-    ret = get_prop_from_field(context, obj, priv, name, value_p);
-
- out:
-    g_free(name);
-    return ret;
+    return get_prop_from_field(context, obj, priv, name, value_p);
 }
 
 static bool
@@ -510,7 +504,7 @@ object_instance_set_prop(JSContext              *context,
                          JS::MutableHandleValue  value_p)
 {
     ObjectInstance *priv;
-    char *name;
+    GjsAutoJSChar name(context);
     bool ret = true;
     bool g_param_was_set = false;
 
@@ -522,28 +516,23 @@ object_instance_set_prop(JSContext              *context,
                      "Set prop '%s' hook obj %p priv %p",
                      name, obj.get(), priv);
 
-    if (priv == NULL) {
+    if (priv == nullptr)
         /* see the comment in object_instance_get_prop() on this */
-        goto out;
-    }
+        return true;
+
     if (priv->gobj == NULL) /* prototype, not an instance. */
-        goto out;
+        return true;
 
     ret = set_g_param_from_prop(context, priv, name, g_param_was_set, value_p);
     if (g_param_was_set || !ret)
-        goto out;
-
-    ret = check_set_field_from_prop(context, priv, name, strict, value_p);
+        return ret;
 
     /* note that the prop will also have been set in JS, which I think
      * is OK, since we hook get and set so will always override that
      * value. We could also use JS_DefineProperty though and specify a
      * getter/setter maybe, don't know if that is better.
      */
-
- out:
-    g_free(name);
-    return ret;
+    return check_set_field_from_prop(context, priv, name, strict, value_p);
 }
 
 static bool
@@ -611,7 +600,7 @@ object_instance_resolve_no_info(JSContext       *context,
                                 JS::HandleObject obj,
                                 bool            *resolved,
                                 ObjectInstance  *priv,
-                                char            *name)
+                                const char      *name)
 {
     GIFunctionInfo *method_info;
     guint n_interfaces;
@@ -675,7 +664,7 @@ object_instance_resolve(JSContext       *context,
 {
     GIFunctionInfo *method_info;
     ObjectInstance *priv;
-    char *name = NULL;
+    GjsAutoJSChar name(context);
 
     if (!gjs_get_string_id(context, id, &name)) {
         *resolved = false;
@@ -704,13 +693,11 @@ object_instance_resolve(JSContext       *context,
          * check there.
          */
         *resolved = false;
-        g_free(name);
         return true;
     }
 
     if (priv->gobj != NULL) {
         *resolved = false;
-        g_free(name);
         return true;
     }
 
@@ -719,7 +706,6 @@ object_instance_resolve(JSContext       *context,
      * GType data, and then hope that *those* are introspectable. */
     if (priv->info == NULL) {
         bool status = object_instance_resolve_no_info(context, obj, resolved, priv, name);
-        g_free(name);
         return status;
     }
 
@@ -738,13 +724,12 @@ object_instance_resolve(JSContext       *context,
          * rest.
          */
 
-        const char *name_without_vfunc_ = &name[6];  /* lifetime tied to name */
+        const char *name_without_vfunc_ = &(name[6]);  /* lifetime tied to name */
         GIVFuncInfo *vfunc;
         bool defined_by_parent;
 
         vfunc = find_vfunc_on_parents(priv->info, name_without_vfunc_, &defined_by_parent);
         if (vfunc != NULL) {
-            g_free(name);
 
             /* In the event that the vfunc is unchanged, let regular
              * prototypal inheritance take over. */
@@ -786,11 +771,9 @@ object_instance_resolve(JSContext       *context,
      */
     if (method_info == NULL) {
         bool retval = object_instance_resolve_no_info(context, obj, resolved, priv, name);
-        g_free(name);
         return retval;
     }
 
-    g_free(name);
 
 #if GJS_VERBOSE_ENABLE_GI_USAGE
     _gjs_log_info_usage((GIBaseInfo*) method_info);
@@ -860,7 +843,7 @@ object_instance_props_to_g_parameters(JSContext                  *context,
     }
 
     for (ix = 0, length = ids.length(); ix < length; ix++) {
-        char *name = NULL;
+        GjsAutoJSChar name(context);
         GParameter gparam = { NULL, { 0, }};
 
         /* ids[ix] is reachable because props is rooted, but require_property
@@ -881,18 +864,15 @@ object_instance_props_to_g_parameters(JSContext                  *context,
                                            true /* constructing */)) {
         case NO_SUCH_G_PROPERTY:
             gjs_throw(context, "No property %s on this GObject %s",
-                         name, g_type_name(gtype));
+                      name.get(), g_type_name(gtype));
             /* fallthrough */
         case SOME_ERROR_OCCURRED:
-            g_free(name);
             goto free_array_and_fail;
         case VALUE_WAS_SET:
         default:
             break;
         }
 
-        g_free(name);
-
         gparams.push_back(gparam);
     }
 
@@ -1586,10 +1566,9 @@ real_connect_func(JSContext *context,
     GClosure *closure;
     gulong id;
     guint signal_id;
-    char *signal_name;
+    GjsAutoJSChar signal_name(context);
     GQuark signal_detail;
     ConnectData *connect_data;
-    bool ret = false;
 
     gjs_debug_gsignal("connect obj %p priv %p argc %d", obj.get(), priv, argc);
     if (priv == NULL) {
@@ -1619,14 +1598,14 @@ real_connect_func(JSContext *context,
                              &signal_detail,
                              true)) {
         gjs_throw(context, "No signal '%s' on object '%s'",
-                     signal_name,
-                     g_type_name(G_OBJECT_TYPE(priv->gobj)));
-        goto out;
+                  signal_name.get(),
+                  g_type_name(G_OBJECT_TYPE(priv->gobj)));
+        return false;
     }
 
     closure = gjs_closure_new_for_signal(context, &argv[1].toObject(), "signal callback", signal_id);
     if (closure == NULL)
-        goto out;
+        return false;
 
     connect_data = g_slice_new0(ConnectData);
     priv->signals.insert(connect_data);
@@ -1643,10 +1622,7 @@ real_connect_func(JSContext *context,
 
     argv.rval().setDouble(id);
 
-    ret = true;
- out:
-    g_free(signal_name);
-    return ret;
+    return true;
 }
 
 static bool
@@ -1674,12 +1650,11 @@ emit_func(JSContext *context,
     guint signal_id;
     GQuark signal_detail;
     GSignalQuery signal_query;
-    char *signal_name;
+    GjsAutoJSChar signal_name(context);
     GValue *instance_and_args;
     GValue rvalue = G_VALUE_INIT;
     unsigned int i;
     bool failed;
-    bool ret = false;
 
     gjs_debug_gsignal("emit obj %p priv %p argc %d", obj.get(), priv, argc);
 
@@ -1710,20 +1685,20 @@ emit_func(JSContext *context,
                              &signal_detail,
                              false)) {
         gjs_throw(context, "No signal '%s' on object '%s'",
-                     signal_name,
-                     g_type_name(G_OBJECT_TYPE(priv->gobj)));
-        goto out;
+                  signal_name.get(),
+                  g_type_name(G_OBJECT_TYPE(priv->gobj)));
+        return false;
     }
 
     g_signal_query(signal_id, &signal_query);
 
     if ((argc - 1) != signal_query.n_params) {
         gjs_throw(context, "Signal '%s' on %s requires %d args got %d",
-                     signal_name,
-                     g_type_name(G_OBJECT_TYPE(priv->gobj)),
-                     signal_query.n_params,
-                     argc - 1);
-        goto out;
+                  signal_name.get(),
+                  g_type_name(G_OBJECT_TYPE(priv->gobj)),
+                  signal_query.n_params,
+                  argc - 1);
+        return false;
     }
 
     if (signal_query.return_type != G_TYPE_NONE) {
@@ -1769,10 +1744,7 @@ emit_func(JSContext *context,
         g_value_unset(&instance_and_args[i]);
     }
 
-    ret = !failed;
- out:
-    g_free(signal_name);
-    return ret;
+    return !failed;
 }
 
 static bool
@@ -2891,7 +2863,7 @@ gjs_signal_new(JSContext *cx,
 {
     JS::CallArgs argv = JS::CallArgsFromVp (argc, vp);
     GType gtype;
-    char *signal_name_tmp = NULL;
+    GjsAutoJSChar signal_name(cx);
     GSignalAccumulator accumulator;
     gint signal_id;
     guint i, n_parameters;
@@ -2902,9 +2874,8 @@ gjs_signal_new(JSContext *cx,
 
     JSAutoRequest ar(cx);
 
-    if (!gjs_string_to_utf8(cx, argv[1], &signal_name_tmp))
+    if (!gjs_string_to_utf8(cx, argv[1], &signal_name))
         return false;
-    std::unique_ptr<char, decltype(&g_free)> signal_name(signal_name_tmp, g_free);
 
     JS::RootedObject obj(cx, &argv[0].toObject());
     if (!gjs_typecheck_gtype(cx, obj, true))
@@ -2950,7 +2921,7 @@ gjs_signal_new(JSContext *cx,
 
     gtype = gjs_gtype_get_actual_gtype(cx, obj);
 
-    signal_id = g_signal_newv(signal_name.get(),
+    signal_id = g_signal_newv(signal_name,
                               gtype,
                               (GSignalFlags) argv[2].toInt32(), /* signal_flags */
                               NULL, /* class closure */
diff --git a/gi/param.cpp b/gi/param.cpp
index 9ea8db53..120d627a 100644
--- a/gi/param.cpp
+++ b/gi/param.cpp
@@ -58,7 +58,7 @@ param_resolve(JSContext       *context,
     GIObjectInfo *info = NULL;
     GIFunctionInfo *method_info;
     Param *priv;
-    char *name = NULL;
+    GjsAutoJSChar name(context);
     bool ret = false;
 
     if (!gjs_get_string_id(context, id, &name))
@@ -69,7 +69,6 @@ param_resolve(JSContext       *context,
     if (priv != NULL) {
         /* instance, not prototype */
         *resolved = false;
-        g_free(name);
         return true;
     }
 
@@ -102,7 +101,6 @@ param_resolve(JSContext       *context,
 
     ret = true;
  out:
-    g_free(name); 
     if (info != NULL)
         g_base_info_unref( (GIBaseInfo*)info);
 
diff --git a/gi/repo.cpp b/gi/repo.cpp
index 3b6a7ca7..3b4610f0 100644
--- a/gi/repo.cpp
+++ b/gi/repo.cpp
@@ -167,7 +167,7 @@ repo_resolve(JSContext       *context,
              bool            *resolved)
 {
     Repo *priv;
-    char *name = NULL;
+    GjsAutoJSChar name(context);
 
     if (!gjs_get_string_id(context, id, &name)) {
         *resolved = false;
@@ -178,7 +178,6 @@ repo_resolve(JSContext       *context,
     if (strcmp(name, "valueOf") == 0 ||
         strcmp(name, "toString") == 0) {
         *resolved = false;
-        g_free(name);
         return true;
     }
 
@@ -189,17 +188,14 @@ repo_resolve(JSContext       *context,
     if (priv == NULL) {
         /* we are the prototype, or have the wrong class */
         *resolved = false;
-        g_free(name);
         return true;
     }
 
     if (!resolve_namespace_object(context, obj, id, name)) {
-        g_free(name);
         return false;
     }
 
     *resolved = true;
-    g_free(name);
     return true;
 }
 
diff --git a/gi/union.cpp b/gi/union.cpp
index 14bbcec6..5fd5ab64 100644
--- a/gi/union.cpp
+++ b/gi/union.cpp
@@ -61,7 +61,7 @@ union_resolve(JSContext       *context,
               bool            *resolved)
 {
     Union *priv;
-    char *name = NULL;
+    GjsAutoJSChar name(context);
 
     if (!gjs_get_string_id(context, id, &name)) {
         *resolved = false;
@@ -72,10 +72,8 @@ union_resolve(JSContext       *context,
     gjs_debug_jsprop(GJS_DEBUG_GBOXED, "Resolve prop '%s' hook obj %p priv %p",
                      name, obj.get(), priv);
 
-    if (priv == NULL) {
-        g_free(name);
+    if (priv == nullptr)
         return false; /* wrong class */
-    }
 
     if (priv->gboxed != NULL) {
         /* We are an instance, not a prototype, so look for
@@ -86,7 +84,6 @@ union_resolve(JSContext       *context,
          * hooks, not this resolve hook.
          */
         *resolved = false;
-        g_free(name);
         return true;
     }
 
@@ -116,7 +113,6 @@ union_resolve(JSContext       *context,
                                     g_registered_type_info_get_g_type(priv->info),
                                     method_info) == NULL) {
                 g_base_info_unref( (GIBaseInfo*) method_info);
-                g_free(name);
                 return false;
             }
 
@@ -130,7 +126,6 @@ union_resolve(JSContext       *context,
         *resolved = false;
     }
 
-    g_free(name);
     return true;
 }
 
diff --git a/gi/value.cpp b/gi/value.cpp
index 9b0bceb4..48063347 100644
--- a/gi/value.cpp
+++ b/gi/value.cpp
@@ -380,12 +380,12 @@ gjs_value_to_g_value_internal(JSContext      *context,
         if (value.isNull()) {
             g_value_set_string(gvalue, NULL);
         } else if (value.isString()) {
-            gchar *utf8_string;
+            GjsAutoJSChar utf8_string(context);
 
             if (!gjs_string_to_utf8(context, value, &utf8_string))
                 return false;
 
-            g_value_take_string(gvalue, utf8_string);
+            g_value_take_string(gvalue, utf8_string.copy());
         } else {
             gjs_throw(context,
                       "Wrong type %s; string expected",
diff --git a/test/gjs-tests.cpp b/test/gjs-tests.cpp
index 606cf614..7d971055 100644
--- a/test/gjs-tests.cpp
+++ b/test/gjs-tests.cpp
@@ -124,14 +124,13 @@ static void
 gjstest_test_func_gjs_jsapi_util_string_js_string_utf8(GjsUnitTestFixture *fx,
                                                        gconstpointer       unused)
 {
-    char *utf8_result;
+    GjsAutoJSChar utf8_result(fx->cx);
     JS::RootedValue js_string(fx->cx);
 
     g_assert_true(gjs_string_from_utf8(fx->cx, VALID_UTF8_STRING, -1, &js_string));
     g_assert(js_string.isString());
     g_assert(gjs_string_to_utf8(fx->cx, js_string, &utf8_result));
     g_assert_cmpstr(VALID_UTF8_STRING, ==, utf8_result);
-    g_free(utf8_result);
 }
 
 static void
@@ -139,7 +138,7 @@ gjstest_test_func_gjs_jsapi_util_error_throw(GjsUnitTestFixture *fx,
                                              gconstpointer       unused)
 {
     JS::RootedValue exc(fx->cx), value(fx->cx);
-    char *s = NULL;
+    GjsAutoJSChar s(fx->cx);
 
     /* Test that we can throw */
 
@@ -158,7 +157,6 @@ gjstest_test_func_gjs_jsapi_util_error_throw(GjsUnitTestFixture *fx,
     gjs_string_to_utf8(fx->cx, value, &s);
     g_assert_nonnull(s);
     g_assert_cmpstr(s, ==, "This is an exception 42");
-    JS_free(fx->cx, s);
 
     /* keep this around before we clear it */
     JS::RootedValue previous(fx->cx, exc);

From 23b5fbf943df63d0baa3ed645c5800e93f5782a6 Mon Sep 17 00:00:00 2001
From: Chun-wei Fan <fanchunwei@src.gnome.org>
Date: Wed, 24 May 2017 22:03:10 +0800
Subject: [PATCH 022/154] modules/cairo-*-surface.cpp: Silence compiler
 warnings

Since we moved to a using std::unique_ptr, the filename variables might
be seen by the compiler as possibly uninitialized, so just set them as
mullptr to silence the compiler.

https://bugzilla.gnome.org/show_bug.cgi?id=783031
---
 modules/cairo-image-surface.cpp | 2 +-
 modules/cairo-pdf-surface.cpp   | 2 +-
 modules/cairo-ps-surface.cpp    | 2 +-
 modules/cairo-surface.cpp       | 2 +-
 modules/cairo-svg-surface.cpp   | 2 +-
 5 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/modules/cairo-image-surface.cpp b/modules/cairo-image-surface.cpp
index 4bd39602..08118c91 100644
--- a/modules/cairo-image-surface.cpp
+++ b/modules/cairo-image-surface.cpp
@@ -79,7 +79,7 @@ createFromPNG_func(JSContext *context,
                    JS::Value *vp)
 {
     JS::CallArgs argv = JS::CallArgsFromVp (argc, vp);
-    char *filename;
+    char *filename = nullptr;
     cairo_surface_t *surface;
 
     if (!gjs_parse_call_args(context, "createFromPNG", argv, "s",
diff --git a/modules/cairo-pdf-surface.cpp b/modules/cairo-pdf-surface.cpp
index 0d46912e..ce58d716 100644
--- a/modules/cairo-pdf-surface.cpp
+++ b/modules/cairo-pdf-surface.cpp
@@ -39,7 +39,7 @@ GJS_DEFINE_PROTO_WITH_PARENT("PDFSurface", cairo_pdf_surface,
 GJS_NATIVE_CONSTRUCTOR_DECLARE(cairo_pdf_surface)
 {
     GJS_NATIVE_CONSTRUCTOR_VARIABLES(cairo_pdf_surface)
-    char *filename;
+    char *filename = nullptr;
     double width, height;
     cairo_surface_t *surface;
 
diff --git a/modules/cairo-ps-surface.cpp b/modules/cairo-ps-surface.cpp
index 85642678..01a9906d 100644
--- a/modules/cairo-ps-surface.cpp
+++ b/modules/cairo-ps-surface.cpp
@@ -39,7 +39,7 @@ GJS_DEFINE_PROTO_WITH_PARENT("PSSurface", cairo_ps_surface, cairo_surface,
 GJS_NATIVE_CONSTRUCTOR_DECLARE(cairo_ps_surface)
 {
     GJS_NATIVE_CONSTRUCTOR_VARIABLES(cairo_ps_surface)
-    char *filename;
+    char *filename = nullptr;
     double width, height;
     cairo_surface_t *surface;
 
diff --git a/modules/cairo-surface.cpp b/modules/cairo-surface.cpp
index 1343ef65..8154a5da 100644
--- a/modules/cairo-surface.cpp
+++ b/modules/cairo-surface.cpp
@@ -66,7 +66,7 @@ writeToPNG_func(JSContext *context,
                 JS::Value *vp)
 {
     GJS_GET_THIS(context, argc, vp, argv, obj);
-    char *filename;
+    char *filename = nullptr;
     cairo_surface_t *surface;
 
     if (!gjs_parse_call_args(context, "writeToPNG", argv, "F",
diff --git a/modules/cairo-svg-surface.cpp b/modules/cairo-svg-surface.cpp
index fc606124..dc7ec028 100644
--- a/modules/cairo-svg-surface.cpp
+++ b/modules/cairo-svg-surface.cpp
@@ -39,7 +39,7 @@ GJS_DEFINE_PROTO_WITH_PARENT("SVGSurface", cairo_svg_surface,
 GJS_NATIVE_CONSTRUCTOR_DECLARE(cairo_svg_surface)
 {
     GJS_NATIVE_CONSTRUCTOR_VARIABLES(cairo_svg_surface)
-    char *filename;
+    char *filename = nullptr;
     double width, height;
     cairo_surface_t *surface;
 

From 36b9d0c474ab874f77e755e09cfae44531612090 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 11 Jun 2017 23:23:46 -0700
Subject: [PATCH 024/154] js: Stop using flags argument to String.replace()

This argument (e.g., str.replace('foo', 'bar', 'g')) was nonstandard and
is being removed in SpiderMonkey 52. Instead, we use a regular expression
literal, e.g. str.replace(/foo/g, 'bar').

In addition, tweak the test assertions in testGtk to test that the
provided children are neither null nor undefined, because more tests
should have failed on this.

https://bugzilla.gnome.org/show_bug.cgi?id=781429
---
 installed-tests/js/testGtk.js | 12 ++++++------
 modules/overrides/Gtk.js      | 12 ++++++++----
 modules/package.js            |  2 +-
 3 files changed, 15 insertions(+), 11 deletions(-)

diff --git a/installed-tests/js/testGtk.js b/installed-tests/js/testGtk.js
index 19ea06ee..db97108e 100755
--- a/installed-tests/js/testGtk.js
+++ b/installed-tests/js/testGtk.js
@@ -48,10 +48,10 @@ const MyComplexGtkSubclass = new Lang.Class({
 
     testChildrenExist: function () {
         this._internalLabel = this.get_template_child(MyComplexGtkSubclass, 'label-child');
-        expect(this._internalLabel).not.toBeNull();
+        expect(this._internalLabel).toEqual(jasmine.anything());
 
-        expect(this.label_child2).not.toBeNull();
-        expect(this._internal_label_child).not.toBeNull();
+        expect(this.label_child2).toEqual(jasmine.anything());
+        expect(this._internal_label_child).toEqual(jasmine.anything());
     }
 });
 
@@ -68,9 +68,9 @@ const MyComplexGtkSubclassFromResource = new Lang.Class({
     // },
 
     testChildrenExist: function () {
-        expect(this.label_child).not.toBeNull();
-        expect(this.label_child2).not.toBeNull();
-        expect(this._internal_label_child).not.toBeNull();
+        expect(this.label_child).toEqual(jasmine.anything());
+        expect(this.label_child2).toEqual(jasmine.anything());
+        expect(this._internal_label_child).toEqual(jasmine.anything());
     }
 });
 
diff --git a/modules/overrides/Gtk.js b/modules/overrides/Gtk.js
index 404eaad1..78365398 100644
--- a/modules/overrides/Gtk.js
+++ b/modules/overrides/Gtk.js
@@ -108,12 +108,16 @@ function _init() {
 
         if (this.constructor.Template) {
             let children = this.constructor.Children || [];
-            for (let child of children)
-                this[child.replace('-', '_', 'g')] = this.get_template_child(this.constructor, child);
+            for (let child of children) {
+                this[child.replace(/-/g, '_')] =
+                    this.get_template_child(this.constructor, child);
+            }
 
             let internalChildren = this.constructor.InternalChildren || [];
-            for (let child of internalChildren)
-                this['_' + child.replace('-', '_', 'g')] = this.get_template_child(this.constructor, child);
+            for (let child of internalChildren) {
+                this['_' + child.replace(/-/g, '_')] =
+                    this.get_template_child(this.constructor, child);
+            }
         }
     };
 }
diff --git a/modules/package.js b/modules/package.js
index 5a5cd22a..2e6433f0 100644
--- a/modules/package.js
+++ b/modules/package.js
@@ -67,7 +67,7 @@ function _runningFromMesonSource() {
 }
 
 function _makeNamePath(name) {
-    return '/' + name.replace('.', '/', 'g');
+    return '/' + name.replace(/\./g, '/');
 }
 
 /**

From 756aa040bf5023f70b2f78640348137e1faf9bc6 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 4 Jun 2017 14:51:53 -0400
Subject: [PATCH 025/154] tests: Root using context, not runtime

JSRuntime is going away in SpiderMonkey 52, so we should stop using the
constructor of JS::Rooted<T> that takes JSRuntime instead of JSContext.
There were a few instances I missed in the previous commit that fixed
this.

https://bugzilla.gnome.org/show_bug.cgi?id=781429
---
 test/gjs-test-coverage.cpp | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/test/gjs-test-coverage.cpp b/test/gjs-test-coverage.cpp
index a15eee88..3f1a68e8 100644
--- a/test/gjs-test-coverage.cpp
+++ b/test/gjs-test-coverage.cpp
@@ -1641,10 +1641,9 @@ test_coverage_cache_as_js_object_has_expected_properties(gpointer      fixture_d
     };
 
     GBytes *cache = serialize_ast_to_bytes(fixture->coverage, coverage_paths);
-    JS::RootedString cache_results(JS_GetRuntime((JSContext *) gjs_context_get_native_context(fixture->context)),
-                                   gjs_deserialize_cache_to_object(fixture->coverage, cache));
-    JS::RootedValue cache_result_value(JS_GetRuntime((JSContext *) gjs_context_get_native_context(fixture->context)),
-                                       JS::StringValue(cache_results));
+    auto cx = static_cast<JSContext *>(gjs_context_get_native_context(fixture->context));
+    JS::RootedValue cache_result_value(cx,
+        JS::StringValue(gjs_deserialize_cache_to_object(fixture->coverage, cache)));
     gjs_inject_value_into_coverage_compartment(fixture->coverage,
                                                cache_result_value,
                                                "coverage_cache");

From 76a43a0afe8784368ff27a35fdd7b73933b3d1ce Mon Sep 17 00:00:00 2001
From: Chun-wei Fan <fanchunwei@src.gnome.org>
Date: Wed, 14 Jun 2017 10:34:50 +0800
Subject: [PATCH 026/154] Windows: Build against SpiderMonkey 52

This is done so that people can also test Windows builds for gjs that is
based on SpiderMonkey 52.

As the upstream libffi is not very well maintained for Windows/MSVC, we
are also switching to use the Centricular fork for libffi[1], which will
also be the case for the upcoming stable releases for GLib (i.e. GObject)
and GObject-Introspection.

[1]: https://github.com/centricular/libffi
---
 win32/README.txt      | 2 +-
 win32/config-msvc.mak | 5 ++---
 2 files changed, 3 insertions(+), 4 deletions(-)

diff --git a/win32/README.txt b/win32/README.txt
index 4aa9dbbc..759a1e18 100644
--- a/win32/README.txt
+++ b/win32/README.txt
@@ -6,7 +6,7 @@ via NMake Makefiles.  Due to C++-11 usage, Visual Studio 2012 or
 earlier is not supported.
 
 You will need the following items to build GJS using Visual Studio:
--SpiderMonkey 38 (mozjs-38)
+-SpiderMonkey 52 (mozjs-52)
 -GObject-Introspection (G-I) 1.41.4 or later
 -GLib 2.50.x or later, (which includes GIO, GObject, and the associated tools)
 -Cairo including Cairo-GObject support, unless NO_CAIRO=1 is specified.
diff --git a/win32/config-msvc.mak b/win32/config-msvc.mak
index b0a48f31..74b661c3 100644
--- a/win32/config-msvc.mak
+++ b/win32/config-msvc.mak
@@ -1,7 +1,7 @@
 # NMake Makefile portion for enabling features for Windows builds
 
 # Spidermonkey release series (17, 24, 31, 38, 45 etc.)
-MOZJS_VERSION = 38
+MOZJS_VERSION = 52
 
 # Please see https://bugzilla.gnome.org/show_bug.cgi?id=775868,
 # comments 26, 27 and 28
@@ -23,7 +23,7 @@ GJS_BASE_LIBS = gio-2.0.lib gobject-2.0.lib glib-2.0.lib
 LIBGJS_BASE_DEP_LIBS =			\
 	girepository-1.0.lib		\
 	$(GJS_BASE_LIBS)		\
-	libffi.lib			\
+	ffi.lib				\
 	intl.lib			\
 	mozjs-$(MOZJS_VERSION).lib
 
@@ -123,7 +123,6 @@ LIBGJS_CFLAGS =				\
 	/DGJS_COMPILATION		\
 	/DXP_WIN			\
 	/DWIN32				\
-	/DFFI_BUILDING			\
 	$(GJS_BASE_CFLAGS)		\
 	$(LIBGJS_DEP_INCLUDES)
 

From afe21f62fbbff99885d069f0bf8ce94c15a1df67 Mon Sep 17 00:00:00 2001
From: Chun-wei Fan <fanchunwei@src.gnome.org>
Date: Wed, 14 Jun 2017 11:40:00 +0800
Subject: [PATCH 027/154] Partially revert "Windows: Build against SpiderMonkey
 52"

Sorry, I accidentally pushed the update to use SpiderMonkey 52 to the master
branch, which is on 38.  Revert the part that updates the Visual Studio
build files to use SpiderMonkey 38, but we still want to update the build
to use the Centricular fork of libffi.
---
 win32/README.txt      | 2 +-
 win32/config-msvc.mak | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/win32/README.txt b/win32/README.txt
index 759a1e18..4aa9dbbc 100644
--- a/win32/README.txt
+++ b/win32/README.txt
@@ -6,7 +6,7 @@ via NMake Makefiles.  Due to C++-11 usage, Visual Studio 2012 or
 earlier is not supported.
 
 You will need the following items to build GJS using Visual Studio:
--SpiderMonkey 52 (mozjs-52)
+-SpiderMonkey 38 (mozjs-38)
 -GObject-Introspection (G-I) 1.41.4 or later
 -GLib 2.50.x or later, (which includes GIO, GObject, and the associated tools)
 -Cairo including Cairo-GObject support, unless NO_CAIRO=1 is specified.
diff --git a/win32/config-msvc.mak b/win32/config-msvc.mak
index 74b661c3..8af31113 100644
--- a/win32/config-msvc.mak
+++ b/win32/config-msvc.mak
@@ -1,7 +1,7 @@
 # NMake Makefile portion for enabling features for Windows builds
 
 # Spidermonkey release series (17, 24, 31, 38, 45 etc.)
-MOZJS_VERSION = 52
+MOZJS_VERSION = 38
 
 # Please see https://bugzilla.gnome.org/show_bug.cgi?id=775868,
 # comments 26, 27 and 28

From 9715825134000e9a627a9260a1f8d4cb55a8c0e4 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sat, 10 Jun 2017 20:25:46 -0700
Subject: [PATCH 029/154] autofree: Avoid using local typedefs in classes

We can make the GjsAutoChar and GjsAutoUnref declarations a bit more
readable by just writing 'unique_ptr' directly. This is more idiomatic
C++ style.

Thanks to Daniel Boles for pointing this out.

https://bugzilla.gnome.org/show_bug.cgi?id=777597
---
 cjs/jsapi-util.h | 10 +++-------
 1 file changed, 3 insertions(+), 7 deletions(-)

diff --git a/cjs/jsapi-util.h b/cjs/jsapi-util.h
index 0d268cd7..6658dc25 100644
--- a/cjs/jsapi-util.h
+++ b/cjs/jsapi-util.h
@@ -35,9 +35,7 @@
 
 class GjsAutoChar : public std::unique_ptr<char, decltype(&g_free)> {
 public:
-    typedef std::unique_ptr<char, decltype(&g_free)> U;
-
-    GjsAutoChar(char *str = nullptr) : U(str, g_free) {}
+    GjsAutoChar(char *str = nullptr) : unique_ptr(str, g_free) {}
 
     operator const char *() {
         return get();
@@ -51,12 +49,10 @@ class GjsAutoChar : public std::unique_ptr<char, decltype(&g_free)> {
 template <typename T>
 class GjsAutoUnref : public std::unique_ptr<T, decltype(&g_object_unref)> {
 public:
-    typedef std::unique_ptr<T, decltype(&g_object_unref)> U;
-
-    GjsAutoUnref(T *ptr = nullptr) : U(ptr, g_object_unref) {}
+    GjsAutoUnref(T *ptr = nullptr) : GjsAutoUnref::unique_ptr(ptr, g_object_unref) {}
 
     operator T *() {
-        return U::get();
+        return GjsAutoUnref::unique_ptr::get();
     }
 };
 

From a8c69f5ec52973459bbdfad0cd2052cc2a9a679a Mon Sep 17 00:00:00 2001
From: Daniel Boles <dboles@src.gnome.org>
Date: Thu, 15 Jun 2017 09:33:12 +0100
Subject: [PATCH 030/154] GjsAutoChar: Do not take ownership of const char*

We were taking a const char* and casting away constness, which would
enable bad things like freeing a string literal, or double-freeing a
const char* view of a string that is already owned by another entity.

https://bugzilla.gnome.org/show_bug.cgi?id=777597
---
 cjs/jsapi-util.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/cjs/jsapi-util.h b/cjs/jsapi-util.h
index 6658dc25..33a25fd2 100644
--- a/cjs/jsapi-util.h
+++ b/cjs/jsapi-util.h
@@ -41,8 +41,8 @@ class GjsAutoChar : public std::unique_ptr<char, decltype(&g_free)> {
         return get();
     }
 
-    void operator= (const char* str) {
-        reset(const_cast<char*>(str));
+    void operator= (char *str) {
+        reset(str);
     }
 };
 

From f38b63d2089afaaeacf320d153d74d711825c524 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Claudio=20Andr=C3=A9?= <claudioandre.br@gmail.com>
Date: Mon, 19 Jun 2017 13:37:20 -0300
Subject: [PATCH 031/154] maint: fix a wrong sscanf argument

https://bugzilla.gnome.org/show_bug.cgi?id=783214
---
 test/gjs-test-coverage.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/test/gjs-test-coverage.cpp b/test/gjs-test-coverage.cpp
index 3f1a68e8..535495d1 100644
--- a/test/gjs-test-coverage.cpp
+++ b/test/gjs-test-coverage.cpp
@@ -902,7 +902,7 @@ hit_count_is_more_than_for_function(const char *line,
 
     max_buf_size = strcspn(line, "\n");
     detected_function = g_new(char, max_buf_size + 1);
-    nmatches = sscanf(line, "%i,%s", &hit_count, detected_function);
+    nmatches = sscanf(line, "%u,%s", &hit_count, detected_function);
     if (nmatches != 2) {
         if (errno != 0)
             g_error("sscanf: %s", strerror(errno));

From 33e9bd5d8cbaed92594a9cd26b18652cb16c0e47 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sat, 24 Jun 2017 22:02:54 -0700
Subject: [PATCH 033/154] js: Use autoptr in gjs_object_require_property()

We now use GjsAutoJSChar for the overload of
gjs_object_require_property() that deals with string properties. This
converts existing callers to use GjsAutoJSChar, and in fact fixes a few
instances where the string was freed with the wrong function.

https://bugzilla.gnome.org/show_bug.cgi?id=781429
---
 cjs/jsapi-util.cpp |  7 ++-----
 cjs/jsapi-util.h   |  2 +-
 gi/gerror.cpp      |  4 +---
 gi/repo.cpp        | 11 +++--------
 4 files changed, 7 insertions(+), 17 deletions(-)

diff --git a/cjs/jsapi-util.cpp b/cjs/jsapi-util.cpp
index 7c7de731..0caa514b 100644
--- a/cjs/jsapi-util.cpp
+++ b/cjs/jsapi-util.cpp
@@ -297,15 +297,12 @@ gjs_object_require_property(JSContext       *cx,
                             JS::HandleObject obj,
                             const char      *description,
                             JS::HandleId     property_name,
-                            char           **value)
+                            GjsAutoJSChar   *value)
 {
     JS::RootedValue prop_value(cx);
-    GjsAutoJSChar value_tmp(cx);
     if (JS_GetPropertyById(cx, obj, property_name, &prop_value) &&
-        gjs_string_to_utf8(cx, prop_value, &value_tmp)) {
-        *value = value_tmp.copy();
+        gjs_string_to_utf8(cx, prop_value, value))
         return true;
-    }
 
     throw_property_lookup_error(cx, obj, description, property_name,
                                 "it was not a valid string");
diff --git a/cjs/jsapi-util.h b/cjs/jsapi-util.h
index 33a25fd2..f7f52c8c 100644
--- a/cjs/jsapi-util.h
+++ b/cjs/jsapi-util.h
@@ -390,7 +390,7 @@ bool gjs_object_require_property(JSContext       *cx,
                                  JS::HandleObject obj,
                                  const char      *description,
                                  JS::HandleId     property_name,
-                                 char           **value);
+                                 GjsAutoJSChar   *value);
 
 bool gjs_object_require_property(JSContext              *cx,
                                  JS::HandleObject        obj,
diff --git a/gi/gerror.cpp b/gi/gerror.cpp
index 0ec3cead..229b44f0 100644
--- a/gi/gerror.cpp
+++ b/gi/gerror.cpp
@@ -54,7 +54,6 @@ GJS_NATIVE_CONSTRUCTOR_DECLARE(error)
     GJS_NATIVE_CONSTRUCTOR_VARIABLES(error)
     Error *priv;
     Error *proto_priv;
-    gchar *message;
     int32_t code;
 
     /* Check early to avoid allocating memory for nothing */
@@ -97,6 +96,7 @@ GJS_NATIVE_CONSTRUCTOR_DECLARE(error)
     priv->domain = proto_priv->domain;
 
     JS::RootedObject params_obj(context, &argv[0].toObject());
+    GjsAutoJSChar message(context);
     if (!gjs_object_require_property(context, params_obj,
                                      "GError constructor",
                                      GJS_STRING_MESSAGE, &message))
@@ -109,8 +109,6 @@ GJS_NATIVE_CONSTRUCTOR_DECLARE(error)
 
     priv->gerror = g_error_new_literal(priv->domain, code, message);
 
-    JS_free(context, message);
-
     /* We assume this error will be thrown in the same line as the constructor */
     define_error_properties(context, object);
 
diff --git a/gi/repo.cpp b/gi/repo.cpp
index 3b4610f0..85a3b50b 100644
--- a/gi/repo.cpp
+++ b/gi/repo.cpp
@@ -62,7 +62,7 @@ static bool
 get_version_for_ns (JSContext       *context,
                     JS::HandleObject repo_obj,
                     JS::HandleId     ns_id,
-                    char           **version)
+                    GjsAutoJSChar   *version)
 {
     JS::RootedObject versions(context);
     bool found;
@@ -75,10 +75,8 @@ get_version_for_ns (JSContext       *context,
     if (!JS_AlreadyHasOwnPropertyById(context, versions, ns_id, &found))
         return false;
 
-    if (!found) {
-        *version = NULL;
+    if (!found)
         return true;
-    }
 
     return gjs_object_require_property(context, versions, NULL, ns_id, version);
 }
@@ -91,10 +89,10 @@ resolve_namespace_object(JSContext       *context,
 {
     GIRepository *repo;
     GError *error;
-    char *version;
 
     JSAutoRequest ar(context);
 
+    GjsAutoJSChar version(context);
     if (!get_version_for_ns(context, repo_obj, ns_id, &version))
         return false;
 
@@ -119,12 +117,9 @@ resolve_namespace_object(JSContext       *context,
                   ns_name, version?version:"none", error->message);
 
         g_error_free(error);
-        g_free(version);
         return false;
     }
 
-    g_free(version);
-
     /* Defines a property on "obj" (the javascript repo object)
      * with the given namespace name, pointing to that namespace
      * in the repo.

From 82c96df781d8c05f93767476b6bd7e50250c79c9 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sat, 24 Jun 2017 23:42:44 -0700
Subject: [PATCH 034/154] jsapi-util-string: Remove useless length calculation

This was left over from using JS_EncodeStringToBuffer() in past code. It
is not used now, so it's unnecessary to calculate it.

https://bugzilla.gnome.org/show_bug.cgi?id=781429
---
 cjs/jsapi-util-string.cpp | 9 ---------
 1 file changed, 9 deletions(-)

diff --git a/cjs/jsapi-util-string.cpp b/cjs/jsapi-util-string.cpp
index e01d5952..16085273 100644
--- a/cjs/jsapi-util-string.cpp
+++ b/cjs/jsapi-util-string.cpp
@@ -34,8 +34,6 @@ gjs_string_to_utf8 (JSContext      *context,
                     const JS::Value value,
                     GjsAutoJSChar  *utf8_string_p)
 {
-    gsize len;
-
     JS_BeginRequest(context);
 
     if (!value.isString()) {
@@ -46,13 +44,6 @@ gjs_string_to_utf8 (JSContext      *context,
     }
 
     JS::RootedString str(context, value.toString());
-
-    len = JS_GetStringEncodingLength(context, str);
-    if (len == (gsize)(-1)) {
-        JS_EndRequest(context);
-        return false;
-    }
-
     utf8_string_p->reset(context, JS_EncodeStringToUTF8(context, str));
 
     JS_EndRequest(context);

From 999aa1048aa211f86bc88266a895faf9f07be34e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Claudio=20Andr=C3=A9?= <claudioandre.br@gmail.com>
Date: Mon, 29 May 2017 09:47:26 -0300
Subject: [PATCH 035/154] maint: add a static code analysis 'make target'

It uses cppcheck static code analysis tool. It is harmless, and can be useful.

https://bugzilla.gnome.org/show_bug.cgi?id=783214
---
 Makefile.am    |  7 +++++++
 doc/Hacking.md | 12 +++++++++++-
 2 files changed, 18 insertions(+), 1 deletion(-)

diff --git a/Makefile.am b/Makefile.am
index bc71af99..7fe4363a 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -208,4 +208,11 @@ upload-release: $(DISTNAME) Makefile
 	scp $(DISTNAME) master.gnome.org:
 	ssh master.gnome.org install-module $(DISTNAME)
 
+
+CPPCHECK=cppcheck
+### cppcheck static code analysis
+#
+cppcheck:
+	$(CPPCHECK) --enable=warning,performance,portability,information,missingInclude --force -q $(top_srcdir) -I $(top_builddir)
+
 -include $(top_srcdir)/git.mk
diff --git a/doc/Hacking.md b/doc/Hacking.md
index f1b0361e..0da343e0 100644
--- a/doc/Hacking.md
+++ b/doc/Hacking.md
@@ -90,6 +90,16 @@ G_DEBUG=gc-friendly G_SLICE=always-malloc ./libtool --mode=execute valgrind --le
 
 (And a similar command to run each `minijasmine` test.)
 
+### Static Code Analysis ###
+
+To execute cppcheck, a static code analysis tool for the C and C++, run:
+```sh
+jhbuild make cppcheck
+```
+It is a versatile tool that can check non-standard code, including: variable 
+checking, bounds checking, leaks, etc. It can detect the types of bugs that
+the compilers normally fail to detect.
+
 ### Test Coverage ###
 
 To generate a test coverage report, put this in your JHBuild
@@ -108,4 +118,4 @@ xdg-open ~/.cache/jhbuild/build/gjs/gjs-X.Y.Z-coverage/index.html
 
 (replace `X.Y.Z` with the version number, e.g. `1.48.0`)
 
-[jhbuild] https://wiki.gnome.org/HowDoI/Jhbuild
\ No newline at end of file
+[jhbuild] https://wiki.gnome.org/HowDoI/Jhbuild

From 3052be6dc839e6c01413ce80ec201f01e3feb77d Mon Sep 17 00:00:00 2001
From: Tomas Popela <tpopela@redhat.com>
Date: Mon, 3 Jul 2017 10:39:43 +0200
Subject: [PATCH 036/154] Fix the build with debug logs enabled

https://bugzilla.gnome.org/show_bug.cgi?id=784469
---
 cjs/importer.cpp   | 2 +-
 gi/boxed.cpp       | 2 +-
 gi/fundamental.cpp | 2 +-
 gi/ns.cpp          | 2 +-
 gi/object.cpp      | 6 +++---
 gi/repo.cpp        | 2 +-
 gi/union.cpp       | 2 +-
 7 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index 6f8c64d8..f9f23776 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -825,7 +825,7 @@ importer_resolve(JSContext        *context,
 
     gjs_debug_jsprop(GJS_DEBUG_IMPORTER,
                      "Resolve prop '%s' hook obj %p priv %p",
-                     name, obj.get(), priv);
+                     name.get(), obj.get(), priv);
     if (priv == NULL) {
         /* we are the prototype, or have the wrong class */
         *resolved = false;
diff --git a/gi/boxed.cpp b/gi/boxed.cpp
index 21643df3..a35f5e0d 100644
--- a/gi/boxed.cpp
+++ b/gi/boxed.cpp
@@ -131,7 +131,7 @@ boxed_resolve(JSContext       *context,
 
     priv = priv_from_js(context, obj);
     gjs_debug_jsprop(GJS_DEBUG_GBOXED, "Resolve prop '%s' hook obj %p priv %p",
-                     name, obj.get(), priv);
+                     name.get(), obj.get(), priv);
 
     if (priv == nullptr)
         return false; /* wrong class */
diff --git a/gi/fundamental.cpp b/gi/fundamental.cpp
index f6748849..139e8214 100644
--- a/gi/fundamental.cpp
+++ b/gi/fundamental.cpp
@@ -311,7 +311,7 @@ fundamental_instance_resolve(JSContext       *context,
     priv = priv_from_js(context, obj);
     gjs_debug_jsprop(GJS_DEBUG_GFUNDAMENTAL,
                      "Resolve prop '%s' hook obj %p priv %p",
-                     name, obj.get(), priv);
+                     name.get(), obj.get(), priv);
 
     if (priv == nullptr)
         return false; /* wrong class */
diff --git a/gi/ns.cpp b/gi/ns.cpp
index 362314bc..12178e1b 100644
--- a/gi/ns.cpp
+++ b/gi/ns.cpp
@@ -75,7 +75,7 @@ ns_resolve(JSContext       *context,
     priv = priv_from_js(context, obj);
     gjs_debug_jsprop(GJS_DEBUG_GNAMESPACE,
                      "Resolve prop '%s' hook obj %p priv %p",
-                     name, obj.get(), priv);
+                     name.get(), obj.get(), priv);
 
     if (priv == NULL) {
         *resolved = false;  /* we are the prototype, or have the wrong class */
diff --git a/gi/object.cpp b/gi/object.cpp
index 8b67896f..ef95f3c4 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -399,7 +399,7 @@ object_instance_get_prop(JSContext              *context,
     priv = priv_from_js(context, obj);
     gjs_debug_jsprop(GJS_DEBUG_GOBJECT,
                      "Get prop '%s' hook obj %p priv %p",
-                     name, obj.get(), priv);
+                     name.get(), obj.get(), priv);
 
     if (priv == nullptr)
         /* If we reach this point, either object_instance_new_resolve
@@ -514,7 +514,7 @@ object_instance_set_prop(JSContext              *context,
     priv = priv_from_js(context, obj);
     gjs_debug_jsprop(GJS_DEBUG_GOBJECT,
                      "Set prop '%s' hook obj %p priv %p",
-                     name, obj.get(), priv);
+                     name.get(), obj.get(), priv);
 
     if (priv == nullptr)
         /* see the comment in object_instance_get_prop() on this */
@@ -675,7 +675,7 @@ object_instance_resolve(JSContext       *context,
 
     gjs_debug_jsprop(GJS_DEBUG_GOBJECT,
                      "Resolve prop '%s' hook obj %p priv %p (%s.%s) gobj %p %s",
-                     name,
+                     name.get(),
                      obj.get(),
                      priv,
                      priv && priv->info ? g_base_info_get_namespace (priv->info) : "",
diff --git a/gi/repo.cpp b/gi/repo.cpp
index 85a3b50b..75a59234 100644
--- a/gi/repo.cpp
+++ b/gi/repo.cpp
@@ -178,7 +178,7 @@ repo_resolve(JSContext       *context,
 
     priv = priv_from_js(context, obj);
     gjs_debug_jsprop(GJS_DEBUG_GREPO, "Resolve prop '%s' hook obj %p priv %p",
-                     name, obj.get(), priv);
+                     name.get(), obj.get(), priv);
 
     if (priv == NULL) {
         /* we are the prototype, or have the wrong class */
diff --git a/gi/union.cpp b/gi/union.cpp
index 5fd5ab64..028a5966 100644
--- a/gi/union.cpp
+++ b/gi/union.cpp
@@ -70,7 +70,7 @@ union_resolve(JSContext       *context,
 
     priv = priv_from_js(context, obj);
     gjs_debug_jsprop(GJS_DEBUG_GBOXED, "Resolve prop '%s' hook obj %p priv %p",
-                     name, obj.get(), priv);
+                     name.get(), obj.get(), priv);
 
     if (priv == nullptr)
         return false; /* wrong class */

From 7172626c9162f3c44daa182e099a1ad9d3a44cc6 Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 21:11:40 -0500
Subject: [PATCH 037/154] js: Module exports use ES6 scope rules

We "import" modules by executing them and taking their global scope as the
module object. In ES6, variables declared with "let" and "const" do not end
up in the global scope any longer. Instead, they end up in the "global
lexical scope", which is a different object. Unfortunately, this means
breaking the way many modules export their variables, but if you want
a symbol to be exported, you have to declare it with "var" or place it
explicitly on the global object some other way.

https://bugzilla.gnome.org/show_bug.cgi?id=781429
---
 installed-tests/js/modules/modunicode.js |  2 +-
 modules/cairo.js                         | 26 +++++++++++++-------------
 modules/signals.js                       |  2 +-
 3 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/installed-tests/js/modules/modunicode.js b/installed-tests/js/modules/modunicode.js
index cbda9b8a..560f5c80 100644
--- a/installed-tests/js/modules/modunicode.js
+++ b/installed-tests/js/modules/modunicode.js
@@ -1,3 +1,3 @@
 // This file is written in UTF-8.
 
-const uval = "const ♥ utf8";
+var uval = "const ♥ utf8";
diff --git a/modules/cairo.js b/modules/cairo.js
index 7555c3c3..bc5ad576 100644
--- a/modules/cairo.js
+++ b/modules/cairo.js
@@ -20,32 +20,32 @@
 
 const Lang = imports.lang;
 
-const Antialias = {
+var Antialias = {
     DEFAULT: 0,
     NONE: 1,
     GRAY: 2,
     SUBPIXEL: 3
 };
 
-const Content = {
+var Content = {
     COLOR : 0x1000,
     ALPHA : 0x2000,
     COLOR_ALPHA : 0x3000
 };
 
-const Extend = {
+var Extend = {
     NONE : 0,
     REPEAT : 1,
     REFLECT : 2,
     PAD : 3
 };
 
-const FillRule = {
+var FillRule = {
     WINDING: 0,
     EVEN_ODD: 1
 };
 
-const Filter = {
+var Filter = {
     FAST : 0,
     GOOD : 1,
     BEST : 2,
@@ -54,18 +54,18 @@ const Filter = {
     GAUSSIAN : 5
 };
 
-const FontSlant = {
+var FontSlant = {
     NORMAL: 0,
     ITALIC: 1,
     OBLIQUE: 2
 };
 
-const FontWeight = {
+var FontWeight = {
     NORMAL : 0,
     BOLD : 1
 };
 
-const Format = {
+var Format = {
     ARGB32 : 0,
     RGB24 : 1,
     A8 : 2,
@@ -74,19 +74,19 @@ const Format = {
     RGB16_565: 5
 };
 
-const LineCap = {
+var LineCap = {
     BUTT: 0,
     ROUND: 1,
     SQUASH: 2
 };
 
-const LineJoin = {
+var LineJoin = {
     MITER: 0,
     ROUND: 1,
     BEVEL: 2
 };
 
-const Operator = {
+var Operator = {
     CLEAR: 0,
     SOURCE: 1,
     OVER: 2,
@@ -118,14 +118,14 @@ const Operator = {
     HSL_LUMINOSITY : 28
 };
 
-const PatternType = {
+var PatternType = {
     SOLID : 0,
     SURFACE : 1,
     LINEAR : 2,
     RADIAL : 3
 };
 
-const SurfaceType = {
+var SurfaceType = {
     IMAGE : 0,
     PDF : 1,
     PS : 2,
diff --git a/modules/signals.js b/modules/signals.js
index 1a78dce3..4f4e2404 100644
--- a/modules/signals.js
+++ b/modules/signals.js
@@ -173,7 +173,7 @@ function addSignalMethods(proto) {
     _addSignalMethod(proto, "disconnectAll", _disconnectAll);
 }
 
-const WithSignals = new Lang.Interface({
+var WithSignals = new Lang.Interface({
     Name: 'WithSignals',
     connect: _connect,
     disconnect: _disconnect,

From 0141608b3575216124b97853d77503086c9edc97 Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 21:15:49 -0500
Subject: [PATCH 038/154] console: Refactor read-eval-print loop

This makes the REPL look more like the code from the SpiderMonkey shell
in mozjs52. This is because in SpiderMonkey 52, error reporter callbacks
and JS_ReportPendingException() are going away. We can anticipate this
change by introducing an AutoReportException class which prints any
pending exception when it goes out of scope.

This code still uses JS_ReportPendingException(), since that saves us
from doing many things manually, but that will change when switching to
SpiderMonkey 52 which adds APIs to do the things that
JS_ReportPendingException() would have done, such as print a stack trace.

https://bugzilla.gnome.org/show_bug.cgi?id=781429

https://github.com/GNOME/gjs/commit/86a309a7e5682d5ad9aed57e212324fbbfa34c3f
---
 modules/console.cpp | 111 ++++++++++++++++++++++++++++++++++++----------------
 1 file changed, 78 insertions(+), 33 deletions(-)

diff --git a/modules/console.cpp b/modules/console.cpp
index eb8a2c82..a2000c64 100644
--- a/modules/console.cpp
+++ b/modules/console.cpp
@@ -58,7 +58,7 @@
 #include "cjs/jsapi-wrapper.h"
 
 static void
-gjs_console_error_reporter(JSContext *cx, const char *message, JSErrorReport *report)
+gjs_console_print_error(const char *message, JSErrorReport *report)
 {
     /* Code modified from SpiderMonkey js/src/jscntxt.cpp, js::PrintError() */
 
@@ -126,6 +126,38 @@ gjs_console_error_reporter(JSContext *cx, const char *message, JSErrorReport *re
     g_free(prefix);
 }
 
+static void
+gjs_console_error_reporter(JSContext *cx, const char *message, JSErrorReport *report)
+{
+    gjs_console_print_error(message, report);
+}
+
+/* Based on js::shell::AutoReportException from SpiderMonkey. */
+class AutoReportException {
+    JSContext *m_cx;
+
+public:
+    explicit AutoReportException(JSContext *cx) : m_cx(cx) {}
+
+    ~AutoReportException() {
+        if (!JS_IsExceptionPending(m_cx))
+            return;
+
+        /* Get exception object before printing and clearing exception. */
+        JS::RootedValue v_exn(m_cx);
+        (void) JS_GetPendingException(m_cx, &v_exn);
+
+        JS::RootedObject exn(m_cx, &v_exn.toObject());
+        JSErrorReport *report = JS_ErrorFromException(m_cx, exn);
+        if (!report)
+            g_error("Out of memory initializing ErrorReport");
+
+        g_assert(!JSREPORT_IS_WARNING(report->flags));
+
+        JS_ReportPendingException(m_cx);
+    }
+};
+
 #ifdef HAVE_READLINE_READLINE_H
 static bool
 gjs_console_readline(JSContext *cx, char **bufp, FILE *file, const char *prompt)
@@ -153,6 +185,45 @@ gjs_console_readline(JSContext *cx, char **bufp, FILE *file, const char *prompt)
 }
 #endif
 
+/* Return value of false indicates an uncatchable exception, rather than any
+ * exception. (This is because the exception should be auto-printed around the
+ * invocation of this function.)
+ */
+static bool
+gjs_console_eval_and_print(JSContext       *cx,
+                           JS::HandleObject global,
+                           const char      *bytes,
+                           size_t           length,
+                           int              lineno)
+{
+    JS::CompileOptions options(cx);
+    options.setUTF8(true)
+           .setFileAndLine("typein", lineno);
+
+    JS::RootedValue result(cx);
+    if (!JS::Evaluate(cx, global, options, bytes, length, &result)) {
+        if (!JS_IsExceptionPending(cx))
+            return false;
+    }
+
+    gjs_schedule_gc_if_needed(cx);
+
+    if (result.isUndefined())
+        return true;
+
+    JS::RootedString str(cx, JS::ToString(cx, result));
+    if (!str)
+        return true;
+
+    char *display_str;
+    display_str = gjs_value_debug_string(cx, result);
+    if (display_str) {
+        g_fprintf(stdout, "%s\n", display_str);
+        g_free(display_str);
+    }
+    return true;
+}
+
 static bool
 gjs_console_interact(JSContext *context,
                      unsigned   argc,
@@ -160,8 +231,6 @@ gjs_console_interact(JSContext *context,
 {
     JS::CallArgs argv = JS::CallArgsFromVp(argc, vp);
     bool eof = false;
-    JS::RootedValue result(context);
-    JS::RootedString str(context);
     JS::RootedObject global(context, gjs_get_import_global(context));
     GString *buffer = NULL;
     char *temp_buf = NULL;
@@ -194,43 +263,18 @@ gjs_console_interact(JSContext *context,
         } while (!JS_BufferIsCompilableUnit(context, global,
                                             buffer->str, buffer->len));
 
-        JS::CompileOptions options(context);
-        options.setUTF8(true)
-               .setFileAndLine("typein", startline);
-        if (!JS::Evaluate(context, global, options, buffer->str, buffer->len,
-                          &result)) {
+        AutoReportException are(context);
+        if (!gjs_console_eval_and_print(context, global, buffer->str, buffer->len,
+                                        startline)) {
             /* If this was an uncatchable exception, throw another uncatchable
              * exception on up to the surrounding JS::Evaluate() in main(). This
              * happens when you run gjs-console and type imports.system.exit(0);
              * at the prompt. If we don't throw another uncatchable exception
              * here, then it's swallowed and main() won't exit. */
-            if (!JS_IsExceptionPending(context)) {
-                argv.rval().set(result);
-                return false;
-            }
-        }
-
-        gjs_schedule_gc_if_needed(context);
-
-        if (JS_GetPendingException(context, &result)) {
-            str = JS::ToString(context, result);
-            JS_ClearPendingException(context);
-        } else if (result.isUndefined()) {
-            goto next;
-        } else {
-            str = JS::ToString(context, result);
-        }
-
-        if (str) {
-            char *display_str;
-            display_str = gjs_value_debug_string(context, result);
-            if (display_str != NULL) {
-                g_fprintf(stdout, "%s\n", display_str);
-                g_free(display_str);
-            }
+            g_string_free(buffer, true);
+            return false;
         }
 
- next:
         g_string_free(buffer, true);
     } while (!eof);
 
@@ -239,6 +283,7 @@ gjs_console_interact(JSContext *context,
     if (file != stdin)
         fclose(file);
 
+    argv.rval().setUndefined();
     return true;
 }
 

From 54275d688cc232650b9e6c9cfe33728b8a18550a Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 21:33:23 -0500
Subject: [PATCH 039/154] js: Use a special object for modules

This introduces a new GjsModule class for imported module objects. The
functionality is unchanged, but we will use this as a basis for making
bindings from modules' lexical scopes (variables declared with 'let' and
'const') available for compatibility. In SpiderMonkey 45, these will stop
being exported as properties, as per ES6 standard.

The function GjsModule::evaluate_import() contains duplicated code with
gjs_eval_with_scope(), but that will change when we have to import the
lexical scope separately.

https://bugzilla.gnome.org/show_bug.cgi?id=781429

Based on https://github.com/GNOME/gjs/commit/7e88bd20738ae8c2e0146fb9c33f8eaacb0e7a9b
---
 cjs/importer.cpp                           |  57 +++-----
 cjs/module.cpp                             | 209 +++++++++++++++++++++++++++++
 cjs/module.h                               |  42 ++++++
 gjs-srcs.mk                                |   2 +
 installed-tests/js/jsunit.gresources.xml   |   1 +
 installed-tests/js/modules/lexicalScope.js |  25 ++++
 installed-tests/js/testImporter.js         |  20 +++
 7 files changed, 319 insertions(+), 37 deletions(-)
 create mode 100644 cjs/module.cpp
 create mode 100644 cjs/module.h
 create mode 100644 installed-tests/js/modules/lexicalScope.js

diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index f9f23776..956a1c0c 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -30,6 +30,7 @@
 #include "jsapi-class.h"
 #include "jsapi-wrapper.h"
 #include "mem.h"
+#include "module.h"
 #include "native.h"
 
 #include <gio/gio.h>
@@ -185,34 +186,18 @@ import_directory(JSContext       *context,
     return importer != NULL;
 }
 
-static bool
-define_import(JSContext       *context,
-              JS::HandleObject obj,
-              JS::HandleObject module_obj,
-              const char      *name)
-{
-    if (!JS_DefineProperty(context, obj, name, module_obj,
-                           GJS_MODULE_PROP_FLAGS & ~JSPROP_PERMANENT)) {
-        gjs_debug(GJS_DEBUG_IMPORTER,
-                  "Failed to define '%s' in importer",
-                  name);
-        return false;
-    }
-
-    return true;
-}
-
-/* Make the property we set in define_import permament;
+/* Make the property we set in gjs_module_import() permanent;
  * we do this after the import succesfully completes.
  */
 static bool
 seal_import(JSContext       *cx,
             JS::HandleObject obj,
+            JS::HandleId     id,
             const char      *name)
 {
     JS::Rooted<JSPropertyDescriptor> descr(cx);
 
-    if (!JS_GetOwnPropertyDescriptor(cx, obj, name, &descr) ||
+    if (!JS_GetOwnPropertyDescriptorById(cx, obj, id, &descr) ||
         descr.object() == NULL) {
         gjs_debug(GJS_DEBUG_IMPORTER,
                   "Failed to get attributes to seal '%s' in importer",
@@ -223,10 +208,10 @@ seal_import(JSContext       *cx,
     /* COMPAT: in mozjs45 use .setConfigurable(false) and the form of
      * JS_DefineProperty that takes the JSPropertyDescriptor directly */
 
-    if (!JS_DefineProperty(cx, descr.object(), name, descr.value(),
-                           descr.attributes() | JSPROP_PERMANENT,
-                           JS_PROPERTYOP_GETTER(descr.getter()),
-                           JS_PROPERTYOP_SETTER(descr.setter()))) {
+    if (!JS_DefinePropertyById(cx, descr.object(), id, descr.value(),
+                               descr.attributes() | JSPROP_PERMANENT,
+                               JS_PROPERTYOP_GETTER(descr.getter()),
+                               JS_PROPERTYOP_SETTER(descr.setter()))) {
         gjs_debug(GJS_DEBUG_IMPORTER,
                   "Failed to redefine attributes to seal '%s' in importer",
                   name);
@@ -327,10 +312,9 @@ import_native_file(JSContext       *context,
 }
 
 static bool
-import_file(JSContext       *context,
-            const char      *name,
-            GFile           *file,
-            JS::HandleObject module_obj)
+import_module_init(JSContext       *context,
+                   GFile           *file,
+                   JS::HandleObject module_obj)
 {
     bool ret = false;
     char *script = NULL;
@@ -399,7 +383,7 @@ load_module_init(JSContext       *context,
 
     JS::RootedObject module_obj(context, JS_NewPlainObject(context));
     GjsAutoUnref<GFile> file = g_file_new_for_commandline_arg(full_path);
-    if (!import_file (context, "__init__", file, module_obj))
+    if (!import_module_init(context, file, module_obj))
         return module_obj;
 
     gjs_object_define_property(context, in_object,
@@ -468,18 +452,16 @@ import_symbol_from_init_js(JSContext       *cx,
 static bool
 import_file_on_module(JSContext       *context,
                       JS::HandleObject obj,
+                      JS::HandleId     id,
                       const char      *name,
                       GFile           *file)
 {
     bool retval = false;
     char *full_path = NULL;
 
-    JS::RootedObject module_obj(context, JS_NewPlainObject(context));
-
-    if (!define_import(context, obj, module_obj, name))
-        goto out;
-
-    if (!import_file(context, name, file, module_obj))
+    JS::RootedObject module_obj(context,
+        gjs_module_import(context, obj, id, name, file));
+    if (!module_obj)
         goto out;
 
     full_path = g_file_get_parse_name (file);
@@ -490,7 +472,7 @@ import_file_on_module(JSContext       *context,
                            0, 0))
         goto out;
 
-    if (!seal_import(context, obj, name))
+    if (!seal_import(context, obj, id, name))
         goto out;
 
     retval = true;
@@ -507,6 +489,7 @@ static bool
 do_import(JSContext       *context,
           JS::HandleObject obj,
           Importer        *priv,
+          JS::HandleId     id,
           const char      *name)
 {
     char *filename;
@@ -629,7 +612,7 @@ do_import(JSContext       *context,
             continue;
         }
 
-        if (import_file_on_module (context, obj, name, gfile)) {
+        if (import_file_on_module(context, obj, id, name, gfile)) {
             gjs_debug(GJS_DEBUG_IMPORTER,
                       "successfully imported module '%s'", name);
             result = true;
@@ -833,7 +816,7 @@ importer_resolve(JSContext        *context,
     }
 
     JSAutoRequest ar(context);
-    if (!do_import(context, obj, priv, name))
+    if (!do_import(context, obj, priv, id, name))
         return false;
 
     *resolved = true;
diff --git a/cjs/module.cpp b/cjs/module.cpp
new file mode 100644
index 00000000..0a4ea970
--- /dev/null
+++ b/cjs/module.cpp
@@ -0,0 +1,209 @@
+/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; -*- */
+/*
+ * Copyright (c) 2017  Philip Chimento <philip.chimento@gmail.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <gio/gio.h>
+
+#include "jsapi-private.h"
+#include "jsapi-util.h"
+#include "jsapi-wrapper.h"
+#include "module.h"
+#include "util/log.h"
+
+class GjsModule {
+    char *m_name;
+
+    GjsModule(const char *name)
+    {
+        m_name = g_strdup(name);
+    }
+
+    ~GjsModule()
+    {
+        g_free(m_name);
+    }
+
+    /* Private data accessors */
+
+    static inline GjsModule *
+    priv(JSObject *module)
+    {
+        return static_cast<GjsModule *>(JS_GetPrivate(module));
+    }
+
+    /* Creates a JS module object. Use instead of the class's constructor */
+    static JSObject *
+    create(JSContext  *cx,
+           const char *name)
+    {
+        JSObject *module = JS_NewObject(cx, &GjsModule::klass);
+        JS_SetPrivate(module, new GjsModule(name));
+        return module;
+    }
+
+    /* Defines the empty module as a property on the importer */
+    bool
+    define_import(JSContext       *cx,
+                  JS::HandleObject module,
+                  JS::HandleObject importer,
+                  JS::HandleId     name)
+    {
+        if (!JS_DefinePropertyById(cx, importer, name, module,
+                                   GJS_MODULE_PROP_FLAGS & ~JSPROP_PERMANENT)) {
+            gjs_debug(GJS_DEBUG_IMPORTER, "Failed to define '%s' in importer",
+                      m_name);
+            return false;
+        }
+
+        return true;
+    }
+
+    /* Carries out the actual execution of the module code */
+    bool
+    evaluate_import(JSContext       *cx,
+                    JS::HandleObject module,
+                    const char      *script,
+                    size_t           script_len,
+                    const char      *filename,
+                    int              line_number)
+    {
+        JS::CompileOptions options(cx);
+        options.setUTF8(true)
+               .setFileAndLine(filename, line_number)
+               .setSourceIsLazy(true);
+
+        JS::RootedScript compiled_script(cx);
+        if (!JS::Compile(cx, module, options, script, script_len,
+                         &compiled_script))
+            return false;
+
+        JS::AutoObjectVector scope_chain(cx);
+        scope_chain.append(module);
+        JS::RootedValue ignored_retval(cx);
+        if (!JS_ExecuteScript(cx, scope_chain, compiled_script, &ignored_retval))
+            return false;
+
+        gjs_schedule_gc_if_needed(cx);
+
+        gjs_debug(GJS_DEBUG_IMPORTER, "Importing module %s succeeded", m_name);
+
+        return true;
+    }
+
+    /* Loads JS code from a file and imports it */
+    bool
+    import_file(JSContext       *cx,
+                JS::HandleObject module,
+                GFile           *file)
+    {
+        GError *error = nullptr;
+        char *unowned_script;
+        size_t script_len = 0;
+        int start_line_number = 1;
+
+        if (!(g_file_load_contents(file, nullptr, &unowned_script, &script_len,
+                                   nullptr, &error))) {
+            gjs_throw_g_error(cx, error);
+            return false;
+        }
+
+        GjsAutoChar script = unowned_script;  /* steals ownership */
+        g_assert(script != nullptr);
+
+        const char *stripped_script =
+            gjs_strip_unix_shebang(script, &script_len, &start_line_number);
+
+        GjsAutoChar full_path = g_file_get_parse_name(file);
+        return evaluate_import(cx, module, stripped_script, script_len,
+                               full_path, start_line_number);
+    }
+
+    /* JSClass operations */
+
+    static void
+    finalize(JSFreeOp *op,
+             JSObject *module)
+    {
+        delete priv(module);
+    }
+
+    static constexpr JSClass klass = {
+        "GjsModule",
+        JSCLASS_HAS_PRIVATE | JSCLASS_BACKGROUND_FINALIZE |
+        JSCLASS_IMPLEMENTS_BARRIERS,
+        nullptr,  /* addProperty */
+        nullptr,  /* deleteProperty */
+        nullptr,  /* getProperty */
+        nullptr,  /* setProperty */
+        nullptr,  /* enumerate */
+        nullptr,  /* resolve */
+        nullptr,  /* mayResolve */
+        &GjsModule::finalize,
+    };
+
+public:
+
+    /* Carries out the import operation */
+    static JSObject *
+    import(JSContext       *cx,
+           JS::HandleObject importer,
+           JS::HandleId     id,
+           const char      *name,
+           GFile           *file)
+    {
+        JS::RootedObject module(cx, GjsModule::create(cx, name));
+        if (!module ||
+            !priv(module)->define_import(cx, module, importer, id) ||
+            !priv(module)->import_file(cx, module, file))
+            return nullptr;
+
+        return module;
+    }
+};
+
+/**
+ * gjs_module_import:
+ * @cx: the JS context
+ * @importer: the JS importer object, parent of the module to be imported
+ * @id: module name in the form of a jsid
+ * @name: module name, used for logging and identification
+ * @file: location of the file to import
+ *
+ * Carries out an import of a GJS module.
+ * Defines a property @name on @importer pointing to the module object, which
+ * is necessary in the case of cyclic imports.
+ * This property is not permanent; the caller is responsible for making it
+ * permanent if the import succeeds.
+ *
+ * Returns: the JS module object, or nullptr on failure.
+ */
+JSObject *
+gjs_module_import(JSContext       *cx,
+                  JS::HandleObject importer,
+                  JS::HandleId     id,
+                  const char      *name,
+                  GFile           *file)
+{
+    return GjsModule::import(cx, importer, id, name, file);
+}
+
+decltype(GjsModule::klass) constexpr GjsModule::klass;
diff --git a/cjs/module.h b/cjs/module.h
new file mode 100644
index 00000000..90413917
--- /dev/null
+++ b/cjs/module.h
@@ -0,0 +1,42 @@
+/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; -*- */
+/*
+ * Copyright (c) 2017  Philip Chimento <philip.chimento@gmail.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef GJS_MODULE_H
+#define GJS_MODULE_H
+
+#include <gio/gio.h>
+
+#include "jsapi-wrapper.h"
+
+G_BEGIN_DECLS
+
+JSObject *
+gjs_module_import(JSContext       *cx,
+                  JS::HandleObject importer,
+                  JS::HandleId     id,
+                  const char      *name,
+                  GFile           *file);
+
+G_END_DECLS
+
+#endif  /* GJS_MODULE_H */
diff --git a/gjs-srcs.mk b/gjs-srcs.mk
index 787cbb9d..4566c9e2 100644
--- a/gjs-srcs.mk
+++ b/gjs-srcs.mk
@@ -71,6 +71,8 @@ gjs_srcs =				\
 	cjs/jsapi-wrapper.h		\
 	cjs/mem.h			\
 	cjs/mem.cpp			\
+	cjs/module.h			\
+	cjs/module.cpp			\
 	cjs/native.cpp			\
 	cjs/native.h			\
 	cjs/runtime.cpp			\
diff --git a/installed-tests/js/jsunit.gresources.xml b/installed-tests/js/jsunit.gresources.xml
index 3fe08f2f..15bd3308 100644
--- a/installed-tests/js/jsunit.gresources.xml
+++ b/installed-tests/js/jsunit.gresources.xml
@@ -6,6 +6,7 @@
     <file>minijasmine.js</file>
     <file>modules/alwaysThrows.js</file>
     <file>modules/foobar.js</file>
+    <file>modules/lexicalScope.js</file>
     <file>modules/modunicode.js</file>
     <file>modules/mutualImport/a.js</file>
     <file>modules/mutualImport/b.js</file>
diff --git a/installed-tests/js/modules/lexicalScope.js b/installed-tests/js/modules/lexicalScope.js
new file mode 100644
index 00000000..65429526
--- /dev/null
+++ b/installed-tests/js/modules/lexicalScope.js
@@ -0,0 +1,25 @@
+/* exported a, b, c */
+
+// Tests bindings in the global scope (var) and lexical environment (let, const)
+
+// This should be exported as a property when importing this module:
+var a = 1;
+
+// These should not be exported, but for compatibility we will pretend they are
+// for the time being:
+let b = 2;
+const c = 3;
+
+// It's not clear whether this should be exported in ES6, but for compatibility
+// it should be:
+this.d = 4;
+
+// Modules should have access to standard properties on the global object.
+if (typeof imports === 'undefined')
+    throw new Error('fail the import');
+
+// This should probably not be supported in the future, but I'm not sure how
+// we can phase it out compatibly. The module should also have access to
+// properties that the importing code defines.
+if (typeof expectMe === 'undefined')
+    throw new Error('fail the import');
diff --git a/installed-tests/js/testImporter.js b/installed-tests/js/testImporter.js
index 6b736437..35879b1a 100644
--- a/installed-tests/js/testImporter.js
+++ b/installed-tests/js/testImporter.js
@@ -156,6 +156,26 @@ describe('Importer', function () {
         expect(ModUnicode.uval).toEqual('const \u2665 utf8');
     });
 
+    describe("properties defined in the module's lexical scope", function () {
+        let LexicalScope;
+
+        beforeAll(function () {
+            window.expectMe = true;
+            LexicalScope = imports.lexicalScope;
+        });
+
+        it('can be accessed', function () {
+            expect(LexicalScope.a).toEqual(1);
+            expect(LexicalScope.b).toEqual(2);
+            expect(LexicalScope.c).toEqual(3);
+            expect(LexicalScope.d).toEqual(4);
+        });
+
+        it('does not leak module properties into the global scope', function () {
+            expect(window.d).not.toBeDefined();
+        });
+    });
+
     describe('enumerating modules', function () {
         let keys;
         beforeEach(function () {

From ff07f39b5b98c52278b0733a7ec785ae24566281 Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 21:59:00 -0500
Subject: [PATCH 040/154] js: Refactor global object creation

In order to more easily create global objects, we refactor code that
deals with them into gjs/global.cpp and gjs/global.h. Previously global
objects were set up partly in gjs_context_constructed() and partly in
gjs_init_context_standard(); we disentangle that code and move everything
dealing with setting up the GjsContext into gjs_context_constructed(),
while global object setup moves to gjs_create_global_object().

Since global objects all share the same root importer, we must split the
setup into two. Creating the root importer is the responsibility of
gjs_context_constructed(), and it requires that the first global has been
created. After creating the root importer, the global object is finished
with gjs_define_global_properties().

In the case of global objects beyond the first, such as the global object
for the coverage compartment, gjs_define_global_properties() will also
wrap the root importer in a cross-compartment wrapper so that the new
global can access it.

https://bugzilla.gnome.org/show_bug.cgi?id=781429

Based on https://github.com/GNOME/gjs/commit/2a38e4ae184534550b418371f973c2faa60be06b
---
 cjs/context.cpp                 | 280 +++++---------------------------
 cjs/coverage.cpp                |  75 +--------
 cjs/global.cpp                  | 352 ++++++++++++++++++++++++++++++++++++++++
 cjs/global.h                    |  72 ++++++++
 cjs/importer.cpp                | 127 ++-------------
 cjs/importer.h                  |  18 +-
 cjs/jsapi-class.h               |   1 +
 cjs/jsapi-constructor-proxy.cpp |   5 +-
 cjs/jsapi-constructor-proxy.h   |   3 +-
 cjs/jsapi-util.cpp              |  95 -----------
 cjs/jsapi-util.h                |  34 ----
 gjs-srcs.mk                     |   2 +
 12 files changed, 498 insertions(+), 566 deletions(-)
 create mode 100644 cjs/global.cpp
 create mode 100644 cjs/global.h

diff --git a/cjs/context.cpp b/cjs/context.cpp
index 6f0ed2e9..055184ff 100644
--- a/cjs/context.cpp
+++ b/cjs/context.cpp
@@ -28,8 +28,8 @@
 #include <gio/gio.h>
 
 #include "context-private.h"
+#include "global.h"
 #include "importer.h"
-#include "jsapi-constructor-proxy.h"
 #include "jsapi-private.h"
 #include "jsapi-util.h"
 #include "jsapi-wrapper.h"
@@ -113,157 +113,6 @@ enum {
 static GMutex contexts_lock;
 static GList *all_contexts = NULL;
 
-static bool
-gjs_log(JSContext *context,
-        unsigned   argc,
-        JS::Value *vp)
-{
-    JS::CallArgs argv = JS::CallArgsFromVp (argc, vp);
-
-    if (argc != 1) {
-        gjs_throw(context, "Must pass a single argument to log()");
-        return false;
-    }
-
-    JS_BeginRequest(context);
-
-    /* JS::ToString might throw, in which case we will only log that the value
-     * could not be converted to string */
-    JS::AutoSaveExceptionState exc_state(context);
-    JS::RootedString jstr(context, JS::ToString(context, argv[0]));
-    exc_state.restore();
-
-    if (jstr == NULL) {
-        g_message("JS LOG: <cannot convert value to string>");
-        JS_EndRequest(context);
-        return true;
-    }
-
-    GjsAutoJSChar s(context);
-    if (!gjs_string_to_utf8(context, JS::StringValue(jstr), &s)) {
-        JS_EndRequest(context);
-        return false;
-    }
-    g_message("JS LOG: %s", s.get());
-
-    JS_EndRequest(context);
-    argv.rval().setUndefined();
-    return true;
-}
-
-static bool
-gjs_log_error(JSContext *context,
-              unsigned   argc,
-              JS::Value *vp)
-{
-    JS::CallArgs argv = JS::CallArgsFromVp (argc, vp);
-
-    if ((argc != 1 && argc != 2) || !argv[0].isObject()) {
-        gjs_throw(context, "Must pass an exception and optionally a message to logError()");
-        return false;
-    }
-
-    JS_BeginRequest(context);
-
-    JS::RootedString jstr(context);
-
-    if (argc == 2) {
-        /* JS::ToString might throw, in which case we will only log that the
-         * value could be converted to string */
-        JS::AutoSaveExceptionState exc_state(context);
-        jstr = JS::ToString(context, argv[1]);
-        exc_state.restore();
-    }
-
-    gjs_log_exception_full(context, argv[0], jstr);
-
-    JS_EndRequest(context);
-    argv.rval().setUndefined();
-    return true;
-}
-
-static bool
-gjs_print_parse_args(JSContext *context,
-                     JS::CallArgs &argv,
-                     char     **buffer)
-{
-    GString *str;
-    guint n;
-
-    JS_BeginRequest(context);
-
-    str = g_string_new("");
-    for (n = 0; n < argv.length(); ++n) {
-        /* JS::ToString might throw, in which case we will only log that the
-         * value could not be converted to string */
-        JS::AutoSaveExceptionState exc_state(context);
-        JS::RootedString jstr(context, JS::ToString(context, argv[n]));
-        exc_state.restore();
-
-        if (jstr != NULL) {
-            GjsAutoJSChar s(context);
-            if (!gjs_string_to_utf8(context, JS::StringValue(jstr), &s)) {
-                JS_EndRequest(context);
-                g_string_free(str, true);
-                return false;
-            }
-
-            g_string_append(str, s);
-            if (n < (argv.length()-1))
-                g_string_append_c(str, ' ');
-        } else {
-            JS_EndRequest(context);
-            *buffer = g_string_free(str, true);
-            if (!*buffer)
-                *buffer = g_strdup("<invalid string>");
-            return true;
-        }
-
-    }
-    *buffer = g_string_free(str, false);
-
-    JS_EndRequest(context);
-    return true;
-}
-
-static bool
-gjs_print(JSContext *context,
-          unsigned   argc,
-          JS::Value *vp)
-{
-    JS::CallArgs argv = JS::CallArgsFromVp (argc, vp);
-    char *buffer;
-
-    if (!gjs_print_parse_args(context, argv, &buffer)) {
-        return false;
-    }
-
-    g_print("%s\n", buffer);
-    g_free(buffer);
-
-    argv.rval().setUndefined();
-    return true;
-}
-
-static bool
-gjs_printerr(JSContext *context,
-             unsigned   argc,
-             JS::Value *vp)
-{
-    JS::CallArgs argv = JS::CallArgsFromVp (argc, vp);
-    char *buffer;
-
-    if (!gjs_print_parse_args(context, argv, &buffer)) {
-        return false;
-    }
-
-    g_printerr("%s\n", buffer);
-    g_free(buffer);
-
-    argv.rval().setUndefined();
-    return true;
-}
-
 static void
 on_garbage_collect(JSRuntime *rt,
                    JSGCStatus status,
@@ -277,45 +126,6 @@ on_garbage_collect(JSRuntime *rt,
         gjs_object_clear_toggles();
 }
 
-/* Requires request, does not throw error */
-static bool
-gjs_define_promise_object(JSContext       *cx,
-                          JS::HandleObject global)
-{
-    /* This is not a regular import, we just load the module's code from the
-     * GResource and evaluate it */
-
-    GError *error = NULL;
-    GBytes *lie_bytes = g_resources_lookup_data("/org/cinnamon/cjs/modules/_lie.js",
-                                                G_RESOURCE_LOOKUP_FLAGS_NONE,
-                                                &error);
-    if (lie_bytes == NULL) {
-        g_critical("Failed to load Promise resource: %s", error->message);
-        g_clear_error(&error);
-        return false;
-    }
-
-    /* It should be OK to cast these bytes to const char *, since the module is
-     * a text file and we setUTF8(true) below */
-    size_t lie_length;
-    const char *lie_code = static_cast<const char *>(g_bytes_get_data(lie_bytes,
-                                                                      &lie_length));
-    JS::CompileOptions options(cx);
-    options.setUTF8(true)
-        .setSourceIsLazy(true)
-        .setFile("<Promise>");
-
-    JS::RootedValue promise(cx);
-    if (!JS::Evaluate(cx, global, options, lie_code, lie_length, &promise)) {
-        g_bytes_unref(lie_bytes);
-        return false;
-    }
-    g_bytes_unref(lie_bytes);
-
-    return JS_DefineProperty(cx, global, "Promise", promise,
-                             JSPROP_READONLY | JSPROP_PERMANENT);
-}
-
 static void
 gjs_context_init(GjsContext *js_context)
 {
@@ -465,14 +275,6 @@ gjs_context_finalize(GObject *object)
     G_OBJECT_CLASS(gjs_context_parent_class)->finalize(object);
 }
 
-static JSFunctionSpec global_funcs[] = {
-    JS_FS("log", gjs_log, 1, GJS_MODULE_PROP_FLAGS),
-    JS_FS("logError", gjs_log_error, 2, GJS_MODULE_PROP_FLAGS),
-    JS_FS("print", gjs_print, 0, GJS_MODULE_PROP_FLAGS),
-    JS_FS("printerr", gjs_printerr, 0, GJS_MODULE_PROP_FLAGS),
-    JS_FS_END
-};
-
 static void
 gjs_context_constructed(GObject *object)
 {
@@ -502,47 +304,55 @@ gjs_context_constructed(GObject *object)
 
     /* set ourselves as the private data */
     JS_SetContextPrivate(js_context->context, js_context);
-    JS::RootedObject global(js_context->context);
 
-    if (!gjs_init_context_standard(js_context->context, &global))
-        g_error("Failed to initialize context");
+    /* setExtraWarnings: Be extra strict about code that might hide a bug */
+    if (!g_getenv("GJS_DISABLE_EXTRA_WARNINGS")) {
+        gjs_debug(GJS_DEBUG_CONTEXT, "Enabling extra warnings");
+        JS::RuntimeOptionsRef(js_context->context).setExtraWarnings(true);
+    }
 
-    JSAutoCompartment ac(js_context->context, global);
+    if (!g_getenv("GJS_DISABLE_JIT")) {
+        gjs_debug(GJS_DEBUG_CONTEXT, "Enabling JIT");
+        JS::RuntimeOptionsRef(js_context->context)
+            .setIon(true)
+            .setBaseline(true)
+            .setAsmJS(true);
+    }
 
-    if (!JS_DefineProperty(js_context->context, global, "window", global,
-                           JSPROP_READONLY | JSPROP_PERMANENT))
-        g_error("No memory to export global object as 'window'");
+    /* setDontReportUncaught: Don't send exceptions to our error report handler;
+     * instead leave them set. This allows us to get at the exception object. */
+    JS::ContextOptionsRef(js_context->context).setDontReportUncaught(true);
+
+    JS::RootedObject global(js_context->context,
+        gjs_create_global_object(js_context->context));
+    if (!global) {
+        gjs_log_exception(js_context->context);
+        g_error("Failed to initialize global object");
+    }
 
-    if (!JS_DefineFunctions(js_context->context, global, &global_funcs[0]))
-        g_error("Failed to define properties on the global object");
+    JSAutoCompartment ac(js_context->context, global);
 
     new (&js_context->global) JS::Heap<JSObject *>(global);
     JS_AddExtraGCRootsTracer(js_context->runtime, gjs_context_tracer, js_context);
 
-    gjs_define_constructor_proxy_factory(js_context->context);
-
-    /* We create the global-to-runtime root importer with the
-     * passed-in search path. If someone else already created
-     * the root importer, this is a no-op.
-     */
-    if (!gjs_create_root_importer(js_context->context,
-                                  js_context->search_path ?
-                                  (const char**) js_context->search_path :
-                                  NULL,
-                                  true))
+    JS::RootedObject importer(js_context->context,
+        gjs_create_root_importer(js_context->context, js_context->search_path ?
+                                 js_context->search_path : nullptr));
+    if (!importer)
         g_error("Failed to create root importer");
 
-    /* Now copy the global root importer (which we just created,
-     * if it didn't exist) to our global object
-     */
-    if (!gjs_define_root_importer(js_context->context, global))
-        g_error("Failed to point 'imports' property at root importer");
+    JS::Value v_importer = gjs_get_global_slot(js_context->context,
+                                               GJS_GLOBAL_SLOT_IMPORTS);
+    g_assert(((void) "Someone else already created root importer",
+              v_importer.isUndefined()));
+
+    gjs_set_global_slot(js_context->context, GJS_GLOBAL_SLOT_IMPORTS,
+                        JS::ObjectValue(*importer));
 
-    /* FIXME: We should define the Promise object before any imports, in case
-     * the imports want to use it. Currently that's not possible as it needs to
-     * import GLib */
-    if(!gjs_define_promise_object(js_context->context, global))
-        g_error("Failed to define global Promise object");
+    if (!gjs_define_global_properties(js_context->context, global)) {
+        gjs_log_exception(js_context->context);
+        g_error("Failed to define properties on global object");
+    }
 
     JS_EndRequest(js_context->context);
 
@@ -669,10 +479,10 @@ _gjs_context_get_is_owner_thread(GjsContext *js_context)
 /**
  * gjs_context_maybe_gc:
  * @context: a #GjsContext
- * 
+ *
  * Similar to the Spidermonkey JS_MaybeGC() call which
  * heuristically looks at JS runtime memory usage and
- * may initiate a garbage collection. 
+ * may initiate a garbage collection.
  *
  * This function always unconditionally invokes JS_MaybeGC(), but
  * additionally looks at memory usage from the system malloc()
@@ -686,7 +496,7 @@ _gjs_context_get_is_owner_thread(GjsContext *js_context)
  *
  * A good time to call this function is when your application
  * transitions to an idle state.
- */ 
+ */
 void
 gjs_context_maybe_gc (GjsContext  *context)
 {
@@ -696,10 +506,10 @@ gjs_context_maybe_gc (GjsContext  *context)
 /**
  * gjs_context_gc:
  * @context: a #GjsContext
- * 
+ *
  * Initiate a full GC; may or may not block until complete.  This
  * function just calls Spidermonkey JS_GC().
- */ 
+ */
 void
 gjs_context_gc (GjsContext  *context)
 {
@@ -909,4 +719,4 @@ gjs_get_import_global(JSContext *context)
 {
     GjsContext *gjs_context = (GjsContext *) JS_GetContextPrivate(context);
     return gjs_context->global;
-}
+}
\ No newline at end of file
diff --git a/cjs/coverage.cpp b/cjs/coverage.cpp
index c474efad..08e82f71 100644
--- a/cjs/coverage.cpp
+++ b/cjs/coverage.cpp
@@ -25,6 +25,7 @@
 
 #include "coverage.h"
 #include "coverage-internal.h"
+#include "global.h"
 #include "importer.h"
 #include "jsapi-util-args.h"
 #include "util/error.h"
@@ -1258,24 +1259,6 @@ gjs_coverage_init(GjsCoverage *self)
 {
 }
 
-static JSClass coverage_global_class = {
-    "GjsCoverageGlobal",
-    JSCLASS_GLOBAL_FLAGS_WITH_SLOTS(GJS_GLOBAL_SLOT_LAST) |
-    JSCLASS_IMPLEMENTS_BARRIERS,
-    NULL,  /* addProperty */
-    NULL,  /* deleteProperty */
-    NULL,  /* getProperty */
-    NULL,  /* setProperty */
-    NULL,  /* enumerate */
-    NULL,  /* resolve */
-    NULL,  /* convert */
-    NULL,  /* finalize */
-    NULL,  /* call */
-    NULL,  /* hasInstance */
-    NULL,  /* construct */
-    JS_GlobalObjectTraceHook
-};
-
 static bool
 gjs_context_eval_file_in_compartment(GjsContext      *context,
                                      const char      *filename,
@@ -1557,27 +1540,6 @@ gjs_inject_value_into_coverage_compartment(GjsCoverage     *coverage,
     return true;
 }
 
-/* Gets the root import and wraps it into a cross-compartment
- * object so that it can be used in the debugger compartment */
-static JSObject *
-gjs_wrap_root_importer_in_compartment(JSContext *context,
-                                      JS::HandleObject compartment)
-{
-    JSAutoRequest ar(context);
-    JSAutoCompartment ac(context, compartment);
-    JS::RootedValue importer(context,
-        gjs_get_global_slot(context, GJS_GLOBAL_SLOT_IMPORTS));
-
-    g_assert(importer.isObject());
-
-    JS::RootedObject wrapped_importer(context, &importer.toObject());
-    if (!JS_WrapObject(context, &wrapped_importer)) {
-        return NULL;
-    }
-
-    return wrapped_importer;
-}
-
 static bool
 bootstrap_coverage(GjsCoverage *coverage)
 {
@@ -1593,8 +1555,7 @@ bootstrap_coverage(GjsCoverage *coverage)
     JS::CompartmentOptions options;
     options.setVersion(JSVERSION_LATEST);
     JS::RootedObject debugger_compartment(context,
-        JS_NewGlobalObject(context, &coverage_global_class, NULL,
-                           JS::FireOnNewGlobalHook, options));
+                                          gjs_create_global_object(context));
     {
         JSAutoCompartment compartment(context, debugger_compartment);
         JS::RootedObject debuggeeWrapper(context, debuggee);
@@ -1610,35 +1571,9 @@ bootstrap_coverage(GjsCoverage *coverage)
             return false;
         }
 
-        if (!JS_InitStandardClasses(context, debugger_compartment)) {
-            gjs_throw(context, "Failed to init standard classes");
-            return false;
-        }
-
-        if (!JS_InitReflect(context, debugger_compartment)) {
-            gjs_throw(context, "Failed to init Reflect");
-            return false;
-        }
-
-        if (!JS_DefineDebuggerObject(context, debugger_compartment)) {
-            gjs_throw(context, "Failed to init Debugger");
-            return false;
-        }
-
-        JS::RootedObject wrapped_importer(context,
-                                          gjs_wrap_root_importer_in_compartment(context,
-                                                                                debugger_compartment));;
-
-        if (!wrapped_importer) {
-            gjs_throw(context, "Failed to wrap root importer in debugger compartment");
-            return false;
-        }
-
-        /* Now copy the global root importer (which we just created,
-         * if it didn't exist) to our global object
-         */
-        if (!gjs_define_root_importer_object(context, debugger_compartment, wrapped_importer)) {
-            gjs_throw(context, "Failed to set 'imports' on debugger compartment");
+        if (!gjs_define_global_properties(context, debugger_compartment)) {
+            gjs_throw(context, "Failed to define global properties on debugger "
+                      "compartment");
             return false;
         }
 
diff --git a/cjs/global.cpp b/cjs/global.cpp
new file mode 100644
index 00000000..2256d712
--- /dev/null
+++ b/cjs/global.cpp
@@ -0,0 +1,352 @@
+/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; -*- */
+/*
+ * Copyright (c) 2008  litl, LLC
+ * Copyright (c) 2009 Red Hat, Inc.
+ * Copyright (c) 2017  Philip Chimento <philip.chimento@gmail.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <gio/gio.h>
+
+#include "global.h"
+#include "importer.h"
+#include "jsapi-constructor-proxy.h"
+#include "jsapi-util.h"
+#include "jsapi-wrapper.h"
+
+static bool
+gjs_log(JSContext *cx,
+        unsigned   argc,
+        JS::Value *vp)
+{
+    JS::CallArgs argv = JS::CallArgsFromVp(argc, vp);
+
+    if (argc != 1) {
+        gjs_throw(cx, "Must pass a single argument to log()");
+        return false;
+    }
+
+    JSAutoRequest ar(cx);
+
+    /* JS::ToString might throw, in which case we will only log that the value
+     * could not be converted to string */
+    JS::AutoSaveExceptionState exc_state(cx);
+    JS::RootedString jstr(cx, JS::ToString(cx, argv[0]));
+    exc_state.restore();
+
+    if (jstr == NULL) {
+        g_message("JS LOG: <cannot convert value to string>");
+        return true;
+    }
+
+    GjsAutoJSChar s(cx);
+    if (!gjs_string_to_utf8(cx, JS::StringValue(jstr), &s))
+        return false;
+
+    g_message("JS LOG: %s", s.get());
+
+    argv.rval().setUndefined();
+    return true;
+}
+
+static bool
+gjs_log_error(JSContext *cx,
+              unsigned   argc,
+              JS::Value *vp)
+{
+    JS::CallArgs argv = JS::CallArgsFromVp(argc, vp);
+
+    if ((argc != 1 && argc != 2) || !argv[0].isObject()) {
+        gjs_throw(cx, "Must pass an exception and optionally a message to logError()");
+        return false;
+    }
+
+    JSAutoRequest ar(cx);
+
+    JS::RootedString jstr(cx);
+
+    if (argc == 2) {
+        /* JS::ToString might throw, in which case we will only log that the
+         * value could not be converted to string */
+        JS::AutoSaveExceptionState exc_state(cx);
+        jstr = JS::ToString(cx, argv[1]);
+        exc_state.restore();
+    }
+
+    gjs_log_exception_full(cx, argv[0], jstr);
+
+    argv.rval().setUndefined();
+    return true;
+}
+
+static bool
+gjs_print_parse_args(JSContext    *cx,
+                     JS::CallArgs& argv,
+                     GjsAutoChar  *buffer)
+{
+    GString *str;
+    guint n;
+
+    JSAutoRequest ar(cx);
+
+    str = g_string_new("");
+    for (n = 0; n < argv.length(); ++n) {
+        /* JS::ToString might throw, in which case we will only log that the
+         * value could not be converted to string */
+        JS::AutoSaveExceptionState exc_state(cx);
+        JS::RootedString jstr(cx, JS::ToString(cx, argv[n]));
+        exc_state.restore();
+
+        if (jstr != NULL) {
+            GjsAutoJSChar s(cx);
+            if (!gjs_string_to_utf8(cx, JS::StringValue(jstr), &s)) {
+                g_string_free(str, true);
+                return false;
+            }
+
+            g_string_append(str, s);
+            if (n < (argv.length()-1))
+                g_string_append_c(str, ' ');
+        } else {
+            *buffer = g_string_free(str, true);
+            if (!*buffer)
+                *buffer = g_strdup("<invalid string>");
+            return true;
+        }
+
+    }
+    *buffer = g_string_free(str, false);
+
+    return true;
+}
+
+static bool
+gjs_print(JSContext *context,
+          unsigned   argc,
+          JS::Value *vp)
+{
+    JS::CallArgs argv = JS::CallArgsFromVp (argc, vp);
+
+    GjsAutoChar buffer;
+    if (!gjs_print_parse_args(context, argv, &buffer))
+        return false;
+
+    g_print("%s\n", buffer.get());
+
+    argv.rval().setUndefined();
+    return true;
+}
+
+static bool
+gjs_printerr(JSContext *context,
+             unsigned   argc,
+             JS::Value *vp)
+{
+    JS::CallArgs argv = JS::CallArgsFromVp(argc, vp);
+
+    GjsAutoChar buffer;
+    if (!gjs_print_parse_args(context, argv, &buffer))
+        return false;
+
+    g_printerr("%s\n", buffer.get());
+
+    argv.rval().setUndefined();
+    return true;
+}
+
+class GjsGlobal {
+    static constexpr JSClass klass = {
+        "GjsGlobal",
+        JSCLASS_GLOBAL_FLAGS_WITH_SLOTS(GJS_GLOBAL_SLOT_LAST) |
+        JSCLASS_IMPLEMENTS_BARRIERS,
+        nullptr,  /* addProperty */
+        nullptr,  /* deleteProperty */
+        nullptr,  /* getProperty */
+        nullptr,  /* setProperty */
+        nullptr,  /* enumerate */
+        nullptr,  /* resolve */
+        nullptr,  /* convert */
+        nullptr,  /* finalize */
+        nullptr,  /* call */
+        nullptr,  /* hasInstance */
+        nullptr,  /* construct */
+        JS_GlobalObjectTraceHook
+    };
+
+    static constexpr JSFunctionSpec static_funcs[] = {
+        JS_FS("log", gjs_log, 1, GJS_MODULE_PROP_FLAGS),
+        JS_FS("logError", gjs_log_error, 2, GJS_MODULE_PROP_FLAGS),
+        JS_FS("print", gjs_print, 0, GJS_MODULE_PROP_FLAGS),
+        JS_FS("printerr", gjs_printerr, 0, GJS_MODULE_PROP_FLAGS),
+        JS_FS_END
+    };
+
+    static bool
+    define_promise_object(JSContext       *cx,
+                          JS::HandleObject global)
+    {
+        /* This is not a regular import, we just load the module's code from the
+         * GResource and evaluate it */
+
+        GError *error = NULL;
+        GBytes *lie_bytes = g_resources_lookup_data("/org/gnome/gjs/modules/_lie.js",
+                                                    G_RESOURCE_LOOKUP_FLAGS_NONE,
+                                                    &error);
+        if (lie_bytes == NULL) {
+            g_critical("Failed to load Promise resource: %s", error->message);
+            g_clear_error(&error);
+            return false;
+        }
+
+        /* It should be OK to cast these bytes to const char *, since the module is
+         * a text file and we setUTF8(true) below */
+        size_t lie_length;
+        const char *lie_code = static_cast<const char *>(g_bytes_get_data(lie_bytes,
+                                                                          &lie_length));
+        JS::CompileOptions options(cx);
+        options.setUTF8(true)
+            .setSourceIsLazy(true)
+            .setFile("<Promise>");
+
+        JS::RootedValue promise(cx);
+        if (!JS::Evaluate(cx, global, options, lie_code, lie_length, &promise)) {
+            g_bytes_unref(lie_bytes);
+            return false;
+        }
+        g_bytes_unref(lie_bytes);
+
+        return JS_DefineProperty(cx, global, "Promise", promise,
+                                 JSPROP_READONLY | JSPROP_PERMANENT);
+    }
+
+public:
+
+    static JSObject *
+    create(JSContext *cx)
+    {
+        JS::CompartmentOptions compartment_options;
+        compartment_options.setVersion(JSVERSION_LATEST);
+        JS::RootedObject global(cx,
+            JS_NewGlobalObject(cx, &GjsGlobal::klass, nullptr,
+                               JS::FireOnNewGlobalHook, compartment_options));
+        if (!global)
+            return nullptr;
+
+        JSAutoCompartment ac(cx, global);
+
+        if (!JS_InitStandardClasses(cx, global) ||
+            !JS_InitReflect(cx, global) ||
+            !JS_DefineDebuggerObject(cx, global))
+            return nullptr;
+
+        return global;
+    }
+
+    static bool
+    define_properties(JSContext       *cx,
+                      JS::HandleObject global)
+    {
+        if (!JS_DefineProperty(cx, global, "window", global,
+                               JSPROP_READONLY | JSPROP_PERMANENT) ||
+            !JS_DefineFunctions(cx, global, GjsGlobal::static_funcs) ||
+            !gjs_define_constructor_proxy_factory(cx, global))
+            return false;
+
+        JS::Value v_importer = gjs_get_global_slot(cx, GJS_GLOBAL_SLOT_IMPORTS);
+        g_assert(((void) "importer should be defined before passing null "
+                  "importer to GjsGlobal::define_properties",
+                  v_importer.isObject()));
+        JS::RootedObject root_importer(cx, &v_importer.toObject());
+
+        /* Wrapping is a no-op if the importer is already in the same
+         * compartment. */
+        if (!JS_WrapObject(cx, &root_importer) ||
+            !gjs_object_define_property(cx, global, GJS_STRING_IMPORTS,
+                                        root_importer, GJS_MODULE_PROP_FLAGS))
+            return false;
+
+        /* FIXME: We should define the Promise object before any imports, in
+         * case the imports want to use it. Currently that's not possible as it
+         * needs to import GLib */
+        return define_promise_object(cx, global);
+    }
+};
+
+/**
+ * gjs_create_global_object:
+ * @cx: a #JSContext
+ *
+ * Creates a global object, and initializes it with the default API.
+ *
+ * Returns: the created global object on success, nullptr otherwise, in which
+ * case an exception is pending on @cx
+ */
+JSObject *
+gjs_create_global_object(JSContext *cx)
+{
+    return GjsGlobal::create(cx);
+}
+
+/**
+ * gjs_define_global_properties:
+ * @cx: a #JSContext
+ * @global: a JS global object that has not yet been passed to this function
+ *
+ * Defines properties on the global object such as 'window' and 'imports'.
+ * This function completes the initialization of a new global object, but it
+ * is separate from gjs_create_global_object() because all globals share the
+ * same root importer.
+ * The code creating the main global for the JS context needs to create the
+ * root importer in between calling gjs_create_global_object() and
+ * gjs_define_global_properties().
+ *
+ * The caller of this function should be in the compartment for @global.
+ * If the root importer object belongs to a different compartment, this
+ * function will create a cross-compartment wrapper for it.
+ *
+ * Returns: true on success, false otherwise, in which case an exception is
+ * pending on @cx
+ */
+bool
+gjs_define_global_properties(JSContext       *cx,
+                             JS::HandleObject global)
+{
+    return GjsGlobal::define_properties(cx, global);
+}
+
+void
+gjs_set_global_slot(JSContext    *cx,
+                    GjsGlobalSlot slot,
+                    JS::Value     value)
+{
+    JSObject *global = gjs_get_import_global(cx);
+    JS_SetReservedSlot(global, JSCLASS_GLOBAL_SLOT_COUNT + slot, value);
+}
+
+JS::Value
+gjs_get_global_slot(JSContext    *cx,
+                    GjsGlobalSlot slot)
+{
+    JSObject *global = gjs_get_import_global(cx);
+    return JS_GetReservedSlot(global, JSCLASS_GLOBAL_SLOT_COUNT + slot);
+}
+
+decltype(GjsGlobal::klass) constexpr GjsGlobal::klass;
+decltype(GjsGlobal::static_funcs) constexpr GjsGlobal::static_funcs;
diff --git a/cjs/global.h b/cjs/global.h
new file mode 100644
index 00000000..31056d6f
--- /dev/null
+++ b/cjs/global.h
@@ -0,0 +1,72 @@
+/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; -*- */
+/*
+ * Copyright (c) 2017  Philip Chimento <philip.chimento@gmail.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef GJS_GLOBAL_H
+#define GJS_GLOBAL_H
+
+#include <glib.h>
+
+#include "jsapi-wrapper.h"
+
+G_BEGIN_DECLS
+
+typedef enum {
+    GJS_GLOBAL_SLOT_IMPORTS,
+    GJS_GLOBAL_SLOT_PROTOTYPE_gtype,
+    GJS_GLOBAL_SLOT_PROTOTYPE_function,
+    GJS_GLOBAL_SLOT_PROTOTYPE_ns,
+    GJS_GLOBAL_SLOT_PROTOTYPE_repo,
+    GJS_GLOBAL_SLOT_PROTOTYPE_byte_array,
+    GJS_GLOBAL_SLOT_PROTOTYPE_importer,
+    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_context,
+    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_gradient,
+    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_image_surface,
+    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_linear_gradient,
+    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_path,
+    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_pattern,
+    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_pdf_surface,
+    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_ps_surface,
+    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_radial_gradient,
+    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_region,
+    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_solid_pattern,
+    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_surface,
+    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_surface_pattern,
+    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_svg_surface,
+    GJS_GLOBAL_SLOT_LAST,
+} GjsGlobalSlot;
+
+JSObject *gjs_create_global_object(JSContext *cx);
+
+bool gjs_define_global_properties(JSContext       *cx,
+                                  JS::HandleObject global);
+
+JS::Value gjs_get_global_slot(JSContext    *cx,
+                              GjsGlobalSlot slot);
+
+void gjs_set_global_slot(JSContext    *context,
+                         GjsGlobalSlot slot,
+                         JS::Value     value);
+
+G_END_DECLS
+
+#endif  /* GJS_GLOBAL_H */
diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index 956a1c0c..88047785 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -351,17 +351,6 @@ import_module_init(JSContext       *context,
     return ret;
 }
 
-static gboolean
-is_extension_module (const gchar *path)
-{
-    if (g_strstr_len (path, -1, "applets") ||
-        g_strstr_len (path, -1, "desklets") ||
-        g_strstr_len (path, -1, "extensions"))
-        return TRUE;
-
-    return FALSE;
-}
-
 static JSObject *
 load_module_init(JSContext       *context,
                  JS::HandleObject in_object,
@@ -370,8 +359,7 @@ load_module_init(JSContext       *context,
     bool found;
 
     /* First we check if js module has already been loaded  */
-    if (!is_extension_module (full_path) &&
-        gjs_object_has_property(context, in_object, GJS_STRING_MODULE_INIT,
+    if (gjs_object_has_property(context, in_object, GJS_STRING_MODULE_INIT,
                                 &found) && found) {
         JS::RootedValue module_obj_val(context);
         if (gjs_object_get_property(context, in_object,
@@ -740,17 +728,13 @@ importer_enumerate(JSContext        *context,
 
         while (true) {
             GFileInfo *info;
-            GError *error = NULL;
-            info = g_file_enumerator_next_file(direnum, NULL, &error);
-            if (error != NULL) {
-                g_error_free (error);
+            GFile *file;
+            if (!g_file_enumerator_iterate(direnum, &info, &file, NULL, NULL))
                 break;
-            }
-            if (info == NULL)
+            if (info == NULL || file == NULL)
                 break;
 
-            GjsAutoChar filename =
-              g_path_get_basename(g_file_info_get_name(info));
+            GjsAutoChar filename = g_file_get_basename(file);
 
             /* skip hidden files and directories (.svn, .git, ...) */
             if (filename[0] == '.')
@@ -825,75 +809,6 @@ importer_resolve(JSContext        *context,
 
 GJS_NATIVE_CONSTRUCTOR_DEFINE_ABSTRACT(importer)
 
-static bool
-gjs_importer_add_subimporter(JSContext *context,
-                             unsigned   argc,
-                             JS::Value *vp)
-{
-    if (argc != 2) {
-        gjs_throw(context, "Must pass two arguments to addSubImporter()");
-        return false;
-    }
-
-    GJS_GET_THIS(context, argc, vp, argv, importer);
-
-    bool success = false;
-
-    JSExceptionState *exc_state;
-
-    char *name;
-    char *path;
-    char *search_path[2] = { 0, 0 };
-
-    JS_BeginRequest(context);
-
-    /* JS::ToString might throw, in which case we will only log that the value
-     * could not be converted to string */
-    exc_state = JS_SaveExceptionState(context);
-    JS::RootedString name_str(context, JS::ToString(context, argv[0]));
-    if (name_str != NULL)
-        argv[0].setString(name_str);
-    JS_RestoreExceptionState(context, exc_state);
-
-    if (name_str == NULL) {
-        g_message("addSubImporter: <cannot convert name value to string>");
-        JS_EndRequest(context);
-        return false;
-    }
-
-    exc_state = JS_SaveExceptionState(context);
-    JS::RootedString path_str(context, JS::ToString(context, argv[1]));
-    if (path_str != NULL)
-        argv[1].setString(path_str);
-    JS_RestoreExceptionState(context, exc_state);
-
-    if (path_str == NULL) {
-        g_message("addSubImporter: <cannot convert path value to string>");
-        JS_EndRequest(context);
-        return false;
-    }
-
-    if (!gjs_string_to_utf8(context, JS::StringValue(name_str), &name))
-        goto out;
-
-    if (!gjs_string_to_utf8(context, JS::StringValue(path_str), &path))
-        goto out;
-
-    search_path[0] = path;
-
-    gjs_define_importer(context, importer, name, (const char **)search_path, FALSE);
-
-    JS_EndRequest(context);
-    argv.rval().setUndefined();
-    success = true;
-
-    out:
-
-    g_free (name);
-    g_free (path);
-    return success;
-}
-
 static void
 importer_finalize(js::FreeOp *fop,
                   JSObject   *obj)
@@ -958,11 +873,6 @@ JSFunctionSpec gjs_importer_proto_funcs[] = {
 
 GJS_DEFINE_PROTO_FUNCS(importer)
 
-JSFunctionSpec gjs_global_importer_funcs[] = {
-    JS_FS("addSubImporter", gjs_importer_add_subimporter, 0, 0),
-    JS_FS_END
-};
-
 static JSObject*
 importer_new(JSContext *context,
              bool       is_root)
@@ -1021,7 +931,7 @@ gjs_get_search_path(void)
             g_free(dirs);
         }
 
-        g_ptr_array_add(path, g_strdup("resource:///org/cinnamon/cjs/modules/"));
+        g_ptr_array_add(path, g_strdup("resource:///org/gnome/gjs/modules/"));
 
         /* $XDG_DATA_DIRS /gjs-1.0 */
         system_data_dirs = g_get_system_data_dirs();
@@ -1123,14 +1033,13 @@ gjs_create_root_importer(JSContext   *context,
                          const char **initial_search_path,
                          bool         add_standard_search_path)
 {
-    JS::Value importer_val;
-    JSObject *importer;
+    JS::Value importer;
 
     JS_BeginRequest(context);
 
-    importer_val = gjs_get_global_slot(context, GJS_GLOBAL_SLOT_IMPORTS);
+    importer = gjs_get_global_slot(context, GJS_GLOBAL_SLOT_IMPORTS);
 
-    if (G_UNLIKELY (!importer_val.isUndefined())) {
+    if (G_UNLIKELY (!importer.isUndefined())) {
         gjs_debug(GJS_DEBUG_IMPORTER,
                   "Someone else already created root importer, ignoring second request");
 
@@ -1138,17 +1047,11 @@ gjs_create_root_importer(JSContext   *context,
         return true;
     }
 
-    importer = gjs_create_importer(context, "imports",
-                                   initial_search_path,
-                                   add_standard_search_path,
-                                   true, JS::NullPtr());
-
-    JS::RootedObject global(context, importer);
-
-    importer_val = JS::ObjectValue (*importer);
-
-    JS_DefineFunctions(context, global, &gjs_global_importer_funcs[0]);
-    gjs_set_global_slot(context, GJS_GLOBAL_SLOT_IMPORTS, importer_val);
+    importer = JS::ObjectValue(*gjs_create_importer(context, "imports",
+                                                    initial_search_path,
+                                                    add_standard_search_path,
+                                                    true, JS::NullPtr()));
+    gjs_set_global_slot(context, GJS_GLOBAL_SLOT_IMPORTS, importer);
 
     JS_EndRequest(context);
     return true;
@@ -1179,4 +1082,4 @@ gjs_define_root_importer(JSContext       *cx,
     JS::Value importer = gjs_get_global_slot(cx, GJS_GLOBAL_SLOT_IMPORTS);
     JS::RootedObject rooted_importer(cx, &importer.toObject());
     return gjs_define_root_importer_object(cx, in_object, rooted_importer);
-}
+}
\ No newline at end of file
diff --git a/cjs/importer.h b/cjs/importer.h
index fa9a5572..4006ee61 100644
--- a/cjs/importer.h
+++ b/cjs/importer.h
@@ -30,22 +30,8 @@
 
 G_BEGIN_DECLS
 
-bool      gjs_create_root_importer (JSContext   *context,
-                                    const char **initial_search_path,
-                                    bool         add_standard_search_path);
-
-bool gjs_define_root_importer(JSContext       *cx,
-                              JS::HandleObject in_object);
-
-bool      gjs_define_root_importer_object(JSContext        *context,
-                                          JS::HandleObject  in_object,
-                                          JS::HandleObject  root_importer);
-
-JSObject *gjs_define_importer(JSContext       *context,
-                              JS::HandleObject in_object,
-                              const char      *importer_name,
-                              const char     **initial_search_path,
-                              bool             add_standard_search_path);
+JSObject *gjs_create_root_importer(JSContext          *cx,
+                                   const char * const *search_path);
 
 G_END_DECLS
 
diff --git a/cjs/jsapi-class.h b/cjs/jsapi-class.h
index 77979018..0d487e77 100644
--- a/cjs/jsapi-class.h
+++ b/cjs/jsapi-class.h
@@ -24,6 +24,7 @@
 #ifndef GJS_JSAPI_CLASS_H
 #define GJS_JSAPI_CLASS_H
 
+#include "global.h"
 #include "jsapi-util.h"
 #include "jsapi-wrapper.h"
 #include "util/log.h"
diff --git a/cjs/jsapi-constructor-proxy.cpp b/cjs/jsapi-constructor-proxy.cpp
index 6bb59b25..ea59bd3f 100644
--- a/cjs/jsapi-constructor-proxy.cpp
+++ b/cjs/jsapi-constructor-proxy.cpp
@@ -173,11 +173,10 @@ create_gjs_constructor_proxy(JSContext *cx,
 }
 
 bool
-gjs_define_constructor_proxy_factory(JSContext *cx)
+gjs_define_constructor_proxy_factory(JSContext       *cx,
+                                     JS::HandleObject global)
 {
     bool found;
-    JS::RootedObject global(cx, gjs_get_import_global(cx));
-
     if (!JS_HasProperty(cx, global, constructor_proxy_create_name, &found))
         return false;
     if (found)
diff --git a/cjs/jsapi-constructor-proxy.h b/cjs/jsapi-constructor-proxy.h
index ef54145a..bc45b072 100644
--- a/cjs/jsapi-constructor-proxy.h
+++ b/cjs/jsapi-constructor-proxy.h
@@ -30,7 +30,8 @@
 
 G_BEGIN_DECLS
 
-bool gjs_define_constructor_proxy_factory(JSContext *cx);
+bool gjs_define_constructor_proxy_factory(JSContext       *cx,
+                                          JS::HandleObject global);
 
 G_END_DECLS
 
diff --git a/cjs/jsapi-util.cpp b/cjs/jsapi-util.cpp
index 0caa514b..183e40e7 100644
--- a/cjs/jsapi-util.cpp
+++ b/cjs/jsapi-util.cpp
@@ -45,101 +45,6 @@ gjs_util_error_quark (void)
     return g_quark_from_static_string ("gjs-util-error-quark");
 }
 
-static JSClass global_class = {
-    "GjsGlobal",
-    JSCLASS_GLOBAL_FLAGS_WITH_SLOTS(GJS_GLOBAL_SLOT_LAST) |
-    JSCLASS_IMPLEMENTS_BARRIERS,
-    NULL,  /* addProperty */
-    NULL,  /* deleteProperty */
-    NULL,  /* getProperty */
-    NULL,  /* setProperty */
-    NULL,  /* enumerate */
-    NULL,  /* resolve */
-    NULL,  /* convert */
-    NULL,  /* finalize */
-    NULL,  /* call */
-    NULL,  /* hasInstance */
-    NULL,  /* construct */
-    JS_GlobalObjectTraceHook
-};
-
-/**
- * gjs_init_context_standard:
- * @context: a #JSContext
- * @global_out: (out): The created global object.
-
- * This function creates a global object given the context,
- * and initializes it with the default API.
- *
- * Returns: true on success, false otherwise
- */
-bool
-gjs_init_context_standard (JSContext              *context,
-                           JS::MutableHandleObject global)
-{
-    JS::CompartmentOptions compartment_options;
-
-    bool extra_warnings = false;
-    if (!g_getenv("GJS_DISABLE_EXTRA_WARNINGS")) {
-        gjs_debug(GJS_DEBUG_CONTEXT, "Enabling extra warnings");
-        extra_warnings = true;
-    }
-
-    /* setDontReportUncaught: Don't send exceptions to our error report handler;
-     * instead leave them set. This allows us to get at the exception object.
-     *
-     * setExtraWarnings: Report warnings to error reporter function.
-     */
-    JS::ContextOptionsRef(context).setDontReportUncaught(true);
-    JS::RuntimeOptionsRef(context).setExtraWarnings(extra_warnings);
-
-    if (!g_getenv("GJS_DISABLE_JIT")) {
-        gjs_debug(GJS_DEBUG_CONTEXT, "Enabling JIT");
-        JS::RuntimeOptionsRef(context)
-            .setIon(true)
-            .setBaseline(true)
-            .setAsmJS(true);
-    }
-
-    compartment_options.setVersion(JSVERSION_LATEST);
-    global.set(JS_NewGlobalObject(context, &global_class, NULL,
-                                  JS::FireOnNewGlobalHook, compartment_options));
-    if (global == NULL)
-        return false;
-
-    JSAutoCompartment ac(context, global);
-
-    if (!JS_InitStandardClasses(context, global))
-        return false;
-
-    if (!JS_InitReflect(context, global))
-        return false;
-
-    if (!JS_DefineDebuggerObject(context, global))
-        return false;
-
-    return true;
-}
-
-void
-gjs_set_global_slot (JSContext     *context,
-                     GjsGlobalSlot  slot,
-                     JS::Value      value)
-{
-    JSObject *global;
-    global = gjs_get_import_global(context);
-    JS_SetReservedSlot(global, JSCLASS_GLOBAL_SLOT_COUNT + slot, value);
-}
-
-JS::Value
-gjs_get_global_slot (JSContext     *context,
-                     GjsGlobalSlot  slot)
-{
-    JSObject *global;
-    global = gjs_get_import_global(context);
-    return JS_GetReservedSlot(global, JSCLASS_GLOBAL_SLOT_COUNT + slot);
-}
-
 bool
 gjs_object_get_property(JSContext             *cx,
                         JS::HandleObject       obj,
diff --git a/cjs/jsapi-util.h b/cjs/jsapi-util.h
index f7f52c8c..27977e6c 100644
--- a/cjs/jsapi-util.h
+++ b/cjs/jsapi-util.h
@@ -123,31 +123,6 @@ enum {
   GJS_UTIL_ERROR_ARGUMENT_TYPE_MISMATCH
 };
 
-typedef enum {
-    GJS_GLOBAL_SLOT_IMPORTS,
-    GJS_GLOBAL_SLOT_PROTOTYPE_gtype,
-    GJS_GLOBAL_SLOT_PROTOTYPE_function,
-    GJS_GLOBAL_SLOT_PROTOTYPE_ns,
-    GJS_GLOBAL_SLOT_PROTOTYPE_repo,
-    GJS_GLOBAL_SLOT_PROTOTYPE_byte_array,
-    GJS_GLOBAL_SLOT_PROTOTYPE_importer,
-    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_context,
-    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_gradient,
-    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_image_surface,
-    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_linear_gradient,
-    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_path,
-    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_pattern,
-    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_pdf_surface,
-    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_ps_surface,
-    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_radial_gradient,
-    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_region,
-    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_solid_pattern,
-    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_surface,
-    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_surface_pattern,
-    GJS_GLOBAL_SLOT_PROTOTYPE_cairo_svg_surface,
-    GJS_GLOBAL_SLOT_LAST,
-} GjsGlobalSlot;
-
 typedef struct GjsRootedArray GjsRootedArray;
 
 /* Flags that should be set on properties exported from native code modules.
@@ -174,17 +149,8 @@ typedef struct GjsRootedArray GjsRootedArray;
     JS::CallArgs args = JS::CallArgsFromVp(argc, vp);          \
     JS::RootedObject to(cx, &args.computeThis(cx).toObject())
 
-bool gjs_init_context_standard(JSContext              *context,
-                               JS::MutableHandleObject global);
-
 JSObject*   gjs_get_import_global            (JSContext       *context);
 
-JS::Value   gjs_get_global_slot              (JSContext       *context,
-                                              GjsGlobalSlot    slot);
-void        gjs_set_global_slot              (JSContext       *context,
-                                              GjsGlobalSlot    slot,
-                                              JS::Value        value);
-
 void gjs_throw_constructor_error             (JSContext       *context);
 
 void gjs_throw_abstract_constructor_error(JSContext    *context,
diff --git a/gjs-srcs.mk b/gjs-srcs.mk
index 4566c9e2..9cdd5cc4 100644
--- a/gjs-srcs.mk
+++ b/gjs-srcs.mk
@@ -54,6 +54,8 @@ gjs_srcs =				\
 	cjs/context-private.h		\
 	cjs/coverage-internal.h		\
 	cjs/coverage.cpp 		\
+	cjs/global.cpp			\
+	cjs/global.h		  \
 	cjs/importer.cpp		\
 	cjs/importer.h			\
 	cjs/jsapi-class.h		\

From 1bd05610d5c28076815dc5d94da6fe6e992d3f68 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 19 Mar 2017 04:48:56 +0000
Subject: [PATCH 041/154] build: Build with mozj45

Changes necessary to header and pkgconfig file names.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/runtime.cpp | 4 +++-
 configure.ac    | 2 +-
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/cjs/runtime.cpp b/cjs/runtime.cpp
index eb9677b5..3c9c2061 100644
--- a/cjs/runtime.cpp
+++ b/cjs/runtime.cpp
@@ -23,8 +23,10 @@
 
 #include <config.h>
 
-#include "jsapi-util.h"
 #include "jsapi-wrapper.h"
+#include <js/Initialization.h>
+
+#include "jsapi-util.h"
 #include "runtime.h"
 
 #ifdef G_OS_WIN32
diff --git a/configure.ac b/configure.ac
index 352dc236..7c2723ff 100644
--- a/configure.ac
+++ b/configure.ac
@@ -62,7 +62,7 @@ GOBJECT_INTROSPECTION_REQUIRE([1.41.4])
 
 GOBJECT_REQUIREMENT="gobject-2.0 >= glib_required_version"
 gjs_base_packages="$GOBJECT_REQUIREMENT gio-2.0"
-common_packages="gthread-2.0 gio-2.0 >= glib_required_version mozjs-38"
+common_packages="gthread-2.0 gio-2.0 >= glib_required_version mozjs-45"
 gjs_packages="gobject-introspection-1.0 libffi $common_packages"
 gjs_cairo_packages="cairo cairo-gobject $common_packages"
 gjs_gtk_packages="gtk+-3.0 >= 3.14.0"

From 2d7ee337de398ae0d6865b0b4cc0c0ba0ee3e96e Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 19 Mar 2017 04:53:15 +0000
Subject: [PATCH 042/154] js: new JS_Enumerate API

You now have to pass into JS_Enumerate() a rooted JS::IdVector for it to
fill in, rather than it returning a JSIdArray.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/importer.cpp | 4 ++--
 gi/arg.cpp       | 4 ++--
 gi/boxed.cpp     | 5 ++---
 gi/object.cpp    | 4 ++--
 4 files changed, 8 insertions(+), 9 deletions(-)

diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index 88047785..0b25091b 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -393,8 +393,8 @@ load_module_elements(JSContext        *cx,
     if (module_obj == NULL)
         return;
 
-    JS::AutoIdArray ids(cx, JS_Enumerate(cx, module_obj));
-    if (!ids)
+    JS::Rooted<JS::IdVector> ids(cx, cx);
+    if (!JS_Enumerate(cx, module_obj, &ids))
         return;
 
     for (ix = 0, length = ids.length(); ix < length; ix++)
diff --git a/gi/arg.cpp b/gi/arg.cpp
index 3912b637..b6a59b75 100644
--- a/gi/arg.cpp
+++ b/gi/arg.cpp
@@ -502,8 +502,8 @@ gjs_object_to_g_hash(JSContext   *context,
         transfer = GI_TRANSFER_NOTHING;
     }
 
-    JS::AutoIdArray ids(context, JS_Enumerate(context, props));
-    if (!ids)
+    JS::Rooted<JS::IdVector> ids(context, context);
+    if (!JS_Enumerate(context, props, &ids))
         return false;
 
     result = create_hash_table_for_key_type(key_param_info);
diff --git a/gi/boxed.cpp b/gi/boxed.cpp
index a35f5e0d..aeefdd04 100644
--- a/gi/boxed.cpp
+++ b/gi/boxed.cpp
@@ -265,9 +265,8 @@ boxed_init_from_props(JSContext   *context,
     }
 
     JS::RootedObject props(context, &props_value.toObject());
-    JS::AutoIdArray ids(context, JS_Enumerate(context, props));
-
-    if (!ids) {
+    JS::Rooted<JS::IdVector> ids(context, context);
+    if (!JS_Enumerate(context, props, &ids)) {
         gjs_throw(context, "Failed to enumerate fields hash");
         return false;
     }
diff --git a/gi/object.cpp b/gi/object.cpp
index ef95f3c4..b53da708 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -835,9 +835,9 @@ object_instance_props_to_g_parameters(JSContext                  *context,
 
     JS::RootedObject props(context, &args[0].toObject());
     JS::RootedId prop_id(context);
-    JS::AutoIdArray ids(context, JS_Enumerate(context, props));
     JS::RootedValue value(context);
-    if (!ids) {
+    JS::Rooted<JS::IdVector> ids(context, context);
+    if (!JS_Enumerate(context, props, &ids)) {
         gjs_throw(context, "Failed to create property iterator for object props hash");
         goto free_array_and_fail;
     }

From d5e79206b4b27b36b8c6f4300553bc208e294eac Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 22:11:33 -0500
Subject: [PATCH 043/154] js: Switch from JS::NullPtr() to nullptr

JS::NullPtr() is gone, and instead now functions that took JS::NullPtr()
as a null handle value take nullptr_t, so we should use C++ nullptr.

https://bugzilla.gnome.org/show_bug.cgi?id=784196

Reconciled from https://github.com/GNOME/gjs/commit/ef18c5a40db7eacff2fe0cd45cb12e1d0427fe94
---
 cjs/context.cpp    |  2 +-
 cjs/importer.cpp   | 80 ++++++++++--------------------------------------------
 cjs/jsapi-util.cpp |  2 +-
 gi/boxed.cpp       |  4 +--
 gi/closure.cpp     |  2 +-
 gi/function.cpp    |  2 +-
 gi/gtype.cpp       |  5 ++--
 gi/interface.cpp   |  4 +--
 gi/ns.cpp          |  2 +-
 gi/param.cpp       |  4 +--
 gi/repo.cpp        |  2 +-
 gi/union.cpp       |  3 +-
 12 files changed, 28 insertions(+), 84 deletions(-)

diff --git a/cjs/context.cpp b/cjs/context.cpp
index 055184ff..c5ec083a 100644
--- a/cjs/context.cpp
+++ b/cjs/context.cpp
@@ -567,7 +567,7 @@ gjs_context_eval(GjsContext   *js_context,
     g_object_ref(G_OBJECT(js_context));
 
     JS::RootedValue retval(js_context->context);
-    if (!gjs_eval_with_scope(js_context->context, JS::NullPtr(), script,
+    if (!gjs_eval_with_scope(js_context->context, nullptr, script,
                              script_len, filename, &retval)) {
         uint8_t code;
         if (_gjs_context_should_exit(js_context, &code)) {
diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index 0b25091b..dff4c45c 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -63,6 +63,9 @@ static const JSClass gjs_importer_class = *js::Jsvalify(&gjs_importer_real_class
 
 GJS_DEFINE_PRIV_FROM_JS(Importer, gjs_importer_class)
 
+static JSObject *gjs_define_importer(JSContext *, JS::HandleObject,
+    const char *, const char **, bool);
+
 static bool
 importer_to_string(JSContext *cx,
                    unsigned   argc,
@@ -880,7 +883,7 @@ importer_new(JSContext *context,
     Importer *priv;
 
     JS::RootedObject proto(context);
-    if (!gjs_importer_define_proto(context, JS::NullPtr(), &proto))
+    if (!gjs_importer_define_proto(context, nullptr, &proto))
         g_error("Error creating importer prototype");
 
     JS::RootedObject importer(context,
@@ -966,12 +969,12 @@ gjs_get_search_path(void)
 }
 
 static JSObject*
-gjs_create_importer(JSContext       *context,
-                    const char      *importer_name,
-                    const char     **initial_search_path,
-                    bool             add_standard_search_path,
-                    bool             is_root,
-                    JS::HandleObject in_object)
+gjs_create_importer(JSContext          *context,
+                    const char         *importer_name,
+                    const char * const *initial_search_path,
+                    bool                add_standard_search_path,
+                    bool                is_root,
+                    JS::HandleObject    in_object)
 {
     char **paths[2] = {0};
     char **search_path;
@@ -1001,7 +1004,7 @@ gjs_create_importer(JSContext       *context,
     return importer;
 }
 
-JSObject*
+static JSObject *
 gjs_define_importer(JSContext       *context,
                     JS::HandleObject in_object,
                     const char      *importer_name,
@@ -1024,62 +1027,9 @@ gjs_define_importer(JSContext       *context,
     return importer;
 }
 
-/* If this were called twice for the same runtime with different args it
- * would basically be a bug, but checking for that is a lot of code so
- * we just ignore all calls after the first and hope the args are the same.
- */
-bool
-gjs_create_root_importer(JSContext   *context,
-                         const char **initial_search_path,
-                         bool         add_standard_search_path)
-{
-    JS::Value importer;
-
-    JS_BeginRequest(context);
-
-    importer = gjs_get_global_slot(context, GJS_GLOBAL_SLOT_IMPORTS);
-
-    if (G_UNLIKELY (!importer.isUndefined())) {
-        gjs_debug(GJS_DEBUG_IMPORTER,
-                  "Someone else already created root importer, ignoring second request");
-
-        JS_EndRequest(context);
-        return true;
-    }
-
-    importer = JS::ObjectValue(*gjs_create_importer(context, "imports",
-                                                    initial_search_path,
-                                                    add_standard_search_path,
-                                                    true, JS::NullPtr()));
-    gjs_set_global_slot(context, GJS_GLOBAL_SLOT_IMPORTS, importer);
-
-    JS_EndRequest(context);
-    return true;
-}
-
-bool
-gjs_define_root_importer_object(JSContext        *context,
-                                JS::HandleObject  in_object,
-                                JS::HandleObject  root_importer)
-{
-    JSAutoRequest ar(context);
-
-    if (!gjs_object_define_property(context, in_object,
-                                    GJS_STRING_IMPORTS, root_importer,
-                                    GJS_MODULE_PROP_FLAGS)) {
-        gjs_debug(GJS_DEBUG_IMPORTER, "DefineProperty imports on %p failed",
-                  in_object.get());
-        return false;
-    }
-
-    return true;
-}
-
-bool
-gjs_define_root_importer(JSContext       *cx,
-                         JS::HandleObject in_object)
+JSObject *
+gjs_create_root_importer(JSContext          *cx,
+                         const char * const *search_path)
 {
-    JS::Value importer = gjs_get_global_slot(cx, GJS_GLOBAL_SLOT_IMPORTS);
-    JS::RootedObject rooted_importer(cx, &importer.toObject());
-    return gjs_define_root_importer_object(cx, in_object, rooted_importer);
+    return gjs_create_importer(cx, "imports", search_path, true, true, nullptr);
 }
\ No newline at end of file
diff --git a/cjs/jsapi-util.cpp b/cjs/jsapi-util.cpp
index 183e40e7..b7fbfa7f 100644
--- a/cjs/jsapi-util.cpp
+++ b/cjs/jsapi-util.cpp
@@ -590,7 +590,7 @@ gjs_log_exception(JSContext  *context)
 
     JS_ClearPendingException(context);
 
-    gjs_log_exception_full(context, exc, JS::NullPtr());
+    gjs_log_exception_full(context, exc, nullptr);
 
     retval = true;
 
diff --git a/gi/boxed.cpp b/gi/boxed.cpp
index aeefdd04..5fd6e33a 100644
--- a/gi/boxed.cpp
+++ b/gi/boxed.cpp
@@ -322,7 +322,7 @@ boxed_invoke_constructor(JSContext             *context,
                                      constructor_name, &js_constructor_func))
         return false;
 
-    return gjs_call_function_value(context, JS::NullPtr(), js_constructor_func,
+    return gjs_call_function_value(context, nullptr, js_constructor_func,
                                    args, args.rval());
 }
 
@@ -1148,7 +1148,7 @@ gjs_define_boxed_class(JSContext       *context,
     constructor_name = g_base_info_get_name( (GIBaseInfo*) info);
 
     if (!gjs_init_class_dynamic(context, in_object,
-                                JS::NullPtr(), /* parent prototype */
+                                nullptr, /* parent prototype */
                                 g_base_info_get_namespace( (GIBaseInfo*) info),
                                 constructor_name,
                                 &gjs_boxed_class,
diff --git a/gi/closure.cpp b/gi/closure.cpp
index 4dcef120..0047441a 100644
--- a/gi/closure.cpp
+++ b/gi/closure.cpp
@@ -211,7 +211,7 @@ gjs_closure_invoke(GClosure                   *closure,
     JS::RootedValue v_closure(context, JS::ObjectValue(*c->obj));
     if (!gjs_call_function_value(context,
                                  /* "this" object; null is some kind of default presumably */
-                                 JS::NullPtr(),
+                                 nullptr,
                                  v_closure, args, retval)) {
         /* Exception thrown... */
         gjs_debug_closure("Closure invocation failed (exception should "
diff --git a/gi/function.cpp b/gi/function.cpp
index 4857ee8c..5b601159 100644
--- a/gi/function.cpp
+++ b/gi/function.cpp
@@ -1678,7 +1678,7 @@ function_new(JSContext      *context,
     Function *priv;
 
     JS::RootedObject proto(context);
-    if (!gjs_function_define_proto(context, JS::NullPtr(), &proto))
+    if (!gjs_function_define_proto(context, nullptr, &proto))
         return nullptr;
 
     JS::RootedObject function(context,
diff --git a/gi/gtype.cpp b/gi/gtype.cpp
index 0b6a294c..4b9333c7 100644
--- a/gi/gtype.cpp
+++ b/gi/gtype.cpp
@@ -159,12 +159,11 @@ gjs_gtype_create_gtype_wrapper (JSContext *context,
         return *heap_wrapper;
 
     JS::RootedObject proto(context);
-    if (!gjs_gtype_define_proto(context, JS::NullPtr(), &proto))
+    if (!gjs_gtype_define_proto(context, nullptr, &proto))
         return nullptr;
 
     heap_wrapper = new JS::Heap<JSObject *>();
-    *heap_wrapper = JS_NewObjectWithGivenProto(context, &gjs_gtype_class, proto,
-                                               JS::NullPtr());
+    *heap_wrapper = JS_NewObjectWithGivenProto(context, &gjs_gtype_class, proto);
     if (*heap_wrapper == nullptr)
         return nullptr;
 
diff --git a/gi/interface.cpp b/gi/interface.cpp
index 43573791..52ec8f3b 100644
--- a/gi/interface.cpp
+++ b/gi/interface.cpp
@@ -195,9 +195,7 @@ gjs_define_interface_class(JSContext              *context,
     ns = gjs_get_names_from_gtype_and_gi_info(gtype, (GIBaseInfo *) info,
                                               &constructor_name);
 
-    if (!gjs_init_class_dynamic(context, in_object,
-                                JS::NullPtr(),
-                                ns,
+    if (!gjs_init_class_dynamic(context, in_object, nullptr, ns,
                                 constructor_name,
                                 &gjs_interface_class,
                                 gjs_interface_constructor, 0,
diff --git a/gi/ns.cpp b/gi/ns.cpp
index 12178e1b..bf191e2c 100644
--- a/gi/ns.cpp
+++ b/gi/ns.cpp
@@ -182,7 +182,7 @@ ns_new(JSContext    *context,
     Ns *priv;
 
     JS::RootedObject proto(context);
-    if (!gjs_ns_define_proto(context, JS::NullPtr(), &proto))
+    if (!gjs_ns_define_proto(context, nullptr, &proto))
         return nullptr;
 
     JS::RootedObject ns(context,
diff --git a/gi/param.cpp b/gi/param.cpp
index 120d627a..c453ef6d 100644
--- a/gi/param.cpp
+++ b/gi/param.cpp
@@ -209,9 +209,7 @@ gjs_define_param_class(JSContext       *context,
 
     constructor_name = "ParamSpec";
 
-    if (!gjs_init_class_dynamic(context, in_object,
-                                JS::NullPtr(),
-                                "GObject",
+    if (!gjs_init_class_dynamic(context, in_object, nullptr, "GObject",
                                 constructor_name,
                                 &gjs_param_class,
                                 gjs_param_constructor, 0,
diff --git a/gi/repo.cpp b/gi/repo.cpp
index 75a59234..7a1617c6 100644
--- a/gi/repo.cpp
+++ b/gi/repo.cpp
@@ -242,7 +242,7 @@ repo_new(JSContext *context)
     Repo *priv;
 
     JS::RootedObject proto(context);
-    if (!gjs_repo_define_proto(context, JS::NullPtr(), &proto))
+    if (!gjs_repo_define_proto(context, nullptr, &proto))
         return nullptr;
 
     JS::RootedObject repo(context,
diff --git a/gi/union.cpp b/gi/union.cpp
index 028a5966..a7a1d5aa 100644
--- a/gi/union.cpp
+++ b/gi/union.cpp
@@ -336,8 +336,7 @@ gjs_define_union_class(JSContext       *context,
 
     constructor_name = g_base_info_get_name( (GIBaseInfo*) info);
 
-    if (!gjs_init_class_dynamic(context, in_object,
-                                JS::NullPtr(),
+    if (!gjs_init_class_dynamic(context, in_object, nullptr,
                                 g_base_info_get_namespace( (GIBaseInfo*) info),
                                 constructor_name,
                                 &gjs_union_class,

From 33b76af492818572f7e0a0658c3a1b72542d9a03 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 19 Mar 2017 05:06:48 +0000
Subject: [PATCH 044/154] js: Global object is implicit in many functions

In many function calls where you had to pass in a global object, it is
now implicit and will use the global for the current scope.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/coverage.cpp            | 12 ++++--------
 cjs/global.cpp              |  2 +-
 cjs/jsapi-dynamic-class.cpp |  4 +---
 cjs/jsapi-util.cpp          |  2 +-
 cjs/module.cpp              |  3 +--
 gi/boxed.cpp                |  2 +-
 modules/console.cpp         | 13 ++++++-------
 test/gjs-test-call-args.cpp |  8 ++------
 8 files changed, 17 insertions(+), 29 deletions(-)

diff --git a/cjs/coverage.cpp b/cjs/coverage.cpp
index 08e82f71..90ef5f38 100644
--- a/cjs/coverage.cpp
+++ b/cjs/coverage.cpp
@@ -1295,12 +1295,11 @@ gjs_context_eval_file_in_compartment(GjsContext      *context,
            .setFileAndLine(filename, start_line_number)
            .setSourceIsLazy(true);
     JS::RootedScript compiled_script(js_context);
-    if (!JS::Compile(js_context, compartment_object, options, stripped_script,
-                     script_len, &compiled_script))
+    if (!JS::Compile(js_context, options, stripped_script, script_len,
+                     &compiled_script))
         return false;
 
-    if (!JS::CloneAndExecuteScript(js_context, compartment_object,
-                                   compiled_script)) {
+    if (!JS::CloneAndExecuteScript(js_context, compiled_script)) {
         g_free(script);
         gjs_log_exception(js_context);
         g_set_error(error, GJS_ERROR, GJS_ERROR_FAILED, "Failed to evaluate %s", filename);
@@ -1505,10 +1504,7 @@ gjs_run_script_in_coverage_compartment(GjsCoverage *coverage,
     options.setUTF8(true);
 
     JS::RootedValue rval(js_context);
-    JS::RootedObject global(js_context,
-        JS_GetGlobalForObject(js_context, priv->coverage_statistics));
-    if (!JS::Evaluate(js_context, global, options, script, strlen(script),
-                      &rval)) {
+    if (!JS::Evaluate(js_context, options, script, strlen(script), &rval)) {
         gjs_log_exception(js_context);
         g_warning("Failed to evaluate <coverage_modifier>");
         return false;
diff --git a/cjs/global.cpp b/cjs/global.cpp
index 2256d712..f91e449d 100644
--- a/cjs/global.cpp
+++ b/cjs/global.cpp
@@ -226,7 +226,7 @@ class GjsGlobal {
             .setFile("<Promise>");
 
         JS::RootedValue promise(cx);
-        if (!JS::Evaluate(cx, global, options, lie_code, lie_length, &promise)) {
+        if (!JS::Evaluate(cx, options, lie_code, lie_length, &promise)) {
             g_bytes_unref(lie_bytes);
             return false;
         }
diff --git a/cjs/jsapi-dynamic-class.cpp b/cjs/jsapi-dynamic-class.cpp
index 3d702228..7d45339b 100644
--- a/cjs/jsapi-dynamic-class.cpp
+++ b/cjs/jsapi-dynamic-class.cpp
@@ -67,8 +67,6 @@ gjs_init_class_dynamic(JSContext              *context,
 
     JS_BeginRequest(context);
 
-    JS::RootedObject global(context, gjs_get_import_global(context));
-
     /* Class initalization consists of three parts:
        - building a prototype
        - defining prototype properties and functions
@@ -99,7 +97,7 @@ gjs_init_class_dynamic(JSContext              *context,
 
     full_function_name = g_strdup_printf("%s_%s", ns_name, class_name);
     constructor_fun = JS_NewFunction(context, constructor_native, nargs, JSFUN_CONSTRUCTOR,
-                                     global, full_function_name);
+                                     full_function_name);
     if (!constructor_fun)
         goto out;
 
diff --git a/cjs/jsapi-util.cpp b/cjs/jsapi-util.cpp
index b7fbfa7f..465b04f5 100644
--- a/cjs/jsapi-util.cpp
+++ b/cjs/jsapi-util.cpp
@@ -835,7 +835,7 @@ gjs_eval_with_scope(JSContext             *context,
            .setSourceIsLazy(true);
 
     JS::RootedScript compiled_script(context);
-    if (!JS::Compile(context, object, options, script, real_len, &compiled_script))
+    if (!JS::Compile(context, options, script, real_len, &compiled_script))
         return false;
 
     JS::AutoObjectVector scope_chain(context);
diff --git a/cjs/module.cpp b/cjs/module.cpp
index 0a4ea970..ceeb8b69 100644
--- a/cjs/module.cpp
+++ b/cjs/module.cpp
@@ -92,8 +92,7 @@ class GjsModule {
                .setSourceIsLazy(true);
 
         JS::RootedScript compiled_script(cx);
-        if (!JS::Compile(cx, module, options, script, script_len,
-                         &compiled_script))
+        if (!JS::Compile(cx, options, script, script_len, &compiled_script))
             return false;
 
         JS::AutoObjectVector scope_chain(cx);
diff --git a/gi/boxed.cpp b/gi/boxed.cpp
index 5fd6e33a..8559d166 100644
--- a/gi/boxed.cpp
+++ b/gi/boxed.cpp
@@ -594,7 +594,7 @@ define_native_accessor_wrapper(JSContext  *cx,
                                uint32_t    id)
 {
     JSFunction *func = js::NewFunctionWithReserved(cx, call, nargs, 0,
-                                                   NULL, func_name);
+                                                   func_name);
     if (!func)
         return NULL;
 
diff --git a/modules/console.cpp b/modules/console.cpp
index a2000c64..2e588de3 100644
--- a/modules/console.cpp
+++ b/modules/console.cpp
@@ -190,18 +190,17 @@ gjs_console_readline(JSContext *cx, char **bufp, FILE *file, const char *prompt)
  * invocation of this function.)
  */
 static bool
-gjs_console_eval_and_print(JSContext       *cx,
-                           JS::HandleObject global,
-                           const char      *bytes,
-                           size_t           length,
-                           int              lineno)
+gjs_console_eval_and_print(JSContext  *cx,
+                           const char *bytes,
+                           size_t      length,
+                           int         lineno)
 {
     JS::CompileOptions options(cx);
     options.setUTF8(true)
            .setFileAndLine("typein", lineno);
 
     JS::RootedValue result(cx);
-    if (!JS::Evaluate(cx, global, options, bytes, length, &result)) {
+    if (!JS::Evaluate(cx, options, bytes, length, &result)) {
         if (!JS_IsExceptionPending(cx))
             return false;
     }
@@ -264,7 +263,7 @@ gjs_console_interact(JSContext *context,
                                             buffer->str, buffer->len));
 
         AutoReportException are(context);
-        if (!gjs_console_eval_and_print(context, global, buffer->str, buffer->len,
+        if (!gjs_console_eval_and_print(context, buffer->str, buffer->len,
                                         startline)) {
             /* If this was an uncatchable exception, throw another uncatchable
              * exception on up to the surrounding JS::Evaluate() in main(). This
diff --git a/test/gjs-test-call-args.cpp b/test/gjs-test-call-args.cpp
index 7d87b8e1..a92a48d2 100644
--- a/test/gjs-test-call-args.cpp
+++ b/test/gjs-test-call-args.cpp
@@ -272,10 +272,8 @@ run_code(GjsUnitTestFixture *fx,
     JS::CompileOptions options(fx->cx, JSVERSION_UNKNOWN);
     options.setFileAndLine("unit test", 1);
 
-    JS::RootedObject global(fx->cx, gjs_get_import_global(fx->cx));
     JS::RootedValue ignored(fx->cx);
-    bool ok = JS::Evaluate(fx->cx, global, options, script, strlen(script),
-                           &ignored);
+    bool ok = JS::Evaluate(fx->cx, options, script, strlen(script), &ignored);
     JS_ReportPendingException(fx->cx);
 
     g_assert_null(fx->message);
@@ -291,10 +289,8 @@ run_code_expect_exception(GjsUnitTestFixture *fx,
     JS::CompileOptions options(fx->cx, JSVERSION_UNKNOWN);
     options.setFileAndLine("unit test", 1);
 
-    JS::RootedObject global(fx->cx, gjs_get_import_global(fx->cx));
     JS::RootedValue ignored(fx->cx);
-    bool ok = JS::Evaluate(fx->cx, global, options, script, strlen(script),
-                           &ignored);
+    bool ok = JS::Evaluate(fx->cx, options, script, strlen(script), &ignored);
     g_assert_false(ok);
     g_assert_true(JS_IsExceptionPending(fx->cx));
     JS_ReportPendingException(fx->cx);

From eb3700ad43e686f24957b88fb0019594b80d0236 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 19 Mar 2017 05:10:08 +0000
Subject: [PATCH 045/154] js: JSCLASS_IMPLEMENTS_BARRIERS is now implicit

In https://bugzilla.mozilla.org/show_bug.cgi?id=1088214 the
JSCLASS_IMPLEMENTS_BARRIERS flag was removed, simply because it's now
required for all JSClass implementations.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/byteArray.cpp  | 3 +--
 cjs/global.cpp     | 3 +--
 cjs/importer.cpp   | 3 +--
 cjs/module.cpp     | 3 +--
 gi/boxed.cpp       | 3 +--
 gi/function.cpp    | 3 +--
 gi/fundamental.cpp | 3 +--
 gi/gerror.cpp      | 3 +--
 gi/interface.cpp   | 3 +--
 gi/ns.cpp          | 3 +--
 gi/object.cpp      | 3 +--
 gi/param.cpp       | 3 +--
 gi/repo.cpp        | 3 +--
 gi/union.cpp       | 3 +--
 14 files changed, 14 insertions(+), 28 deletions(-)

diff --git a/cjs/byteArray.cpp b/cjs/byteArray.cpp
index 89211e0b..6184fe44 100644
--- a/cjs/byteArray.cpp
+++ b/cjs/byteArray.cpp
@@ -58,8 +58,7 @@ static JSObject *gjs_byte_array_get_proto(JSContext *);
 struct JSClass gjs_byte_array_class = {
     "ByteArray",
     JSCLASS_HAS_PRIVATE |
-    JSCLASS_BACKGROUND_FINALIZE |
-    JSCLASS_IMPLEMENTS_BARRIERS,
+    JSCLASS_BACKGROUND_FINALIZE,
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     (JSPropertyOp)byte_array_get_prop,
diff --git a/cjs/global.cpp b/cjs/global.cpp
index f91e449d..248048fe 100644
--- a/cjs/global.cpp
+++ b/cjs/global.cpp
@@ -174,8 +174,7 @@ gjs_printerr(JSContext *context,
 class GjsGlobal {
     static constexpr JSClass klass = {
         "GjsGlobal",
-        JSCLASS_GLOBAL_FLAGS_WITH_SLOTS(GJS_GLOBAL_SLOT_LAST) |
-        JSCLASS_IMPLEMENTS_BARRIERS,
+        JSCLASS_GLOBAL_FLAGS_WITH_SLOTS(GJS_GLOBAL_SLOT_LAST),
         nullptr,  /* addProperty */
         nullptr,  /* deleteProperty */
         nullptr,  /* getProperty */
diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index dff4c45c..3ef0d2fd 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -834,8 +834,7 @@ importer_finalize(js::FreeOp *fop,
  */
 const js::Class gjs_importer_real_class = {
     "GjsFileImporter",
-    JSCLASS_HAS_PRIVATE |
-    JSCLASS_IMPLEMENTS_BARRIERS,
+    JSCLASS_HAS_PRIVATE,
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
diff --git a/cjs/module.cpp b/cjs/module.cpp
index ceeb8b69..e58206b7 100644
--- a/cjs/module.cpp
+++ b/cjs/module.cpp
@@ -147,8 +147,7 @@ class GjsModule {
 
     static constexpr JSClass klass = {
         "GjsModule",
-        JSCLASS_HAS_PRIVATE | JSCLASS_BACKGROUND_FINALIZE |
-        JSCLASS_IMPLEMENTS_BARRIERS,
+        JSCLASS_HAS_PRIVATE | JSCLASS_BACKGROUND_FINALIZE,
         nullptr,  /* addProperty */
         nullptr,  /* deleteProperty */
         nullptr,  /* getProperty */
diff --git a/gi/boxed.cpp b/gi/boxed.cpp
index 8559d166..db862f76 100644
--- a/gi/boxed.cpp
+++ b/gi/boxed.cpp
@@ -922,8 +922,7 @@ boxed_trace(JSTracer *tracer,
 struct JSClass gjs_boxed_class = {
     "GObject_Boxed",
     JSCLASS_HAS_PRIVATE |
-    JSCLASS_HAS_RESERVED_SLOTS(1) |
-    JSCLASS_IMPLEMENTS_BARRIERS,
+    JSCLASS_HAS_RESERVED_SLOTS(1),
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
diff --git a/gi/function.cpp b/gi/function.cpp
index 5b601159..a89a1a73 100644
--- a/gi/function.cpp
+++ b/gi/function.cpp
@@ -1486,8 +1486,7 @@ function_to_string (JSContext *context,
 struct JSClass gjs_function_class = {
     "GIRepositoryFunction", /* means "new GIRepositoryFunction()" works */
     JSCLASS_HAS_PRIVATE |
-    JSCLASS_BACKGROUND_FINALIZE |
-    JSCLASS_IMPLEMENTS_BARRIERS,
+    JSCLASS_BACKGROUND_FINALIZE,
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
diff --git a/gi/fundamental.cpp b/gi/fundamental.cpp
index 139e8214..ce0a2e38 100644
--- a/gi/fundamental.cpp
+++ b/gi/fundamental.cpp
@@ -551,8 +551,7 @@ fundamental_trace(JSTracer *tracer,
  */
 struct JSClass gjs_fundamental_instance_class = {
     "GFundamental_Object",
-    JSCLASS_HAS_PRIVATE |
-    JSCLASS_IMPLEMENTS_BARRIERS,
+    JSCLASS_HAS_PRIVATE,
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
diff --git a/gi/gerror.cpp b/gi/gerror.cpp
index 229b44f0..de6267fa 100644
--- a/gi/gerror.cpp
+++ b/gi/gerror.cpp
@@ -270,8 +270,7 @@ error_constructor_value_of(JSContext *context,
 struct JSClass gjs_error_class = {
     "GLib_Error",
     JSCLASS_HAS_PRIVATE |
-    JSCLASS_BACKGROUND_FINALIZE |
-    JSCLASS_IMPLEMENTS_BARRIERS,
+    JSCLASS_BACKGROUND_FINALIZE,
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
diff --git a/gi/interface.cpp b/gi/interface.cpp
index 52ec8f3b..c81e4420 100644
--- a/gi/interface.cpp
+++ b/gi/interface.cpp
@@ -160,8 +160,7 @@ interface_resolve(JSContext       *context,
 struct JSClass gjs_interface_class = {
     "GObject_Interface",
     JSCLASS_HAS_PRIVATE |
-    JSCLASS_BACKGROUND_FINALIZE |
-    JSCLASS_IMPLEMENTS_BARRIERS,
+    JSCLASS_BACKGROUND_FINALIZE,
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
diff --git a/gi/ns.cpp b/gi/ns.cpp
index bf191e2c..08654bd5 100644
--- a/gi/ns.cpp
+++ b/gi/ns.cpp
@@ -153,8 +153,7 @@ ns_finalize(JSFreeOp *fop,
  */
 struct JSClass gjs_ns_class = {
     "GIRepositoryNamespace",
-    JSCLASS_HAS_PRIVATE |
-    JSCLASS_IMPLEMENTS_BARRIERS,
+    JSCLASS_HAS_PRIVATE,
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
diff --git a/gi/object.cpp b/gi/object.cpp
index b53da708..8f313be6 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -1766,8 +1766,7 @@ to_string_func(JSContext *context,
 
 struct JSClass gjs_object_instance_class = {
     "GObject_Object",
-    JSCLASS_HAS_PRIVATE |
-    JSCLASS_IMPLEMENTS_BARRIERS,
+    JSCLASS_HAS_PRIVATE,
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     object_instance_get_prop,
diff --git a/gi/param.cpp b/gi/param.cpp
index c453ef6d..3c767745 100644
--- a/gi/param.cpp
+++ b/gi/param.cpp
@@ -145,8 +145,7 @@ param_finalize(JSFreeOp *fop,
 struct JSClass gjs_param_class = {
     "GObject_ParamSpec",
     JSCLASS_HAS_PRIVATE |
-    JSCLASS_BACKGROUND_FINALIZE |
-    JSCLASS_IMPLEMENTS_BARRIERS,
+    JSCLASS_BACKGROUND_FINALIZE,
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
diff --git a/gi/repo.cpp b/gi/repo.cpp
index 7a1617c6..5fb57561 100644
--- a/gi/repo.cpp
+++ b/gi/repo.cpp
@@ -218,8 +218,7 @@ repo_finalize(JSFreeOp *fop,
  */
 struct JSClass gjs_repo_class = {
     "GIRepository", /* means "new GIRepository()" works */
-    JSCLASS_HAS_PRIVATE |
-    JSCLASS_IMPLEMENTS_BARRIERS,
+    JSCLASS_HAS_PRIVATE,
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
diff --git a/gi/union.cpp b/gi/union.cpp
index a7a1d5aa..ececf402 100644
--- a/gi/union.cpp
+++ b/gi/union.cpp
@@ -289,8 +289,7 @@ to_string_func(JSContext *context,
  */
 struct JSClass gjs_union_class = {
     "GObject_Union",
-    JSCLASS_HAS_PRIVATE |
-    JSCLASS_IMPLEMENTS_BARRIERS,
+    JSCLASS_HAS_PRIVATE,
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */

From 5c1247d788887112a9340b931394f2c215f4952b Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 19 Mar 2017 05:10:35 +0000
Subject: [PATCH 046/154] js: Weak pointer callback API change

Weak pointer callbacks now come in two flavours: per-zone and
per-compartment. We do everything in one compartment, and don't care
about zones, so we should use the per-compartment flavour.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 gi/gtype.cpp  | 10 ++++++----
 gi/object.cpp | 10 ++++++----
 2 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/gi/gtype.cpp b/gi/gtype.cpp
index 4b9333c7..3119ffd0 100644
--- a/gi/gtype.cpp
+++ b/gi/gtype.cpp
@@ -57,8 +57,9 @@ gjs_get_gtype_wrapper_quark(void)
 }
 
 static void
-update_gtype_weak_pointers(JSRuntime *rt,
-                           void      *data)
+update_gtype_weak_pointers(JSRuntime     *rt,
+                           JSCompartment *compartment,
+                           void          *data)
 {
     for (auto iter = weak_pointer_list.begin(); iter != weak_pointer_list.end(); ) {
         auto heap_wrapper = static_cast<JS::Heap<JSObject *> *>(g_type_get_qdata(*iter, gjs_get_gtype_wrapper_quark()));
@@ -74,8 +75,9 @@ static void
 ensure_weak_pointer_callback(JSContext *cx)
 {
     if (!weak_pointer_callback) {
-        JS_AddWeakPointerCallback(JS_GetRuntime(cx), update_gtype_weak_pointers,
-                                  nullptr);
+        JS_AddWeakPointerCompartmentCallback(JS_GetRuntime(cx),
+                                             update_gtype_weak_pointers,
+                                             nullptr);
         weak_pointer_callback = true;
     }
 }
diff --git a/gi/object.cpp b/gi/object.cpp
index 8f313be6..cd89a813 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -1130,8 +1130,9 @@ init_object_private (JSContext       *context,
 }
 
 static void
-update_heap_wrapper_weak_pointers(JSRuntime *rt,
-                                  gpointer   data)
+update_heap_wrapper_weak_pointers(JSRuntime     *rt,
+                                  JSCompartment *compartment,
+                                  gpointer       data)
 {
     std::vector<GObject *> to_be_disassociated;
 
@@ -1159,8 +1160,9 @@ static void
 ensure_weak_pointer_callback(JSContext *cx)
 {
     if (!weak_pointer_callback) {
-        JS_AddWeakPointerCallback(JS_GetRuntime(cx),
-                                  update_heap_wrapper_weak_pointers, NULL);
+        JS_AddWeakPointerCompartmentCallback(JS_GetRuntime(cx),
+                                             update_heap_wrapper_weak_pointers,
+                                             nullptr);
         weak_pointer_callback = true;
     }
 }

From a001f523bbcf5045c593fd986006f59e34ca4976 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 19 Mar 2017 05:12:53 +0000
Subject: [PATCH 047/154] js: setProperty operations with triple result state

Property setting callbacks now get a JS::ObjectOpResult on which they
have to call the succeed() method or one if the fail() methods. This is
required in order to implement an awkward part of the ES6 spec where it
is possible for a property setting operation to fail despite not throwing
an exception. This replaces what used to be "strict mode" and
JSStrictPropertyOp.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/byteArray.cpp | 23 ++++++++++++-----------
 gi/object.cpp     | 45 +++++++++++++++++++++------------------------
 2 files changed, 33 insertions(+), 35 deletions(-)

diff --git a/cjs/byteArray.cpp b/cjs/byteArray.cpp
index 6184fe44..2090a33d 100644
--- a/cjs/byteArray.cpp
+++ b/cjs/byteArray.cpp
@@ -47,8 +47,8 @@ static bool   byte_array_get_prop      (JSContext    *context,
 static bool   byte_array_set_prop      (JSContext    *context,
                                         JS::HandleObject obj,
                                         JS::HandleId id,
-                                        bool                   strict,
-                                        JS::MutableHandleValue value_p);
+                                        JS::MutableHandleValue value_p,
+                                        JS::ObjectOpResult&    result);
 GJS_NATIVE_CONSTRUCTOR_DECLARE(byte_array);
 static void   byte_array_finalize      (JSFreeOp     *fop,
                                         JSObject     *obj);
@@ -61,8 +61,8 @@ struct JSClass gjs_byte_array_class = {
     JSCLASS_BACKGROUND_FINALIZE,
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
-    (JSPropertyOp)byte_array_get_prop,
-    (JSStrictPropertyOp)byte_array_set_prop,
+    byte_array_get_prop,
+    byte_array_set_prop,
     NULL,  /* enumerate */
     NULL,  /* resolve */
     NULL,  /* convert */
@@ -267,7 +267,8 @@ byte_array_set_index(JSContext         *context,
                      JS::HandleObject obj,
                      ByteArrayInstance *priv,
                      gsize              idx,
-                     JS::MutableHandleValue value_p)
+                     JS::MutableHandleValue value_p,
+                     JS::ObjectOpResult&    result)
 {
     guint8 v;
 
@@ -288,7 +289,7 @@ byte_array_set_index(JSContext         *context,
     /* Stop JS from storing a copy of the value */
     value_p.setUndefined();
 
-    return true;
+    return result.succeed();
 }
 
 /* a hook on setting a property; set value_p to override property value to
@@ -298,15 +299,15 @@ static bool
 byte_array_set_prop(JSContext *context,
                     JS::HandleObject obj,
                     JS::HandleId id,
-                    bool strict,
-                    JS::MutableHandleValue value_p)
+                    JS::MutableHandleValue value_p,
+                    JS::ObjectOpResult&    result)
 {
     ByteArrayInstance *priv;
 
     priv = priv_from_js(context, obj);
 
     if (priv == NULL)
-        return true; /* prototype, not an instance. */
+        return result.succeed(); /* prototype, not an instance. */
 
     JS::RootedValue id_value(context);
     if (!JS_IdToValue(context, id, &id_value))
@@ -318,12 +319,12 @@ byte_array_set_prop(JSContext *context,
         if (!gjs_value_to_gsize(context, id_value, &idx))
             return false;
 
-        return byte_array_set_index(context, obj, priv, idx, value_p);
+        return byte_array_set_index(context, obj, priv, idx, value_p, result);
     }
 
     /* We don't special-case anything else for now */
 
-    return true;
+    return result.succeed();
 }
 
 static GByteArray *
diff --git a/gi/object.cpp b/gi/object.cpp
index cd89a813..8e8d7310 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -421,11 +421,12 @@ object_instance_get_prop(JSContext              *context,
 }
 
 static bool
-set_g_param_from_prop(JSContext      *context,
-                      ObjectInstance *priv,
-                      const char     *name,
-                      bool&           was_set,
-                      JS::HandleValue value_p)
+set_g_param_from_prop(JSContext          *context,
+                      ObjectInstance     *priv,
+                      const char         *name,
+                      bool&               was_set,
+                      JS::HandleValue     value_p,
+                      JS::ObjectOpResult& result)
 {
     GParameter param = { NULL, { 0, }};
     was_set = false;
@@ -438,7 +439,7 @@ set_g_param_from_prop(JSContext      *context,
     case SOME_ERROR_OCCURRED:
         return false;
     case NO_SUCH_G_PROPERTY:
-        return true;
+        return result.succeed();
     case VALUE_WAS_SET:
     default:
         break;
@@ -449,22 +450,22 @@ set_g_param_from_prop(JSContext      *context,
 
     g_value_unset(&param.value);
     was_set = true;
-    return true;
+    return result.succeed();
 }
 
 static bool
 check_set_field_from_prop(JSContext             *cx,
                           ObjectInstance        *priv,
                           const char            *name,
-                          bool                   strict,
-                          JS::MutableHandleValue value_p)
+                          JS::MutableHandleValue value_p,
+                          JS::ObjectOpResult&    result)
 {
     if (priv->info == NULL)
-        return true;
+        return result.succeed();
 
     GIFieldInfo *field = lookup_field_info(priv->info, name);
     if (field == NULL)
-        return true;
+        return result.succeed();
 
     bool retval = true;
 
@@ -473,21 +474,17 @@ check_set_field_from_prop(JSContext             *cx,
     if (g_field_info_get_flags(field) & GI_FIELD_IS_WRITABLE) {
         g_message("Field %s of a GObject is writable, but setting it is not "
                   "implemented", name);
+        result.succeed();
         goto out;
     }
 
-    if (strict) {
-        gjs_throw(cx, "Tried to set read-only field %s in strict mode", name);
-        retval = false;
-        goto out;
-    }
+    result.failReadOnly();  /* still return true; error only in strict mode */
 
     /* We have to update value_p because JS caches it as the property's "stored
      * value" (https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/JSAPI_reference/Stored_value)
      * and so subsequent gets would get the stored value instead of accessing
      * the field */
     value_p.setUndefined();
-
 out:
     g_base_info_unref((GIBaseInfo *) field);
     return retval;
@@ -500,8 +497,8 @@ static bool
 object_instance_set_prop(JSContext              *context,
                          JS::HandleObject        obj,
                          JS::HandleId            id,
-                         bool                    strict,
-                         JS::MutableHandleValue  value_p)
+                         JS::MutableHandleValue  value_p,
+                         JS::ObjectOpResult&     result)
 {
     ObjectInstance *priv;
     GjsAutoJSChar name(context);
@@ -509,7 +506,7 @@ object_instance_set_prop(JSContext              *context,
     bool g_param_was_set = false;
 
     if (!gjs_get_string_id(context, id, &name))
-        return true; /* not resolved, but no error */
+        return result.succeed();  /* not resolved, but no error */
 
     priv = priv_from_js(context, obj);
     gjs_debug_jsprop(GJS_DEBUG_GOBJECT,
@@ -518,12 +515,12 @@ object_instance_set_prop(JSContext              *context,
 
     if (priv == nullptr)
         /* see the comment in object_instance_get_prop() on this */
-        return true;
+        return result.succeed();
 
     if (priv->gobj == NULL) /* prototype, not an instance. */
-        return true;
+        return result.succeed();
 
-    ret = set_g_param_from_prop(context, priv, name, g_param_was_set, value_p);
+    ret = set_g_param_from_prop(context, priv, name, g_param_was_set, value_p, result);
     if (g_param_was_set || !ret)
         return ret;
 
@@ -532,7 +529,7 @@ object_instance_set_prop(JSContext              *context,
      * value. We could also use JS_DefineProperty though and specify a
      * getter/setter maybe, don't know if that is better.
      */
-    return check_set_field_from_prop(context, priv, name, strict, value_p);
+    return check_set_field_from_prop(context, priv, name, value_p, result);
 }
 
 static bool

From b561642aedb7441f3cd0a92eec70b35bbfa43cbb Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 19 Mar 2017 05:14:40 +0000
Subject: [PATCH 048/154] js: New JS_IsArrayObject() API

Now JS_IsArrayObject() distinguishes between errors (returning false) and
the object not being an array (returning true but setting the passed-in
bool ref to false.)

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/byteArray.cpp         |  5 ++++-
 cjs/coverage.cpp          |  5 ++++-
 cjs/importer.cpp          | 12 ++++++++----
 gi/object.cpp             |  9 +++++++--
 modules/cairo-context.cpp |  5 ++++-
 5 files changed, 27 insertions(+), 9 deletions(-)

diff --git a/cjs/byteArray.cpp b/cjs/byteArray.cpp
index 2090a33d..a14f65d5 100644
--- a/cjs/byteArray.cpp
+++ b/cjs/byteArray.cpp
@@ -637,6 +637,7 @@ from_array_func(JSContext *context,
     ByteArrayInstance *priv;
     guint32 len;
     guint32 i;
+    bool is_array;
     JS::RootedObject obj(context, byte_array_new(context));
 
     if (obj == NULL)
@@ -650,7 +651,9 @@ from_array_func(JSContext *context,
     priv->array = gjs_g_byte_array_new(0);
 
     JS::RootedObject array_obj(context, &argv[0].toObject());
-    if (!JS_IsArrayObject(context, array_obj)) {
+    if (!JS_IsArrayObject(context, array_obj, &is_array))
+        return false;
+    if (!is_array) {
         gjs_throw(context,
                   "byteArray.fromArray() called with non-array as first arg");
         return false;
diff --git a/cjs/coverage.cpp b/cjs/coverage.cpp
index 90ef5f38..ddda58ab 100644
--- a/cjs/coverage.cpp
+++ b/cjs/coverage.cpp
@@ -408,7 +408,10 @@ get_array_from_js_value(JSContext             *context,
     g_return_val_if_fail(out_array != NULL, false);
     g_return_val_if_fail(*out_array == NULL, false);
 
-    if (!JS_IsArrayObject(context, value)) {
+    bool is_array;
+    if (!JS_IsArrayObject(context, value, &is_array))
+        return false;
+    if (!is_array) {
         g_critical("Returned object from is not an array");
         return false;
     }
diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index 3ef0d2fd..4fb5d920 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -488,16 +488,17 @@ do_import(JSContext       *context,
     JS::RootedObject search_path(context);
     guint32 search_path_len;
     guint32 i;
-    bool result;
+    bool result, exists, is_array;
     GPtrArray *directories;
     GFile *gfile;
-    bool exists;
 
     if (!gjs_object_require_property(context, obj, "importer",
                                      GJS_STRING_SEARCH_PATH, &search_path))
         return false;
 
-    if (!JS_IsArrayObject(context, search_path)) {
+    if (!JS_IsArrayObject(context, search_path, &is_array))
+        return false;
+    if (!is_array) {
         gjs_throw(context, "searchPath property on importer is not an array");
         return false;
     }
@@ -670,6 +671,7 @@ importer_enumerate(JSContext        *context,
     Importer *priv;
     guint32 search_path_len;
     guint32 i;
+    bool is_array;
 
     priv = priv_from_js(context, object);
 
@@ -683,7 +685,9 @@ importer_enumerate(JSContext        *context,
                                      &search_path))
         return false;
 
-    if (!JS_IsArrayObject(context, search_path)) {
+    if (!JS_IsArrayObject(context, search_path, &is_array))
+        return false;
+    if (!is_array) {
         gjs_throw(context, "searchPath property on importer is not an array");
         return false;
     }
diff --git a/gi/object.cpp b/gi/object.cpp
index 8e8d7310..e32e23e7 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -2585,8 +2585,11 @@ validate_interfaces_and_properties_args(JSContext       *cx,
                                         uint32_t        *n_properties)
 {
     guint32 n_int, n_prop;
+    bool is_array;
 
-    if (!JS_IsArrayObject(cx, interfaces)) {
+    if (!JS_IsArrayObject(cx, interfaces, &is_array))
+        return false;
+    if (!is_array) {
         gjs_throw(cx, "Invalid parameter interfaces (expected Array)");
         return false;
     }
@@ -2594,7 +2597,9 @@ validate_interfaces_and_properties_args(JSContext       *cx,
     if (!JS_GetArrayLength(cx, interfaces, &n_int))
         return false;
 
-    if (!JS_IsArrayObject(cx, properties)) {
+    if (!JS_IsArrayObject(cx, properties, &is_array))
+        return false;
+    if (!is_array) {
         gjs_throw(cx, "Invalid parameter properties (expected Array)");
         return false;
     }
diff --git a/modules/cairo-context.cpp b/modules/cairo-context.cpp
index c2dc5c03..e929b162 100644
--- a/modules/cairo-context.cpp
+++ b/modules/cairo-context.cpp
@@ -540,13 +540,16 @@ setDash_func(JSContext *context,
     JS::RootedObject dashes(context);
     double offset;
     guint len;
+    bool is_array;
 
     if (!gjs_parse_call_args(context, "setDash", argv, "of",
                              "dashes", &dashes,
                              "offset", &offset))
         return false;
 
-    if (!JS_IsArrayObject(context, dashes)) {
+    if (!JS_IsArrayObject(context, dashes, &is_array))
+        return false;
+    if (!is_array) {
         gjs_throw(context, "dashes must be an array");
         return false;
     }

From aedd22abcc6d29322ff7fa94ea8d69c852a2e108 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 19 Mar 2017 05:15:48 +0000
Subject: [PATCH 049/154] js: Rename JS_InternString to JS_AtomizeAndPinString

This was simply renamed in SpiderMonkey 45.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/jsapi-util-string.cpp | 2 +-
 gi/repo.cpp               | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/cjs/jsapi-util-string.cpp b/cjs/jsapi-util-string.cpp
index 16085273..bc8cb740 100644
--- a/cjs/jsapi-util-string.cpp
+++ b/cjs/jsapi-util-string.cpp
@@ -382,7 +382,7 @@ gjs_intern_string_to_id(JSContext  *cx,
                         const char *string)
 {
     JSAutoRequest ar(cx);
-    JS::RootedString str(cx, JS_InternString(cx, string));
+    JS::RootedString str(cx, JS_AtomizeAndPinString(cx, string));
     JS::RootedId id(cx, INTERNED_STRING_TO_JSID(cx, str));
     return id;
 }
diff --git a/gi/repo.cpp b/gi/repo.cpp
index 5fb57561..4720df0d 100644
--- a/gi/repo.cpp
+++ b/gi/repo.cpp
@@ -592,7 +592,7 @@ lookup_override_function(JSContext             *cx,
 
         /* If the exception was an ImportError (i.e., module not found) then
          * we simply didn't have an override, don't throw an exception */
-        if (error_has_name(cx, exc, JS_InternString(cx, "ImportError"))) {
+        if (error_has_name(cx, exc, JS_AtomizeAndPinString(cx, "ImportError"))) {
             saved_exc.restore();
             return true;
         }

From 3f659b70f087d00fae4b14af07b0430574cead17 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 19 Mar 2017 05:16:40 +0000
Subject: [PATCH 050/154] importer: API change in enumerate operation

Now an enumerate operation distinguishes between whether only the
enumerable properties should be enumerated, or all of them, by passing in
a boolean parameter. In the case of the importer object, we don't care,
so we ignore the parameter.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/importer.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index 4fb5d920..b05a6976 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -666,7 +666,8 @@ do_import(JSContext       *context,
 static bool
 importer_enumerate(JSContext        *context,
                    JS::HandleObject  object,
-                   JS::AutoIdVector& properties)
+                   JS::AutoIdVector& properties,
+                   bool              enumerable_only)
 {
     Importer *priv;
     guint32 search_path_len;

From e16d0d7c052c9abc44e9eff7e1be1e6560c4ed7b Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 21 Mar 2017 10:30:59 +0000
Subject: [PATCH 051/154] js: Set JSPROP_RESOLVING when defining properties

JS_DefineProperty() can now call into a class's resolve hook, so when
pre-defining properties on classes with resolve hooks we have to include
JSPROP_RESOLVING in the flags so that the resolve hook is not called.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/importer.cpp            | 28 +++++++++++++---------------
 cjs/jsapi-dynamic-class.cpp | 26 ++++++++++++++++++++++++--
 gi/repo.cpp                 |  4 ++--
 3 files changed, 39 insertions(+), 19 deletions(-)

diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index b05a6976..cd338bd0 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -103,6 +103,12 @@ define_meta_properties(JSContext       *context,
 {
     bool parent_is_module;
 
+    /* For these meta-properties, don't set ENUMERATE since we wouldn't want to
+     * copy these symbols to any other object for example. RESOLVING is used to
+     * make sure we don't try to invoke a "resolve" operation, since this
+     * function may be called from inside one. */
+    unsigned attrs = JSPROP_READONLY | JSPROP_PERMANENT | JSPROP_RESOLVING;
+
     /* We define both __moduleName__ and __parentModule__ to null
      * on the root importer
      */
@@ -115,16 +121,12 @@ define_meta_properties(JSContext       *context,
 
     if (full_path != NULL) {
         JS::RootedString file(context, JS_NewStringCopyZ(context, full_path));
-        if (!JS_DefineProperty(context, module_obj, "__file__", file,
-                               /* don't set ENUMERATE since we wouldn't want to copy
-                                * this symbol to any other object for example.
-                                */
-                               JSPROP_READONLY | JSPROP_PERMANENT))
+        if (!JS_DefineProperty(context, module_obj, "__file__", file, attrs))
             return false;
     }
 
-    /* Null is used instead of undefined to make sure we don't try to invoke
-     * a "resolve" operation. */
+    /* Null is used instead of undefined for backwards compatibility with code
+     * that explicitly checks for null. */
     JS::RootedValue module_name_val(context, JS::NullValue());
     JS::RootedValue parent_module_val(context, JS::NullValue());
     JS::RootedValue module_path(context, JS::NullValue());
@@ -150,20 +152,16 @@ define_meta_properties(JSContext       *context,
         module_path.setString(JS_NewStringCopyZ(context, module_path_buf));
     }
 
-    /* don't set ENUMERATE since we wouldn't want to copy these symbols to any
-     * other object for example. */
     if (!JS_DefineProperty(context, module_obj,
-                           "__moduleName__", module_name_val,
-                           JSPROP_READONLY | JSPROP_PERMANENT))
+                           "__moduleName__", module_name_val, attrs))
         return false;
 
     if (!JS_DefineProperty(context, module_obj,
-                           "__parentModule__", parent_module_val,
-                           JSPROP_READONLY | JSPROP_PERMANENT))
+                           "__parentModule__", parent_module_val, attrs))
         return false;
 
     if (!JS_DefineProperty(context, module_obj, "__modulePath__", module_path,
-                           JSPROP_READONLY | JSPROP_PERMANENT))
+                           attrs))
         return false;
 
     return true;
@@ -997,7 +995,7 @@ gjs_create_importer(JSContext          *context,
     if (!gjs_define_string_array(context, importer,
                                  "searchPath", -1, (const char **)search_path,
                                  /* settable (no READONLY) but not deleteable (PERMANENT) */
-                                 JSPROP_PERMANENT))
+                                 JSPROP_PERMANENT | JSPROP_RESOLVING))
         g_error("no memory to define importer search path prop");
 
     g_strfreev(search_path);
diff --git a/cjs/jsapi-dynamic-class.cpp b/cjs/jsapi-dynamic-class.cpp
index 7d45339b..36e830df 100644
--- a/cjs/jsapi-dynamic-class.cpp
+++ b/cjs/jsapi-dynamic-class.cpp
@@ -90,6 +90,16 @@ gjs_init_class_dynamic(JSContext              *context,
     if (!prototype)
         goto out;
 
+    /* Bypass resolve hooks when defining the initial properties */
+    if (clasp->resolve) {
+        JSPropertySpec *ps_iter;
+        JSFunctionSpec *fs_iter;
+        for (ps_iter = proto_ps; ps_iter && ps_iter->name; ps_iter++)
+            ps_iter->flags |= JSPROP_RESOLVING;
+        for (fs_iter = proto_fs; fs_iter && fs_iter->name; fs_iter++)
+            fs_iter->flags |= JSPROP_RESOLVING;
+    }
+
     if (proto_ps && !JS_DefineProperties(context, prototype, proto_ps))
         goto out;
     if (proto_fs && !JS_DefineFunctions(context, prototype, proto_fs))
@@ -108,8 +118,20 @@ gjs_init_class_dynamic(JSContext              *context,
     if (static_fs && !JS_DefineFunctions(context, constructor, static_fs))
         goto out;
 
-    if (!JS_LinkConstructorAndPrototype(context, constructor, prototype))
-        goto out;
+    if (!clasp->resolve) {
+        if (!JS_LinkConstructorAndPrototype(context, constructor, prototype))
+            goto out;
+    } else {
+        /* Have to fake it with JSPROP_RESOLVING, otherwise it will trigger
+         * the resolve hook */
+        if (!JS_DefineProperty(context, constructor, "prototype", prototype,
+                               JSPROP_PERMANENT | JSPROP_READONLY | JSPROP_RESOLVING,
+                               JS_STUBGETTER, JS_STUBSETTER))
+            goto out;
+        if (!JS_DefineProperty(context, prototype, "constructor", constructor,
+                               JSPROP_RESOLVING, JS_STUBGETTER, JS_STUBSETTER))
+            goto out;
+    }
 
     /* The constructor defined by JS_InitClass has no property attributes, but this
        is a more useful default for gjs */
diff --git a/gi/repo.cpp b/gi/repo.cpp
index 4720df0d..a3146864 100644
--- a/gi/repo.cpp
+++ b/gi/repo.cpp
@@ -263,7 +263,7 @@ repo_new(JSContext *context)
 
     JS::RootedObject versions(context, JS_NewPlainObject(context));
     gjs_object_define_property(context, repo, GJS_STRING_GI_VERSIONS,
-                               versions, JSPROP_PERMANENT);
+                               versions, JSPROP_PERMANENT | JSPROP_RESOLVING);
 
     /* GLib/GObject/Gio are fixed at 2.0, since we depend on them
      * internally.
@@ -282,7 +282,7 @@ repo_new(JSContext *context)
     JS::RootedObject private_ns(context, JS_NewPlainObject(context));
     gjs_object_define_property(context, repo,
                                GJS_STRING_PRIVATE_NS_MARKER, private_ns,
-                               JSPROP_PERMANENT);
+                               JSPROP_PERMANENT | JSPROP_RESOLVING);
 
     return repo;
 }

From 27cfb2fcee920c9508d90d1af70f8debe27f33b3 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sat, 29 Apr 2017 18:25:44 -0700
Subject: [PATCH 052/154] modules/console: Update to js::PrintError from
 upstream

The existing code doesn't compile with SpiderMonkey 45, so we copy the
corresponding code from SpiderMonkey 45's js::PrintError() function.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 modules/console.cpp | 34 +++++++++++++++++++++-------------
 1 file changed, 21 insertions(+), 13 deletions(-)

diff --git a/modules/console.cpp b/modules/console.cpp
index 2e588de3..76bae67f 100644
--- a/modules/console.cpp
+++ b/modules/console.cpp
@@ -100,20 +100,28 @@ gjs_console_print_error(const char *message, JSErrorReport *report)
         fputs(prefix, stderr);
     fputs(message, stderr);
 
-    if (report->linebuf) {
-        /* report->linebuf usually ends with a newline. */
-        int n = strlen(report->linebuf);
-        fprintf(stderr, ":\n%s%s%s%s",
-                prefix,
-                report->linebuf,
-                (n > 0 && report->linebuf[n-1] == '\n') ? "" : "\n",
-                prefix);
-        n = report->tokenptr - report->linebuf;
-        for (int i = 0, j = 0; i < n; i++) {
-            if (report->linebuf[i] == '\t') {
-                for (int k = (j + 8) & ~7; j < k; j++) {
+    if (const char16_t* linebuf = report->linebuf()) {
+        size_t n = report->linebufLength();
+
+        fputs(":\n", stderr);
+        if (prefix)
+            fputs(prefix, stderr);
+
+        for (size_t i = 0; i < n; i++)
+            fputc(static_cast<char>(linebuf[i]), stderr);
+
+        // linebuf usually ends with a newline. If not, add one here.
+        if (n == 0 || linebuf[n - 1] != '\n')
+            fputc('\n', stderr);
+
+        if (prefix)
+            fputs(prefix, stderr);
+
+        n = report->tokenOffset();
+        for (size_t i = 0, j = 0; i < n; i++) {
+            if (linebuf[i] == '\t') {
+                for (size_t k = (j + 8) & ~7; j < k; j++)
                     fputc('.', stderr);
-                }
                 continue;
             }
             fputc('.', stderr);

From f1c691fe50297289a3f0eda5eebdb2aef80d9264 Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 22:17:11 -0500
Subject: [PATCH 053/154] js: Various API changes for SpiderMonkey 45

A few minor changes that were only in one place.

https://bugzilla.gnome.org/show_bug.cgi?id=784196

Based on https://github.com/GNOME/gjs/commit/ba491c258000c02c2b086b30381f0c71252bec8f
---
 cjs/global.cpp                  |  2 +-
 cjs/jsapi-constructor-proxy.cpp | 10 +++++-----
 modules/system.cpp              |  9 ++++++---
 3 files changed, 12 insertions(+), 9 deletions(-)

diff --git a/cjs/global.cpp b/cjs/global.cpp
index 248048fe..c977330a 100644
--- a/cjs/global.cpp
+++ b/cjs/global.cpp
@@ -251,7 +251,7 @@ class GjsGlobal {
         JSAutoCompartment ac(cx, global);
 
         if (!JS_InitStandardClasses(cx, global) ||
-            !JS_InitReflect(cx, global) ||
+            !JS_InitReflectParse(cx, global) ||
             !JS_DefineDebuggerObject(cx, global))
             return nullptr;
 
diff --git a/cjs/jsapi-constructor-proxy.cpp b/cjs/jsapi-constructor-proxy.cpp
index ea59bd3f..a7631e43 100644
--- a/cjs/jsapi-constructor-proxy.cpp
+++ b/cjs/jsapi-constructor-proxy.cpp
@@ -45,7 +45,7 @@
  * getPrototypeOf() trap, which may or may not be turned on in JS proxies,
  * I'm not sure.
  *
- * COMPAT: SpiderMonkey doesn't support the getPrototypeOf() trap in JS
+ * COMPAT: SpiderMonkey doesn't support the getPrototype() trap in JS
  * proxies yet. That has yet to be released, in the upcoming SpiderMonkey 52.
  * When that is available, then this whole file can be discontinued.
  *
@@ -87,9 +87,9 @@ class GjsConstructorHandler : public js::Wrapper {
     { }
 
     bool
-    getPrototypeOf(JSContext              *cx,
-                   JS::HandleObject        proxy,
-                   JS::MutableHandleObject proto_p)
+    getPrototype(JSContext              *cx,
+                 JS::HandleObject        proxy,
+                 JS::MutableHandleObject proto_p)
     const override
     {
         proto_p.set(proto(proxy));
@@ -155,7 +155,7 @@ create_gjs_constructor_proxy(JSContext *cx,
 
     JS::RootedObject proxy(cx,
         js::NewProxyObject(cx, &GjsConstructorHandler::singleton(), args[0],
-                           &args[1].toObject(), nullptr));
+                           &args[1].toObject()));
     /* We stick this extra object into one of the proxy object's "extra slots",
      * even though it is private data of the proxy handler. This is because
      * proxy handlers cannot have trace callbacks. The proxy object does have a
diff --git a/modules/system.cpp b/modules/system.cpp
index b09f5e9c..3406a39a 100644
--- a/modules/system.cpp
+++ b/modules/system.cpp
@@ -27,6 +27,9 @@
 #include <sys/types.h>
 #include <time.h>
 
+#include "cjs/jsapi-wrapper.h"
+#include <js/Date.h>
+
 #include <cjs/context.h>
 
 #include "gi/object.h"
@@ -109,11 +112,11 @@ gjs_dump_heap(JSContext *cx,
 
     if (filename) {
         FILE *fp = fopen(filename, "a");
-        js::DumpHeapComplete(JS_GetRuntime(cx), fp, js::IgnoreNurseryObjects);
+        js::DumpHeap(JS_GetRuntime(cx), fp, js::IgnoreNurseryObjects);
         fclose(fp);
         g_free(filename);
     } else {
-        js::DumpHeapComplete(JS_GetRuntime(cx), stdout, js::IgnoreNurseryObjects);
+        js::DumpHeap(JS_GetRuntime(cx), stdout, js::IgnoreNurseryObjects);
     }
 
     args.rval().setUndefined();
@@ -161,7 +164,7 @@ gjs_clear_date_caches(JSContext *context,
     // localtime_r, see https://bugzilla.mozilla.org/show_bug.cgi?id=1004706
     tzset();
 
-    JS_ClearDateCaches(context);
+    JS::ResetTimeZone();
     JS_EndRequest(context);
 
     rec.rval().setUndefined();

From f9bf8c5748acaad3573c5c3905a5ac5de79e88e8 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Wed, 22 Mar 2017 15:37:09 +0000
Subject: [PATCH 054/154] coverage: Misc Javascript-side API changes

Debugger.Script.getOffsetLine() which we previously used in code coverage
is gone now, replaced by Debugger.Script.getOffsetLocation() which gives
more information. We don't currently take advantage of the extra
information.

ArrowExpression was renamed to ArrowFunctionExpression.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 modules/coverage.js | 20 +++++++++-----------
 1 file changed, 9 insertions(+), 11 deletions(-)

diff --git a/modules/coverage.js b/modules/coverage.js
index d01b3787..0ed3407c 100644
--- a/modules/coverage.js
+++ b/modules/coverage.js
@@ -92,7 +92,7 @@ function getSubNodesForNode(node) {
                 subNodes.push(elem);
         });
         break;
-    case 'ArrowExpression':
+    case 'ArrowFunctionExpression':
         Array.prototype.push.apply(subNodes, node.defaults);
         subNodes.push(node.body);
         break;
@@ -219,7 +219,7 @@ function functionsForNode(node) {
     switch (node.type) {
     case 'FunctionDeclaration':
     case 'FunctionExpression':
-    case 'ArrowExpression':
+    case 'ArrowFunctionExpression':
         functionNames.push({ key: _getFunctionKeyFromReflectedFunction(node),
                              line: node.loc.start.line,
                              n_params: node.params.length });
@@ -921,19 +921,17 @@ function CoverageStatistics(prefixes, cache, shouldWarn) {
         /* Log function calls */
         if (frame.callee !== null && frame.callee.callable) {
             let name = frame.callee.name ? frame.callee.name : "(anonymous)";
-            let line = frame.script.getOffsetLine(frame.offset);
+            let {lineNumber} = frame.script.getOffsetLocation(frame.offset);
             let nArgs = frame.callee.parameterNames.length;
 
             try {
                 _incrementFunctionCounters(statistics.functionCounters,
                                            statistics.linesWithKnownFunctions,
-                                           name,
-                                           line,
-                                           nArgs);
+                                           name, lineNumber, nArgs);
             } catch (e) {
                 /* Something bad happened. Log the exception and delete
                  * statistics for this file */
-                _logExceptionAndReset(e, name, line);
+                _logExceptionAndReset(e, name, lineNumber);
                 return undefined;
             }
         }
@@ -945,17 +943,17 @@ function CoverageStatistics(prefixes, cache, shouldWarn) {
         frame.onStep = function() {
             /* Line counts */
             let offset = this.offset;
-            let offsetLine = this.script.getOffsetLine(offset);
+            let {lineNumber} = this.script.getOffsetLocation(offset);
 
             try {
                 _incrementExpressionCounters(statistics.expressionCounters,
                                              frame.script.url,
-                                             offsetLine, shouldWarn);
-                this._branchTracker.incrementBranchCounters(offsetLine);
+                                             lineNumber, shouldWarn);
+                this._branchTracker.incrementBranchCounters(lineNumber);
             } catch (e) {
                 /* Something bad happened. Log the exception and delete
                  * statistics for this file */
-                _logExceptionAndReset(e, frame.callee, offsetLine);
+                _logExceptionAndReset(e, frame.callee, lineNumber);
             }
         };
 

From 51c1fc2f23f58f9cd53b735e2a279bb5d31e6f18 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 19 Mar 2017 05:18:36 +0000
Subject: [PATCH 055/154] importer: Seal import with JSPropertyDescriptor
 directly

Previously we "sealed" the import by redefining the property on the
importer object so that it was undeleteable. Now we can do this in a more
direct way by getting and modifying the property's descriptor.

In order to make this more convenient and faster we thread the jsid
through the call stack so we don't have to convert it to and from a
string.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/importer.cpp | 9 ++-------
 1 file changed, 2 insertions(+), 7 deletions(-)

diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index cd338bd0..f8198b45 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -206,13 +206,8 @@ seal_import(JSContext       *cx,
         return false;
     }
 
-    /* COMPAT: in mozjs45 use .setConfigurable(false) and the form of
-     * JS_DefineProperty that takes the JSPropertyDescriptor directly */
-
-    if (!JS_DefinePropertyById(cx, descr.object(), id, descr.value(),
-                               descr.attributes() | JSPROP_PERMANENT,
-                               JS_PROPERTYOP_GETTER(descr.getter()),
-                               JS_PROPERTYOP_SETTER(descr.setter()))) {
+    descr.setConfigurable(false);
+    if (!JS_DefinePropertyById(cx, descr.object(), id, descr)) {
         gjs_debug(GJS_DEBUG_IMPORTER,
                   "Failed to redefine attributes to seal '%s' in importer",
                   name);

From 6acd62aac4f561fee6230a099b5b036e9ca0be42 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 16 Apr 2017 13:19:49 -0700
Subject: [PATCH 056/154] js: Update obsolete comments

These comments were previously correct, but have become incorrect in
SpiderMonkey 45.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/byteArray.cpp           | 2 +-
 cjs/coverage.cpp            | 5 -----
 cjs/global.cpp              | 2 +-
 cjs/importer.cpp            | 2 +-
 cjs/jsapi-class.h           | 2 +-
 cjs/jsapi-dynamic-class.cpp | 7 ++-----
 gi/boxed.cpp                | 2 +-
 gi/function.cpp             | 2 +-
 gi/fundamental.cpp          | 2 +-
 gi/gerror.cpp               | 2 +-
 gi/interface.cpp            | 2 +-
 gi/ns.cpp                   | 2 +-
 gi/object.cpp               | 2 +-
 gi/param.cpp                | 2 +-
 gi/repo.cpp                 | 2 +-
 gi/union.cpp                | 2 +-
 test/gjs-test-rooting.cpp   | 2 +-
 17 files changed, 17 insertions(+), 25 deletions(-)

diff --git a/cjs/byteArray.cpp b/cjs/byteArray.cpp
index a14f65d5..1fbd7879 100644
--- a/cjs/byteArray.cpp
+++ b/cjs/byteArray.cpp
@@ -65,7 +65,7 @@ struct JSClass gjs_byte_array_class = {
     byte_array_set_prop,
     NULL,  /* enumerate */
     NULL,  /* resolve */
-    NULL,  /* convert */
+    nullptr,  /* mayResolve */
     byte_array_finalize
 };
 
diff --git a/cjs/coverage.cpp b/cjs/coverage.cpp
index ddda58ab..ad39498b 100644
--- a/cjs/coverage.cpp
+++ b/cjs/coverage.cpp
@@ -1653,11 +1653,6 @@ gjs_coverage_constructed(GObject *object)
         priv->cache = g_file_new_for_path(".internal-gjs-coverage-cache");
     }
 
-    /* We now enable Ion and BaselineJIT in coverage mode. See the comment
-     * in gjs/runtime.cpp:gjs_clear_thread_runtime for some important
-     * information regarding runtime lifecycle management and garbage collection
-     * bugs in js24 */
-
     if (!bootstrap_coverage(coverage)) {
         JSContext *context = static_cast<JSContext *>(gjs_context_get_native_context(priv->context));
         JSAutoCompartment compartment(context, gjs_get_import_global(context));
diff --git a/cjs/global.cpp b/cjs/global.cpp
index c977330a..7993b7ef 100644
--- a/cjs/global.cpp
+++ b/cjs/global.cpp
@@ -181,7 +181,7 @@ class GjsGlobal {
         nullptr,  /* setProperty */
         nullptr,  /* enumerate */
         nullptr,  /* resolve */
-        nullptr,  /* convert */
+        nullptr,  /* mayResolve */
         nullptr,  /* finalize */
         nullptr,  /* call */
         nullptr,  /* hasInstance */
diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index f8198b45..5d620132 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -839,7 +839,7 @@ const js::Class gjs_importer_real_class = {
     NULL,  /* setProperty */
     NULL,  /* enumerate (see below) */
     importer_resolve,
-    NULL,  /* convert */
+    nullptr,  /* mayResolve */
     importer_finalize,
     NULL,  /* call */
     NULL,  /* hasInstance */
diff --git a/cjs/jsapi-class.h b/cjs/jsapi-class.h
index 0d487e77..8b773ed1 100644
--- a/cjs/jsapi-class.h
+++ b/cjs/jsapi-class.h
@@ -180,7 +180,7 @@ static struct JSClass gjs_##cname##_class = {                                \
     nullptr,  /* setProperty */                                              \
     nullptr,  /* enumerate */                                                \
     nullptr,  /* resolve */                                                  \
-    nullptr,  /* convert */                                                  \
+    nullptr,  /* mayResolve */                                               \
     gjs_##cname##_finalize                                                   \
 };                                                                           \
 _GJS_DEFINE_GET_PROTO(cname)                                                 \
diff --git a/cjs/jsapi-dynamic-class.cpp b/cjs/jsapi-dynamic-class.cpp
index 36e830df..d0e947ba 100644
--- a/cjs/jsapi-dynamic-class.cpp
+++ b/cjs/jsapi-dynamic-class.cpp
@@ -79,11 +79,8 @@ gjs_init_class_dynamic(JSContext              *context,
     if (parent_proto) {
         prototype.set(JS_NewObjectWithGivenProto(context, clasp, parent_proto));
     } else {
-        /* JS_NewObject will try to search for clasp prototype in the
-         * global object, which is wrong, but it's not a problem because
-         * it will fallback to Object.prototype if the clasp's
-         * constructor is not found (and it won't be found, because we
-         * never call JS_InitClass).
+        /* JS_NewObject will use Object.prototype as the prototype if the
+         * clasp's constructor is not a built-in class.
          */
         prototype.set(JS_NewObject(context, clasp));
     }
diff --git a/gi/boxed.cpp b/gi/boxed.cpp
index db862f76..43ff615b 100644
--- a/gi/boxed.cpp
+++ b/gi/boxed.cpp
@@ -929,7 +929,7 @@ struct JSClass gjs_boxed_class = {
     NULL,  /* setProperty */
     NULL,  /* enumerate */
     boxed_resolve,
-    NULL,  /* convert */
+    nullptr,  /* mayResolve */
     boxed_finalize,
     NULL,  /* call */
     NULL,  /* hasInstance */
diff --git a/gi/function.cpp b/gi/function.cpp
index a89a1a73..8b16b35b 100644
--- a/gi/function.cpp
+++ b/gi/function.cpp
@@ -1493,7 +1493,7 @@ struct JSClass gjs_function_class = {
     NULL,  /* setProperty */
     NULL,  /* enumerate */
     NULL,  /* resolve */
-    NULL,  /* convert */
+    nullptr,  /* mayResolve */
     function_finalize,
     function_call
 };
diff --git a/gi/fundamental.cpp b/gi/fundamental.cpp
index ce0a2e38..b3f7c0c7 100644
--- a/gi/fundamental.cpp
+++ b/gi/fundamental.cpp
@@ -558,7 +558,7 @@ struct JSClass gjs_fundamental_instance_class = {
     NULL,  /* setProperty */
     NULL,  /* enumerate */
     fundamental_instance_resolve,
-    NULL,  /* convert */
+    nullptr,  /* mayResolve */
     fundamental_finalize,
     NULL,  /* call */
     NULL,  /* hasInstance */
diff --git a/gi/gerror.cpp b/gi/gerror.cpp
index de6267fa..76fdf4f2 100644
--- a/gi/gerror.cpp
+++ b/gi/gerror.cpp
@@ -277,7 +277,7 @@ struct JSClass gjs_error_class = {
     NULL,  /* setProperty */
     NULL,  /* enumerate */
     NULL,  /* resolve */
-    NULL,  /* convert */
+    nullptr,  /* mayResolve */
     error_finalize
 };
 
diff --git a/gi/interface.cpp b/gi/interface.cpp
index c81e4420..372cd427 100644
--- a/gi/interface.cpp
+++ b/gi/interface.cpp
@@ -167,7 +167,7 @@ struct JSClass gjs_interface_class = {
     NULL,  /* setProperty */
     NULL,  /* enumerate */
     interface_resolve,
-    NULL,  /* convert */
+    nullptr,  /* mayResolve */
     interface_finalize
 };
 
diff --git a/gi/ns.cpp b/gi/ns.cpp
index 08654bd5..5b8f7c26 100644
--- a/gi/ns.cpp
+++ b/gi/ns.cpp
@@ -160,7 +160,7 @@ struct JSClass gjs_ns_class = {
     NULL,  /* setProperty */
     NULL,  /* enumerate */
     ns_resolve,
-    NULL,  /* convert */
+    nullptr,  /* mayResolve */
     ns_finalize
 };
 
diff --git a/gi/object.cpp b/gi/object.cpp
index e32e23e7..e758f317 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -1772,7 +1772,7 @@ struct JSClass gjs_object_instance_class = {
     object_instance_set_prop,
     NULL,  /* enumerate */
     object_instance_resolve,
-    NULL,  /* convert */
+    nullptr,  /* mayResolve */
     object_instance_finalize,
     NULL,
     NULL,
diff --git a/gi/param.cpp b/gi/param.cpp
index 3c767745..ea9d2546 100644
--- a/gi/param.cpp
+++ b/gi/param.cpp
@@ -152,7 +152,7 @@ struct JSClass gjs_param_class = {
     NULL,  /* setProperty */
     NULL,  /* enumerate */
     param_resolve,
-    NULL,  /* convert */
+    nullptr,  /* mayResolve */
     param_finalize
 };
 
diff --git a/gi/repo.cpp b/gi/repo.cpp
index a3146864..563bf571 100644
--- a/gi/repo.cpp
+++ b/gi/repo.cpp
@@ -225,7 +225,7 @@ struct JSClass gjs_repo_class = {
     NULL,  /* setProperty */
     NULL,  /* enumerate */
     repo_resolve,
-    NULL,  /* convert */
+    nullptr,  /* mayResolve */
     repo_finalize
 };
 
diff --git a/gi/union.cpp b/gi/union.cpp
index ececf402..06c67678 100644
--- a/gi/union.cpp
+++ b/gi/union.cpp
@@ -296,7 +296,7 @@ struct JSClass gjs_union_class = {
     NULL,  /* setProperty */
     NULL,  /* enumerate */
     union_resolve,
-    NULL,  /* convert */
+    nullptr,  /* mayResolve */
     union_finalize
 };
 
diff --git a/test/gjs-test-rooting.cpp b/test/gjs-test-rooting.cpp
index 6c377ee7..39a88a6d 100644
--- a/test/gjs-test-rooting.cpp
+++ b/test/gjs-test-rooting.cpp
@@ -35,7 +35,7 @@ static JSClass test_obj_class = {
     NULL,  /* setProperty */
     NULL,  /* enumerate */
     NULL,  /* resolve */
-    NULL,  /* convert */
+    nullptr,  /* mayResolve */
     test_obj_finalize
 };
 

From 1cc5d3ca31c473c78fc404a08a3779f06c6ec755 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Mon, 1 May 2017 22:30:16 -0700
Subject: [PATCH 057/154] js: Adapt to new JS::TraceEdge<T> API

Replacing the old JS_CallFooTracer() API is a new C++ JS::TraceEdge<T>()
function. It works the same, but is templated. The old API will be going
away in SpiderMonkey 52.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/context.cpp       |  2 +-
 cjs/coverage.cpp      |  3 ++-
 cjs/jsapi-util-root.h | 24 ++----------------------
 gi/boxed.cpp          |  8 ++++----
 gi/fundamental.cpp    |  4 ++--
 5 files changed, 11 insertions(+), 30 deletions(-)

diff --git a/cjs/context.cpp b/cjs/context.cpp
index c5ec083a..c7c52c9c 100644
--- a/cjs/context.cpp
+++ b/cjs/context.cpp
@@ -192,7 +192,7 @@ static void
 gjs_context_tracer(JSTracer *trc, void *data)
 {
     GjsContext *gjs_context = reinterpret_cast<GjsContext *>(data);
-    JS_CallObjectTracer(trc, &gjs_context->global, "GJS global object");
+    JS::TraceEdge<JSObject *>(trc, &gjs_context->global, "GJS global object");
 }
 
 static void
diff --git a/cjs/coverage.cpp b/cjs/coverage.cpp
index ad39498b..663d77a9 100644
--- a/cjs/coverage.cpp
+++ b/cjs/coverage.cpp
@@ -1488,7 +1488,8 @@ coverage_statistics_tracer(JSTracer *trc, void *data)
     GjsCoverage *coverage = (GjsCoverage *) data;
     GjsCoveragePrivate *priv = (GjsCoveragePrivate *) gjs_coverage_get_instance_private(coverage);
 
-    JS_CallObjectTracer(trc, &priv->coverage_statistics, "coverage_statistics");
+    JS::TraceEdge<JSObject *>(trc, &priv->coverage_statistics,
+                              "coverage_statistics");
 }
 
 /* This function is mainly used in the tests in order to fiddle with
diff --git a/cjs/jsapi-util-root.h b/cjs/jsapi-util-root.h
index 52ce634e..f4caaba2 100644
--- a/cjs/jsapi-util-root.h
+++ b/cjs/jsapi-util-root.h
@@ -66,23 +66,11 @@
  */
 template<typename T>
 struct GjsHeapOperation {
-    static void trace(JSTracer    *tracer,
-                      JS::Heap<T> *thing,
-                      const char  *name);
-
     static bool update_after_gc(JS::Heap<T> *location);
 };
 
 template<>
 struct GjsHeapOperation<JSObject *> {
-    static void
-    trace(JSTracer             *tracer,
-          JS::Heap<JSObject *> *thing,
-          const char           *name)
-    {
-        JS_CallObjectTracer(tracer, thing, name);
-    }
-
     static bool
     update_after_gc(JS::Heap<JSObject *> *location)
     {
@@ -92,15 +80,7 @@ struct GjsHeapOperation<JSObject *> {
 };
 
 template<>
-struct GjsHeapOperation<JS::Value> {
-    static void
-    trace(JSTracer            *tracer,
-          JS::Heap<JS::Value> *thing,
-          const char          *name)
-    {
-        JS_CallValueTracer(tracer, thing, name);
-    }
-};
+struct GjsHeapOperation<JS::Value> {};
 
 /* GjsMaybeOwned is intended only for use in heap allocation. Do not allocate it
  * on the stack, and do not allocate any instances of structures that have it as
@@ -316,7 +296,7 @@ class GjsMaybeOwned {
     {
         debug("trace()");
         g_assert(!m_rooted);
-        GjsHeapOperation<T>::trace(tracer, &m_heap, name);
+        JS::TraceEdge<T>(tracer, &m_heap, name);
     }
 
     /* If not tracing, then you must call this method during GC in order to
diff --git a/gi/boxed.cpp b/gi/boxed.cpp
index 43ff615b..7854891d 100644
--- a/gi/boxed.cpp
+++ b/gi/boxed.cpp
@@ -904,10 +904,10 @@ boxed_trace(JSTracer *tracer,
     if (priv == NULL)
         return;
 
-    JS_CallIdTracer(tracer, &priv->zero_args_constructor_name,
-                    "Boxed::zero_args_constructor_name");
-    JS_CallIdTracer(tracer, &priv->default_constructor_name,
-                    "Boxed::default_constructor_name");
+    JS::TraceEdge<jsid>(tracer, &priv->zero_args_constructor_name,
+                        "Boxed::zero_args_constructor_name");
+    JS::TraceEdge<jsid>(tracer, &priv->default_constructor_name,
+                        "Boxed::default_constructor_name");
 }
 
 /* The bizarre thing about this vtable is that it applies to both
diff --git a/gi/fundamental.cpp b/gi/fundamental.cpp
index b3f7c0c7..617f945f 100644
--- a/gi/fundamental.cpp
+++ b/gi/fundamental.cpp
@@ -531,8 +531,8 @@ fundamental_trace(JSTracer *tracer,
     if (priv == nullptr || !fundamental_is_prototype(priv))
         return;  /* Only prototypes need tracing */
 
-    JS_CallIdTracer(tracer, &priv->constructor_name,
-                    "Fundamental::constructor_name");
+    JS::TraceEdge<jsid>(tracer, &priv->constructor_name,
+                        "Fundamental::constructor_name");
 }
 
 /* The bizarre thing about this vtable is that it applies to both

From 43e69ef40a6d4a2a70b5b5d5bc6fcd1274586aac Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Mon, 1 May 2017 22:21:55 -0700
Subject: [PATCH 058/154] build: Build with mozjs52

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 configure.ac | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index 7c2723ff..158fcd8a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -62,7 +62,7 @@ GOBJECT_INTROSPECTION_REQUIRE([1.41.4])
 
 GOBJECT_REQUIREMENT="gobject-2.0 >= glib_required_version"
 gjs_base_packages="$GOBJECT_REQUIREMENT gio-2.0"
-common_packages="gthread-2.0 gio-2.0 >= glib_required_version mozjs-45"
+common_packages="gthread-2.0 gio-2.0 >= glib_required_version mozjs-52"
 gjs_packages="gobject-introspection-1.0 libffi $common_packages"
 gjs_cairo_packages="cairo cairo-gobject $common_packages"
 gjs_gtk_packages="gtk+-3.0 >= 3.14.0"

From c870d2bf05b1704206170954096fb4c997465fd0 Mon Sep 17 00:00:00 2001
From: Chun-wei Fan <fanchunwei@src.gnome.org>
Date: Wed, 14 Jun 2017 10:34:50 +0800
Subject: [PATCH 059/154] Windows: Build against SpiderMonkey 52

This is done so that people can also test Windows builds for gjs that is
based on SpiderMonkey 52.

As the upstream libffi is not very well maintained for Windows/MSVC, we
are also switching to use the Centricular fork for libffi[1], which will
also be the case for the upcoming stable releases for GLib (i.e. GObject)
and GObject-Introspection.

[1]: https://github.com/centricular/libffi

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 win32/README.txt      | 2 +-
 win32/config-msvc.mak | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/win32/README.txt b/win32/README.txt
index 4aa9dbbc..759a1e18 100644
--- a/win32/README.txt
+++ b/win32/README.txt
@@ -6,7 +6,7 @@ via NMake Makefiles.  Due to C++-11 usage, Visual Studio 2012 or
 earlier is not supported.
 
 You will need the following items to build GJS using Visual Studio:
--SpiderMonkey 38 (mozjs-38)
+-SpiderMonkey 52 (mozjs-52)
 -GObject-Introspection (G-I) 1.41.4 or later
 -GLib 2.50.x or later, (which includes GIO, GObject, and the associated tools)
 -Cairo including Cairo-GObject support, unless NO_CAIRO=1 is specified.
diff --git a/win32/config-msvc.mak b/win32/config-msvc.mak
index 8af31113..74b661c3 100644
--- a/win32/config-msvc.mak
+++ b/win32/config-msvc.mak
@@ -1,7 +1,7 @@
 # NMake Makefile portion for enabling features for Windows builds
 
 # Spidermonkey release series (17, 24, 31, 38, 45 etc.)
-MOZJS_VERSION = 38
+MOZJS_VERSION = 52
 
 # Please see https://bugzilla.gnome.org/show_bug.cgi?id=775868,
 # comments 26, 27 and 28

From d691f485838202c9110acd50adc93f6683b900b9 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Mon, 1 May 2017 22:44:34 -0700
Subject: [PATCH 060/154] js: New JSClass struct layout

Instead of the various operation hooks being members of JSClass directly,
now JSClass contains a pointer to a JSClassOps struct. The JSClassOps
instead contains the function pointers to the operation hooks.

For importer.cpp, we still use the internal js::Class instead of JSClass.
This also contains a pointer to another struct, JSObjectOps, which we still
need for our internal lazy enumerate hook.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/byteArray.cpp           | 11 ++++++----
 cjs/global.cpp              | 11 +++++++---
 cjs/importer.cpp            | 49 +++++++++++++++++++++++----------------------
 cjs/jsapi-class.h           |  9 ++++++---
 cjs/jsapi-dynamic-class.cpp |  4 ++--
 cjs/module.cpp              | 11 +++++++---
 gi/boxed.cpp                | 21 ++++++++++---------
 gi/function.cpp             | 11 ++++++----
 gi/fundamental.cpp          | 15 +++++++-------
 gi/gerror.cpp               | 11 ++++++----
 gi/interface.cpp            | 11 ++++++----
 gi/ns.cpp                   | 10 ++++++---
 gi/object.cpp               | 11 ++++++----
 gi/param.cpp                | 11 ++++++----
 gi/repo.cpp                 | 10 ++++++---
 gi/union.cpp                | 10 ++++++---
 test/gjs-test-rooting.cpp   | 10 ++++++---
 17 files changed, 138 insertions(+), 88 deletions(-)

diff --git a/cjs/byteArray.cpp b/cjs/byteArray.cpp
index 1fbd7879..88b38e27 100644
--- a/cjs/byteArray.cpp
+++ b/cjs/byteArray.cpp
@@ -55,10 +55,7 @@ static void   byte_array_finalize      (JSFreeOp     *fop,
 
 static JSObject *gjs_byte_array_get_proto(JSContext *);
 
-struct JSClass gjs_byte_array_class = {
-    "ByteArray",
-    JSCLASS_HAS_PRIVATE |
-    JSCLASS_BACKGROUND_FINALIZE,
+static const struct JSClassOps gjs_byte_array_class_ops = {
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     byte_array_get_prop,
@@ -69,6 +66,12 @@ struct JSClass gjs_byte_array_class = {
     byte_array_finalize
 };
 
+struct JSClass gjs_byte_array_class = {
+    "ByteArray",
+    JSCLASS_HAS_PRIVATE | JSCLASS_BACKGROUND_FINALIZE,
+    &gjs_byte_array_class_ops
+};
+
 bool
 gjs_typecheck_bytearray(JSContext       *context,
                         JS::HandleObject object,
diff --git a/cjs/global.cpp b/cjs/global.cpp
index 7993b7ef..f0503b24 100644
--- a/cjs/global.cpp
+++ b/cjs/global.cpp
@@ -172,9 +172,7 @@ gjs_printerr(JSContext *context,
 }
 
 class GjsGlobal {
-    static constexpr JSClass klass = {
-        "GjsGlobal",
-        JSCLASS_GLOBAL_FLAGS_WITH_SLOTS(GJS_GLOBAL_SLOT_LAST),
+    static constexpr JSClassOps class_ops = {
         nullptr,  /* addProperty */
         nullptr,  /* deleteProperty */
         nullptr,  /* getProperty */
@@ -189,6 +187,12 @@ class GjsGlobal {
         JS_GlobalObjectTraceHook
     };
 
+    static constexpr JSClass klass = {
+        "GjsGlobal",
+        JSCLASS_GLOBAL_FLAGS_WITH_SLOTS(GJS_GLOBAL_SLOT_LAST),
+        &GjsGlobal::class_ops,
+    };
+
     static constexpr JSFunctionSpec static_funcs[] = {
         JS_FS("log", gjs_log, 1, GJS_MODULE_PROP_FLAGS),
         JS_FS("logError", gjs_log_error, 2, GJS_MODULE_PROP_FLAGS),
@@ -347,5 +351,6 @@ gjs_get_global_slot(JSContext    *cx,
     return JS_GetReservedSlot(global, JSCLASS_GLOBAL_SLOT_COUNT + slot);
 }
 
+decltype(GjsGlobal::class_ops) constexpr GjsGlobal::class_ops;
 decltype(GjsGlobal::klass) constexpr GjsGlobal::klass;
 decltype(GjsGlobal::static_funcs) constexpr GjsGlobal::static_funcs;
diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index 5d620132..b0bcb2ba 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -830,9 +830,7 @@ importer_finalize(js::FreeOp *fop,
  * instances of the object, and to the prototype that instances of the
  * class have.
  */
-const js::Class gjs_importer_real_class = {
-    "GjsFileImporter",
-    JSCLASS_HAS_PRIVATE,
+static const js::ClassOps gjs_importer_class_ops = {
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
@@ -840,27 +838,30 @@ const js::Class gjs_importer_real_class = {
     NULL,  /* enumerate (see below) */
     importer_resolve,
     nullptr,  /* mayResolve */
-    importer_finalize,
-    NULL,  /* call */
-    NULL,  /* hasInstance */
-    NULL,  /* construct */
-    NULL,  /* trace */
-    JS_NULL_CLASS_SPEC,
-    JS_NULL_CLASS_EXT,
-    {
-        NULL,  /* lookupProperty */
-        NULL,  /* defineProperty */
-        NULL,  /* hasProperty */
-        NULL,  /* getProperty */
-        NULL,  /* setProperty */
-        NULL,  /* getOwnPropertyDescriptor */
-        NULL,  /* deleteProperty */
-        NULL,  /* watch */
-        NULL,  /* unwatch */
-        NULL,  /* getElements */
-        importer_enumerate,
-        NULL,  /* thisObject */
-    }
+    importer_finalize
+};
+
+static const js::ObjectOps gjs_importer_object_ops = {
+    NULL,  /* lookupProperty */
+    NULL,  /* defineProperty */
+    NULL,  /* hasProperty */
+    NULL,  /* getProperty */
+    NULL,  /* setProperty */
+    NULL,  /* getOwnPropertyDescriptor */
+    NULL,  /* deleteProperty */
+    NULL,  /* watch */
+    NULL,  /* unwatch */
+    NULL,  /* getElements */
+    importer_enumerate
+};
+
+const js::Class gjs_importer_real_class = {
+    "GjsFileImporter",
+    JSCLASS_HAS_PRIVATE,
+    &gjs_importer_class_ops,
+    nullptr,
+    nullptr,
+    &gjs_importer_object_ops
 };
 
 static JSPropertySpec *gjs_importer_proto_props = nullptr;
diff --git a/cjs/jsapi-class.h b/cjs/jsapi-class.h
index 8b773ed1..29c44bee 100644
--- a/cjs/jsapi-class.h
+++ b/cjs/jsapi-class.h
@@ -171,9 +171,7 @@ extern JSPropertySpec gjs_##cname##_proto_props[];                           \
 extern JSFunctionSpec gjs_##cname##_proto_funcs[];                           \
 extern JSFunctionSpec gjs_##cname##_static_funcs[];                          \
 static void gjs_##cname##_finalize(JSFreeOp *fop, JSObject *obj);            \
-static struct JSClass gjs_##cname##_class = {                                \
-    type_name,                                                               \
-    JSCLASS_HAS_PRIVATE | jsclass_flags,                                     \
+static const struct JSClassOps gjs_##cname##_class_ops = {                   \
     nullptr,  /* addProperty */                                              \
     nullptr,  /* deleteProperty */                                           \
     nullptr,  /* getProperty */                                              \
@@ -183,6 +181,11 @@ static struct JSClass gjs_##cname##_class = {                                \
     nullptr,  /* mayResolve */                                               \
     gjs_##cname##_finalize                                                   \
 };                                                                           \
+static struct JSClass gjs_##cname##_class = {                                \
+    type_name,                                                               \
+    JSCLASS_HAS_PRIVATE | jsclass_flags,                                     \
+    &gjs_##cname##_class_ops                                                 \
+};                                                                           \
 _GJS_DEFINE_GET_PROTO(cname)                                                 \
 _GJS_DEFINE_DEFINE_PROTO(cname, parent_cname, ctor, gtype)
 
diff --git a/cjs/jsapi-dynamic-class.cpp b/cjs/jsapi-dynamic-class.cpp
index d0e947ba..a660c192 100644
--- a/cjs/jsapi-dynamic-class.cpp
+++ b/cjs/jsapi-dynamic-class.cpp
@@ -88,7 +88,7 @@ gjs_init_class_dynamic(JSContext              *context,
         goto out;
 
     /* Bypass resolve hooks when defining the initial properties */
-    if (clasp->resolve) {
+    if (clasp->cOps->resolve) {
         JSPropertySpec *ps_iter;
         JSFunctionSpec *fs_iter;
         for (ps_iter = proto_ps; ps_iter && ps_iter->name; ps_iter++)
@@ -115,7 +115,7 @@ gjs_init_class_dynamic(JSContext              *context,
     if (static_fs && !JS_DefineFunctions(context, constructor, static_fs))
         goto out;
 
-    if (!clasp->resolve) {
+    if (!clasp->cOps->resolve) {
         if (!JS_LinkConstructorAndPrototype(context, constructor, prototype))
             goto out;
     } else {
diff --git a/cjs/module.cpp b/cjs/module.cpp
index e58206b7..5028d06f 100644
--- a/cjs/module.cpp
+++ b/cjs/module.cpp
@@ -145,9 +145,7 @@ class GjsModule {
         delete priv(module);
     }
 
-    static constexpr JSClass klass = {
-        "GjsModule",
-        JSCLASS_HAS_PRIVATE | JSCLASS_BACKGROUND_FINALIZE,
+    static constexpr JSClassOps class_ops = {
         nullptr,  /* addProperty */
         nullptr,  /* deleteProperty */
         nullptr,  /* getProperty */
@@ -158,6 +156,12 @@ class GjsModule {
         &GjsModule::finalize,
     };
 
+    static constexpr JSClass klass = {
+        "GjsModule",
+        JSCLASS_HAS_PRIVATE | JSCLASS_BACKGROUND_FINALIZE,
+        &GjsModule::class_ops,
+    };
+
 public:
 
     /* Carries out the import operation */
@@ -205,3 +209,4 @@ gjs_module_import(JSContext       *cx,
 }
 
 decltype(GjsModule::klass) constexpr GjsModule::klass;
+decltype(GjsModule::class_ops) constexpr GjsModule::class_ops;
diff --git a/gi/boxed.cpp b/gi/boxed.cpp
index 7854891d..1caaa4b7 100644
--- a/gi/boxed.cpp
+++ b/gi/boxed.cpp
@@ -913,16 +913,8 @@ boxed_trace(JSTracer *tracer,
 /* The bizarre thing about this vtable is that it applies to both
  * instances of the object, and to the prototype that instances of the
  * class have.
- *
- * We allocate 1 reserved slot; this is typically unused, but if the
- * boxed is for a nested structure inside a parent structure, the
- * reserved slot is used to hold onto the parent Javascript object and
- * make sure it doesn't get freed.
  */
-struct JSClass gjs_boxed_class = {
-    "GObject_Boxed",
-    JSCLASS_HAS_PRIVATE |
-    JSCLASS_HAS_RESERVED_SLOTS(1),
+static const struct JSClassOps gjs_boxed_class_ops = {
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
@@ -937,6 +929,17 @@ struct JSClass gjs_boxed_class = {
     boxed_trace
 };
 
+/* We allocate 1 reserved slot; this is typically unused, but if the
+ * boxed is for a nested structure inside a parent structure, the
+ * reserved slot is used to hold onto the parent Javascript object and
+ * make sure it doesn't get freed.
+ */
+struct JSClass gjs_boxed_class = {
+    "GObject_Boxed",
+    JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1),
+    &gjs_boxed_class_ops
+};
+
 JSPropertySpec gjs_boxed_proto_props[] = {
     JS_PS_END
 };
diff --git a/gi/function.cpp b/gi/function.cpp
index 8b16b35b..3d923133 100644
--- a/gi/function.cpp
+++ b/gi/function.cpp
@@ -1483,10 +1483,7 @@ function_to_string (JSContext *context,
  * instances of the object, and to the prototype that instances of the
  * class have.
  */
-struct JSClass gjs_function_class = {
-    "GIRepositoryFunction", /* means "new GIRepositoryFunction()" works */
-    JSCLASS_HAS_PRIVATE |
-    JSCLASS_BACKGROUND_FINALIZE,
+static const struct JSClassOps gjs_function_class_ops = {
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
@@ -1498,6 +1495,12 @@ struct JSClass gjs_function_class = {
     function_call
 };
 
+struct JSClass gjs_function_class = {
+    "GIRepositoryFunction", /* means "new GIRepositoryFunction()" works */
+    JSCLASS_HAS_PRIVATE | JSCLASS_BACKGROUND_FINALIZE,
+    &gjs_function_class_ops
+};
+
 static JSPropertySpec gjs_function_proto_props[] = {
     JS_PSG("length", get_num_arguments, JSPROP_PERMANENT),
     JS_PS_END
diff --git a/gi/fundamental.cpp b/gi/fundamental.cpp
index 617f945f..5402c02a 100644
--- a/gi/fundamental.cpp
+++ b/gi/fundamental.cpp
@@ -543,15 +543,8 @@ fundamental_trace(JSTracer *tracer,
  * tell, it would only be used if no constructor were provided to
  * JS_InitClass. The constructor from JS_InitClass is not applied to
  * the prototype unless JSCLASS_CONSTRUCT_PROTOTYPE is in flags.
- *
- * We allocate 1 reserved slot; this is typically unused, but if the
- * fundamental is for a nested structure inside a parent structure, the
- * reserved slot is used to hold onto the parent Javascript object and
- * make sure it doesn't get freed.
  */
-struct JSClass gjs_fundamental_instance_class = {
-    "GFundamental_Object",
-    JSCLASS_HAS_PRIVATE,
+static const struct JSClassOps gjs_fundamental_class_ops = {
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
@@ -566,6 +559,12 @@ struct JSClass gjs_fundamental_instance_class = {
     fundamental_trace
 };
 
+struct JSClass gjs_fundamental_instance_class = {
+    "GFundamental_Object",
+    JSCLASS_HAS_PRIVATE,
+    &gjs_fundamental_class_ops
+};
+
 static JSPropertySpec gjs_fundamental_instance_proto_props[] = {
     JS_PS_END
 };
diff --git a/gi/gerror.cpp b/gi/gerror.cpp
index 76fdf4f2..849b2c26 100644
--- a/gi/gerror.cpp
+++ b/gi/gerror.cpp
@@ -267,10 +267,7 @@ error_constructor_value_of(JSContext *context,
  * instances of the object, and to the prototype that instances of the
  * class have.
  */
-struct JSClass gjs_error_class = {
-    "GLib_Error",
-    JSCLASS_HAS_PRIVATE |
-    JSCLASS_BACKGROUND_FINALIZE,
+static const struct JSClassOps gjs_error_class_ops = {
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
@@ -281,6 +278,12 @@ struct JSClass gjs_error_class = {
     error_finalize
 };
 
+struct JSClass gjs_error_class = {
+    "GLib_Error",
+    JSCLASS_HAS_PRIVATE | JSCLASS_BACKGROUND_FINALIZE,
+    &gjs_error_class_ops
+};
+
 /* We need to shadow all fields of GError, to prevent calling the getter from GBoxed
    (which would trash memory accessing the instance private data) */
 JSPropertySpec gjs_error_proto_props[] = {
diff --git a/gi/interface.cpp b/gi/interface.cpp
index 372cd427..d7e36543 100644
--- a/gi/interface.cpp
+++ b/gi/interface.cpp
@@ -157,10 +157,7 @@ interface_resolve(JSContext       *context,
     return true;
 }
 
-struct JSClass gjs_interface_class = {
-    "GObject_Interface",
-    JSCLASS_HAS_PRIVATE |
-    JSCLASS_BACKGROUND_FINALIZE,
+static const struct JSClassOps gjs_interface_class_ops = {
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
@@ -171,6 +168,12 @@ struct JSClass gjs_interface_class = {
     interface_finalize
 };
 
+struct JSClass gjs_interface_class = {
+    "GObject_Interface",
+    JSCLASS_HAS_PRIVATE | JSCLASS_BACKGROUND_FINALIZE,
+    &gjs_interface_class_ops
+};
+
 JSPropertySpec gjs_interface_proto_props[] = {
     JS_PS_END
 };
diff --git a/gi/ns.cpp b/gi/ns.cpp
index 5b8f7c26..8080ba97 100644
--- a/gi/ns.cpp
+++ b/gi/ns.cpp
@@ -151,9 +151,7 @@ ns_finalize(JSFreeOp *fop,
  * instances of the object, and to the prototype that instances of the
  * class have.
  */
-struct JSClass gjs_ns_class = {
-    "GIRepositoryNamespace",
-    JSCLASS_HAS_PRIVATE,
+static const struct JSClassOps gjs_ns_class_ops = {
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
@@ -164,6 +162,12 @@ struct JSClass gjs_ns_class = {
     ns_finalize
 };
 
+struct JSClass gjs_ns_class = {
+    "GIRepositoryNamespace",
+    JSCLASS_HAS_PRIVATE,
+    &gjs_ns_class_ops
+};
+
 static JSPropertySpec gjs_ns_proto_props[] = {
     JS_PSG("__name__", get_name, GJS_MODULE_PROP_FLAGS),
     JS_PS_END
diff --git a/gi/object.cpp b/gi/object.cpp
index e758f317..71f80c6b 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -1763,9 +1763,7 @@ to_string_func(JSContext *context,
                                      priv->gobj, rec.rval());
 }
 
-struct JSClass gjs_object_instance_class = {
-    "GObject_Object",
-    JSCLASS_HAS_PRIVATE,
+static const struct JSClassOps gjs_object_class_ops = {
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     object_instance_get_prop,
@@ -1778,7 +1776,12 @@ struct JSClass gjs_object_instance_class = {
     NULL,
     NULL,
     object_instance_trace,
-    
+};
+
+struct JSClass gjs_object_instance_class = {
+    "GObject_Object",
+    JSCLASS_HAS_PRIVATE,
+    &gjs_object_class_ops
 };
 
 static bool
diff --git a/gi/param.cpp b/gi/param.cpp
index ea9d2546..c8ff6f2e 100644
--- a/gi/param.cpp
+++ b/gi/param.cpp
@@ -142,10 +142,7 @@ param_finalize(JSFreeOp *fop,
  * instances of the object, and to the prototype that instances of the
  * class have.
  */
-struct JSClass gjs_param_class = {
-    "GObject_ParamSpec",
-    JSCLASS_HAS_PRIVATE |
-    JSCLASS_BACKGROUND_FINALIZE,
+static const struct JSClassOps gjs_param_class_ops = {
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
@@ -156,6 +153,12 @@ struct JSClass gjs_param_class = {
     param_finalize
 };
 
+struct JSClass gjs_param_class = {
+    "GObject_ParamSpec",
+    JSCLASS_HAS_PRIVATE | JSCLASS_BACKGROUND_FINALIZE,
+    &gjs_param_class_ops
+};
+
 JSPropertySpec gjs_param_proto_props[] = {
     JS_PS_END
 };
diff --git a/gi/repo.cpp b/gi/repo.cpp
index 563bf571..28e720af 100644
--- a/gi/repo.cpp
+++ b/gi/repo.cpp
@@ -216,9 +216,7 @@ repo_finalize(JSFreeOp *fop,
  * instances of the object, and to the prototype that instances of the
  * class have.
  */
-struct JSClass gjs_repo_class = {
-    "GIRepository", /* means "new GIRepository()" works */
-    JSCLASS_HAS_PRIVATE,
+static const struct JSClassOps gjs_repo_class_ops = {
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
@@ -229,6 +227,12 @@ struct JSClass gjs_repo_class = {
     repo_finalize
 };
 
+struct JSClass gjs_repo_class = {
+    "GIRepository", /* means "new GIRepository()" works */
+    JSCLASS_HAS_PRIVATE,
+    &gjs_repo_class_ops,
+};
+
 static JSPropertySpec *gjs_repo_proto_props = nullptr;
 static JSFunctionSpec *gjs_repo_proto_funcs = nullptr;
 static JSFunctionSpec *gjs_repo_static_funcs = nullptr;
diff --git a/gi/union.cpp b/gi/union.cpp
index 06c67678..da8fc338 100644
--- a/gi/union.cpp
+++ b/gi/union.cpp
@@ -287,9 +287,7 @@ to_string_func(JSContext *context,
  * instances of the object, and to the prototype that instances of the
  * class have.
  */
-struct JSClass gjs_union_class = {
-    "GObject_Union",
-    JSCLASS_HAS_PRIVATE,
+static const struct JSClassOps gjs_union_class_ops = {
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
@@ -300,6 +298,12 @@ struct JSClass gjs_union_class = {
     union_finalize
 };
 
+struct JSClass gjs_union_class = {
+    "GObject_Union",
+    JSCLASS_HAS_PRIVATE,
+    &gjs_union_class_ops
+};
+
 JSPropertySpec gjs_union_proto_props[] = {
     JS_PS_END
 };
diff --git a/test/gjs-test-rooting.cpp b/test/gjs-test-rooting.cpp
index 39a88a6d..20692875 100644
--- a/test/gjs-test-rooting.cpp
+++ b/test/gjs-test-rooting.cpp
@@ -26,9 +26,7 @@ test_obj_finalize(JSFreeOp *fop,
     *finalized_p = true;
 }
 
-static JSClass test_obj_class = {
-    "TestObj",
-    JSCLASS_HAS_PRIVATE,
+static const JSClassOps test_obj_class_ops = {
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
     NULL,  /* getProperty */
@@ -39,6 +37,12 @@ static JSClass test_obj_class = {
     test_obj_finalize
 };
 
+static JSClass test_obj_class = {
+    "TestObj",
+    JSCLASS_HAS_PRIVATE,
+    &test_obj_class_ops
+};
+
 static JSObject *
 test_obj_new(GjsRootingFixture *fx)
 {

From 2f6a23ff36059f5f70df2d5503101c7d3246b86b Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Mon, 1 May 2017 22:49:24 -0700
Subject: [PATCH 061/154] js: Add JSCLASS_FOREGROUND_FINALIZE flag

For all classes with a finalize hook, SpiderMonkey 52 requires that they
either have JSCLASS_FOREGROUND_FINALIZE or JSCLASS_BACKGROUND_FINALIZE set.
Previously, only the BACKGROUND flag existed and FOREGROUND was implicit.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/importer.cpp          | 2 +-
 gi/boxed.cpp              | 3 ++-
 gi/fundamental.cpp        | 2 +-
 gi/gtype.cpp              | 3 ++-
 gi/ns.cpp                 | 2 +-
 gi/object.cpp             | 2 +-
 gi/repo.cpp               | 2 +-
 gi/union.cpp              | 2 +-
 test/gjs-test-rooting.cpp | 2 +-
 9 files changed, 11 insertions(+), 9 deletions(-)

diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index b0bcb2ba..1ecf2379 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -857,7 +857,7 @@ static const js::ObjectOps gjs_importer_object_ops = {
 
 const js::Class gjs_importer_real_class = {
     "GjsFileImporter",
-    JSCLASS_HAS_PRIVATE,
+    JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
     &gjs_importer_class_ops,
     nullptr,
     nullptr,
diff --git a/gi/boxed.cpp b/gi/boxed.cpp
index 1caaa4b7..33f9e78d 100644
--- a/gi/boxed.cpp
+++ b/gi/boxed.cpp
@@ -936,7 +936,8 @@ static const struct JSClassOps gjs_boxed_class_ops = {
  */
 struct JSClass gjs_boxed_class = {
     "GObject_Boxed",
-    JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1),
+    JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE |
+        JSCLASS_HAS_RESERVED_SLOTS(1),
     &gjs_boxed_class_ops
 };
 
diff --git a/gi/fundamental.cpp b/gi/fundamental.cpp
index 5402c02a..6ddfae66 100644
--- a/gi/fundamental.cpp
+++ b/gi/fundamental.cpp
@@ -561,7 +561,7 @@ static const struct JSClassOps gjs_fundamental_class_ops = {
 
 struct JSClass gjs_fundamental_instance_class = {
     "GFundamental_Object",
-    JSCLASS_HAS_PRIVATE,
+    JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
     &gjs_fundamental_class_ops
 };
 
diff --git a/gi/gtype.cpp b/gi/gtype.cpp
index 3119ffd0..41b882a8 100644
--- a/gi/gtype.cpp
+++ b/gi/gtype.cpp
@@ -39,7 +39,8 @@ static JSObject *gjs_gtype_get_proto(JSContext *) G_GNUC_UNUSED;
 static bool gjs_gtype_define_proto(JSContext *, JS::HandleObject,
                                    JS::MutableHandleObject);
 
-GJS_DEFINE_PROTO_ABSTRACT("GIRepositoryGType", gtype, 0);
+GJS_DEFINE_PROTO_ABSTRACT("GIRepositoryGType", gtype,
+                          JSCLASS_FOREGROUND_FINALIZE);
 
 /* priv_from_js adds a "*", so this returns "void *" */
 GJS_DEFINE_PRIV_FROM_JS(void, gjs_gtype_class);
diff --git a/gi/ns.cpp b/gi/ns.cpp
index 8080ba97..b041f13b 100644
--- a/gi/ns.cpp
+++ b/gi/ns.cpp
@@ -164,7 +164,7 @@ static const struct JSClassOps gjs_ns_class_ops = {
 
 struct JSClass gjs_ns_class = {
     "GIRepositoryNamespace",
-    JSCLASS_HAS_PRIVATE,
+    JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
     &gjs_ns_class_ops
 };
 
diff --git a/gi/object.cpp b/gi/object.cpp
index 71f80c6b..880627a6 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -1780,7 +1780,7 @@ static const struct JSClassOps gjs_object_class_ops = {
 
 struct JSClass gjs_object_instance_class = {
     "GObject_Object",
-    JSCLASS_HAS_PRIVATE,
+    JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
     &gjs_object_class_ops
 };
 
diff --git a/gi/repo.cpp b/gi/repo.cpp
index 28e720af..5d5cb53d 100644
--- a/gi/repo.cpp
+++ b/gi/repo.cpp
@@ -229,7 +229,7 @@ static const struct JSClassOps gjs_repo_class_ops = {
 
 struct JSClass gjs_repo_class = {
     "GIRepository", /* means "new GIRepository()" works */
-    JSCLASS_HAS_PRIVATE,
+    JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
     &gjs_repo_class_ops,
 };
 
diff --git a/gi/union.cpp b/gi/union.cpp
index da8fc338..50214ff0 100644
--- a/gi/union.cpp
+++ b/gi/union.cpp
@@ -300,7 +300,7 @@ static const struct JSClassOps gjs_union_class_ops = {
 
 struct JSClass gjs_union_class = {
     "GObject_Union",
-    JSCLASS_HAS_PRIVATE,
+    JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
     &gjs_union_class_ops
 };
 
diff --git a/test/gjs-test-rooting.cpp b/test/gjs-test-rooting.cpp
index 20692875..1599b513 100644
--- a/test/gjs-test-rooting.cpp
+++ b/test/gjs-test-rooting.cpp
@@ -39,7 +39,7 @@ static const JSClassOps test_obj_class_ops = {
 
 static JSClass test_obj_class = {
     "TestObj",
-    JSCLASS_HAS_PRIVATE,
+    JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
     &test_obj_class_ops
 };
 

From 7279f7dd7fd801a72e81b2956d9278980cf9fb8b Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 2 May 2017 22:29:33 -0700
Subject: [PATCH 062/154] js: Adapt to options changes

JS::RuntimeOptions and JS::ContextOptions have merged into one
JS::ContextOptions class. JS::CompartmentOptions, on the other hand, has
split into "creation options" (can be set only at construct time) and
"behaviors" (can be changed at run time.)

The DontReportUncaught option is removed and is now activated
unconditionally.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/context.cpp  | 8 ++------
 cjs/coverage.cpp | 2 +-
 cjs/global.cpp   | 2 +-
 3 files changed, 4 insertions(+), 8 deletions(-)

diff --git a/cjs/context.cpp b/cjs/context.cpp
index c7c52c9c..36691c0b 100644
--- a/cjs/context.cpp
+++ b/cjs/context.cpp
@@ -308,21 +308,17 @@ gjs_context_constructed(GObject *object)
     /* setExtraWarnings: Be extra strict about code that might hide a bug */
     if (!g_getenv("GJS_DISABLE_EXTRA_WARNINGS")) {
         gjs_debug(GJS_DEBUG_CONTEXT, "Enabling extra warnings");
-        JS::RuntimeOptionsRef(js_context->context).setExtraWarnings(true);
+        JS::ContextOptionsRef(js_context->context).setExtraWarnings(true);
     }
 
     if (!g_getenv("GJS_DISABLE_JIT")) {
         gjs_debug(GJS_DEBUG_CONTEXT, "Enabling JIT");
-        JS::RuntimeOptionsRef(js_context->context)
+        JS::ContextOptionsRef(js_context->context)
             .setIon(true)
             .setBaseline(true)
             .setAsmJS(true);
     }
 
-    /* setDontReportUncaught: Don't send exceptions to our error report handler;
-     * instead leave them set. This allows us to get at the exception object. */
-    JS::ContextOptionsRef(js_context->context).setDontReportUncaught(true);
-
     JS::RootedObject global(js_context->context,
         gjs_create_global_object(js_context->context));
     if (!global) {
diff --git a/cjs/coverage.cpp b/cjs/coverage.cpp
index 663d77a9..6485d238 100644
--- a/cjs/coverage.cpp
+++ b/cjs/coverage.cpp
@@ -1553,7 +1553,7 @@ bootstrap_coverage(GjsCoverage *coverage)
 
     JSObject *debuggee = gjs_get_import_global(context);
     JS::CompartmentOptions options;
-    options.setVersion(JSVERSION_LATEST);
+    options.behaviors().setVersion(JSVERSION_LATEST);
     JS::RootedObject debugger_compartment(context,
                                           gjs_create_global_object(context));
     {
diff --git a/cjs/global.cpp b/cjs/global.cpp
index f0503b24..295df552 100644
--- a/cjs/global.cpp
+++ b/cjs/global.cpp
@@ -245,7 +245,7 @@ class GjsGlobal {
     create(JSContext *cx)
     {
         JS::CompartmentOptions compartment_options;
-        compartment_options.setVersion(JSVERSION_LATEST);
+        compartment_options.behaviors().setVersion(JSVERSION_LATEST);
         JS::RootedObject global(cx,
             JS_NewGlobalObject(cx, &GjsGlobal::klass, nullptr,
                                JS::FireOnNewGlobalHook, compartment_options));

From 384d377ca9e5cffcb8e92e4ab3ae8dc9d0f60774 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 2 May 2017 22:02:51 -0700
Subject: [PATCH 063/154] js: Report warnings and errors with encoding

JS_ReportWarning() and JS_ReportError() are changed in SpiderMonkey 52 to
specify their character encodings. Therefore, we use JS_ReportWarningUTF8()
and JS_ReportErrorUTF8(), except in a few cases where we use the ASCII
version because the argument is a string literal with only ASCII characters
and no format codes.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/jsapi-util-error.cpp | 8 +++-----
 gi/function.cpp          | 6 +++---
 gi/repo.cpp              | 2 +-
 3 files changed, 7 insertions(+), 9 deletions(-)

diff --git a/cjs/jsapi-util-error.cpp b/cjs/jsapi-util-error.cpp
index 56d3ec78..ce1bbd59 100644
--- a/cjs/jsapi-util-error.cpp
+++ b/cjs/jsapi-util-error.cpp
@@ -83,13 +83,13 @@ gjs_throw_valist(JSContext       *context,
     result = false;
 
     if (!gjs_string_from_utf8(context, s, -1, error_args[0])) {
-        JS_ReportError(context, "Failed to copy exception string");
+        JS_ReportErrorUTF8(context, "Failed to copy exception string");
         goto out;
     }
 
     if (!JS_GetProperty(context, global, error_class, &v_constructor) ||
         !v_constructor.isObject()) {
-        JS_ReportError(context, "??? Missing Error constructor in global object?");
+        JS_ReportErrorUTF8(context, "??? Missing Error constructor in global object?");
         goto out;
     }
 
@@ -119,9 +119,7 @@ gjs_throw_valist(JSContext       *context,
         /* try just reporting it to error handler? should not
          * happen though pretty much
          */
-        JS_ReportError(context,
-                       "Failed to throw exception '%s'",
-                       s);
+        JS_ReportErrorUTF8(context, "Failed to throw exception '%s'", s);
     }
     g_free(s);
 
diff --git a/gi/function.cpp b/gi/function.cpp
index 3d923133..0eaac9a0 100644
--- a/gi/function.cpp
+++ b/gi/function.cpp
@@ -769,9 +769,9 @@ gjs_invoke_c_function(JSContext                             *context,
      */
     if (args.length() > function->expected_js_argc) {
         GjsAutoChar name = format_function_name(function, is_method);
-        JS_ReportWarning(context, "Too many arguments to %s: expected %d, "
-                         "got %" G_GSIZE_FORMAT, name.get(),
-                         function->expected_js_argc, args.length());
+        JS_ReportWarningUTF8(context, "Too many arguments to %s: expected %d, "
+                             "got %" G_GSIZE_FORMAT, name.get(),
+                             function->expected_js_argc, args.length());
     } else if (args.length() < function->expected_js_argc) {
         GjsAutoChar name = format_function_name(function, is_method);
         gjs_throw(context, "Too few arguments to %s: "
diff --git a/gi/repo.cpp b/gi/repo.cpp
index 5d5cb53d..6af10462 100644
--- a/gi/repo.cpp
+++ b/gi/repo.cpp
@@ -105,7 +105,7 @@ resolve_namespace_object(JSContext       *context,
                                                 "versions available; use "
                                                 "imports.gi.versions to pick one",
                                                 ns_name, nversions);
-        JS_ReportWarning(context, warn_text);
+        JS_ReportWarningUTF8(context, "%s", warn_text.get());
     }
     g_list_free_full(versions, g_free);
 

From 618ff8f6164e080d74ee194dc7c11fab81758016 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Mon, 5 Jun 2017 23:10:24 -0700
Subject: [PATCH 064/154] tests: Refactor to avoid error reporter

Error reporter callbacks and JS_ReportPendingException() are going away
in SpiderMonkey 52. We used these to determine the message from a thrown
exception. Luckily, it's quite easy to do so without an error reporter
callback: simply create an error report from the exception object which
you can get from JS_GetPendingException().

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 test/gjs-test-call-args.cpp | 11 ++++------
 test/gjs-test-rooting.cpp   | 10 +--------
 test/gjs-test-utils.cpp     | 50 ++++++++++++++++++++++-----------------------
 test/gjs-test-utils.h       |  5 ++---
 4 files changed, 31 insertions(+), 45 deletions(-)

diff --git a/test/gjs-test-call-args.cpp b/test/gjs-test-call-args.cpp
index a92a48d2..30df44e4 100644
--- a/test/gjs-test-call-args.cpp
+++ b/test/gjs-test-call-args.cpp
@@ -274,9 +274,8 @@ run_code(GjsUnitTestFixture *fx,
 
     JS::RootedValue ignored(fx->cx);
     bool ok = JS::Evaluate(fx->cx, options, script, strlen(script), &ignored);
-    JS_ReportPendingException(fx->cx);
 
-    g_assert_null(fx->message);
+    g_assert_null(gjs_unit_test_exception_message(fx));
     g_assert_true(ok);
 }
 
@@ -292,17 +291,15 @@ run_code_expect_exception(GjsUnitTestFixture *fx,
     JS::RootedValue ignored(fx->cx);
     bool ok = JS::Evaluate(fx->cx, options, script, strlen(script), &ignored);
     g_assert_false(ok);
-    g_assert_true(JS_IsExceptionPending(fx->cx));
-    JS_ReportPendingException(fx->cx);
-    g_assert_nonnull(fx->message);
+    GjsAutoChar message = gjs_unit_test_exception_message(fx);
+    g_assert_nonnull(message);
 
     /* Cheap way to shove an expected exception message into the data argument */
     const char *expected_msg = strstr((const char *) code, "//");
     if (expected_msg != NULL) {
         expected_msg += 2;
-        assert_match(fx->message, expected_msg);
+        assert_match(message, expected_msg);
     }
-    g_clear_pointer(&fx->message, g_free);
 }
 
 void
diff --git a/test/gjs-test-rooting.cpp b/test/gjs-test-rooting.cpp
index 1599b513..b48d4797 100644
--- a/test/gjs-test-rooting.cpp
+++ b/test/gjs-test-rooting.cpp
@@ -229,13 +229,6 @@ context_destroyed(JS::HandleObject obj,
     fx->obj->reset();
 }
 
-static void
-teardown_context_already_destroyed(GjsRootingFixture *fx,
-                                   gconstpointer      unused)
-{
-    gjs_unit_test_teardown_context_already_destroyed(PARENT(fx));
-}
-
 static void
 test_maybe_owned_notify_callback_called_on_context_destroy(GjsRootingFixture *fx,
                                                            gconstpointer      unused)
@@ -288,8 +281,7 @@ gjs_test_add_tests_for_rooting(void)
 #undef ADD_ROOTING_TEST
 
 #define ADD_CONTEXT_DESTROY_TEST(path, f) \
-    g_test_add("/rooting/" path, GjsRootingFixture, NULL, setup, f, \
-               teardown_context_already_destroyed);
+    g_test_add("/rooting/" path, GjsRootingFixture, nullptr, setup, f, nullptr);
 
     ADD_CONTEXT_DESTROY_TEST("maybe-owned/notify-callback-called-on-context-destroy",
                              test_maybe_owned_notify_callback_called_on_context_destroy);
diff --git a/test/gjs-test-utils.cpp b/test/gjs-test-utils.cpp
index 74fb1347..0311a44f 100644
--- a/test/gjs-test-utils.cpp
+++ b/test/gjs-test-utils.cpp
@@ -36,19 +36,6 @@
 #include "cjs/jsapi-wrapper.h"
 #include "gjs-test-utils.h"
 
-static void
-test_error_reporter(JSContext     *context,
-                    const char    *message,
-                    JSErrorReport *report)
-{
-    GjsContext *gjs_context = gjs_context_get_current();
-    GjsUnitTestFixture *fx =
-        (GjsUnitTestFixture *) g_object_get_data(G_OBJECT(gjs_context),
-                                                 "test fixture");
-    g_free(fx->message);
-    fx->message = g_strdup(message);
-}
-
 void
 gjs_unit_test_fixture_setup(GjsUnitTestFixture *fx,
                             gconstpointer       unused)
@@ -56,10 +43,6 @@ gjs_unit_test_fixture_setup(GjsUnitTestFixture *fx,
     fx->gjs_context = gjs_context_new();
     fx->cx = (JSContext *) gjs_context_get_native_context(fx->gjs_context);
 
-    /* This is for shoving private data into the error reporter callback */
-    g_object_set_data(G_OBJECT(fx->gjs_context), "test fixture", fx);
-    JS_SetErrorReporter(JS_GetRuntime(fx->cx), test_error_reporter);
-
     JS_BeginRequest(fx->cx);
 
     JS::RootedObject global(fx->cx, gjs_get_import_global(fx->cx));
@@ -69,26 +52,41 @@ gjs_unit_test_fixture_setup(GjsUnitTestFixture *fx,
 void
 gjs_unit_test_destroy_context(GjsUnitTestFixture *fx)
 {
+    GjsAutoChar message = gjs_unit_test_exception_message(fx);
+    if (message)
+        g_printerr("**\n%s\n", message.get());
+
     JS_LeaveCompartment(fx->cx, fx->compartment);
     JS_EndRequest(fx->cx);
 
     g_object_unref(fx->gjs_context);
 }
 
-void
-gjs_unit_test_teardown_context_already_destroyed(GjsUnitTestFixture *fx)
-{
-    if (fx->message != NULL)
-        g_printerr("**\n%s\n", fx->message);
-    g_free(fx->message);
-}
-
 void
 gjs_unit_test_fixture_teardown(GjsUnitTestFixture *fx,
                                gconstpointer      unused)
 {
     gjs_unit_test_destroy_context(fx);
-    gjs_unit_test_teardown_context_already_destroyed(fx);
+}
+
+char *
+gjs_unit_test_exception_message(GjsUnitTestFixture *fx)
+{
+    if (!JS_IsExceptionPending(fx->cx))
+        return nullptr;
+
+    JS::RootedValue v_exc(fx->cx);
+    g_assert_true(JS_GetPendingException(fx->cx, &v_exc));
+    g_assert_true(v_exc.isObject());
+
+    JS::RootedObject exc(fx->cx, &v_exc.toObject());
+    JSErrorReport *report = JS_ErrorFromException(fx->cx, exc);
+    g_assert_nonnull(report);
+
+    char *retval = g_strdup(report->message().c_str());
+    g_assert_nonnull(retval);
+    JS_ClearPendingException(fx->cx);
+    return retval;
 }
 
 /* Fork a process that waits the given time then
diff --git a/test/gjs-test-utils.h b/test/gjs-test-utils.h
index ca3c1ca8..b19f4c5b 100644
--- a/test/gjs-test-utils.h
+++ b/test/gjs-test-utils.h
@@ -28,7 +28,6 @@ struct _GjsUnitTestFixture {
     GjsContext *gjs_context;
     JSContext *cx;
     JSCompartment *compartment;
-    char *message;  /* Thrown exception message */
 };
 
 void gjs_unit_test_fixture_setup(GjsUnitTestFixture *fx,
@@ -36,11 +35,11 @@ void gjs_unit_test_fixture_setup(GjsUnitTestFixture *fx,
 
 void gjs_unit_test_destroy_context(GjsUnitTestFixture *fx);
 
-void gjs_unit_test_teardown_context_already_destroyed(GjsUnitTestFixture *fx);
-
 void gjs_unit_test_fixture_teardown(GjsUnitTestFixture *fx,
                                     gconstpointer      unused);
 
+char *gjs_unit_test_exception_message(GjsUnitTestFixture *fx);
+
 void gjs_crash_after_timeout(int seconds);
 
 void gjs_test_add_tests_for_coverage ();

From 6ec24a69101ea7a2c158d23e5eb02d3a862b59a8 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sat, 10 Jun 2017 18:13:23 -0700
Subject: [PATCH 065/154] js: Replace error reporter callbacks

JS_SetErrorReporter() goes away in SpiderMonkey 52, and is replaced by
JS::SetWarningReporter(). Errors should now be reported manually after
each call into JS code. (We don't actually have to change much, since we
already used the DontReportUncaught option and reported uncaught
exceptions manually already. This is now the only choice.)

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/jsapi-private.cpp    | 10 ++++++----
 cjs/jsapi-util-error.cpp | 29 +++++++++++++++++++++++++++++
 cjs/jsapi-util.h         |  8 +++++---
 cjs/runtime.cpp          |  2 +-
 modules/console.cpp      | 29 +++++++++++++++++++----------
 5 files changed, 60 insertions(+), 18 deletions(-)

diff --git a/cjs/jsapi-private.cpp b/cjs/jsapi-private.cpp
index cf16f732..f6584ef0 100644
--- a/cjs/jsapi-private.cpp
+++ b/cjs/jsapi-private.cpp
@@ -32,13 +32,14 @@
 #include "jsapi-wrapper.h"
 
 void
-gjs_error_reporter(JSContext     *context,
-                   const char    *message,
-                   JSErrorReport *report)
+gjs_warning_reporter(JSContext     *context,
+                     JSErrorReport *report)
 {
     const char *warning;
     GLogLevelFlags level;
 
+    g_assert(report);
+
     if (gjs_environment_variable_is_set("GJS_ABORT_ON_OOM") &&
         report->flags == JSREPORT_ERROR &&
         report->errorNumber == 137) {
@@ -66,5 +67,6 @@ gjs_error_reporter(JSContext     *context,
         level = G_LOG_LEVEL_WARNING;
     }
 
-    g_log(G_LOG_DOMAIN, level, "JS %s: [%s %d]: %s", warning, report->filename, report->lineno, message);
+    g_log(G_LOG_DOMAIN, level, "JS %s: [%s %d]: %s", warning, report->filename,
+          report->lineno, report->message().c_str());
 }
diff --git a/cjs/jsapi-util-error.cpp b/cjs/jsapi-util-error.cpp
index ce1bbd59..1196bd0e 100644
--- a/cjs/jsapi-util-error.cpp
+++ b/cjs/jsapi-util-error.cpp
@@ -202,3 +202,32 @@ gjs_throw_g_error (JSContext       *context,
 
     JS_EndRequest(context);
 }
+
+/**
+ * gjs_format_stack_trace:
+ * @cx: the #JSContext
+ * @saved_frame: a SavedFrame #JSObject
+ *
+ * Formats a stack trace as a string in filename encoding, suitable for
+ * printing to stderr. Ignores any errors.
+ *
+ * Returns: unique string in filename encoding, or nullptr if no stack trace
+ */
+GjsAutoChar
+gjs_format_stack_trace(JSContext       *cx,
+                       JS::HandleObject saved_frame)
+{
+    JS::AutoSaveExceptionState saved_exc(cx);
+
+    JS::RootedString stack_trace(cx);
+    GjsAutoJSChar stack_utf8(cx);
+    if (JS::BuildStackString(cx, saved_frame, &stack_trace, 2))
+        stack_utf8.reset(cx, JS_EncodeStringToUTF8(cx, stack_trace));
+
+    saved_exc.restore();
+
+    if (!stack_utf8)
+        return nullptr;
+
+    return g_filename_from_utf8(stack_utf8, -1, nullptr, nullptr, nullptr);
+}
diff --git a/cjs/jsapi-util.h b/cjs/jsapi-util.h
index 27977e6c..c3d89f21 100644
--- a/cjs/jsapi-util.h
+++ b/cjs/jsapi-util.h
@@ -195,9 +195,8 @@ bool gjs_call_function_value(JSContext                  *context,
                              const JS::HandleValueArray& args,
                              JS::MutableHandleValue      rval);
 
-void        gjs_error_reporter               (JSContext       *context,
-                                              const char      *message,
-                                              JSErrorReport   *report);
+void gjs_warning_reporter(JSContext     *cx,
+                          JSErrorReport *report);
 
 bool        gjs_string_to_utf8               (JSContext       *context,
                                               const JS::Value  string_val,
@@ -312,6 +311,9 @@ bool gjs_object_has_property(JSContext       *cx,
 
 G_END_DECLS
 
+GjsAutoChar gjs_format_stack_trace(JSContext       *cx,
+                                   JS::HandleObject saved_frame);
+
 bool gjs_object_define_property(JSContext       *cx,
                                 JS::HandleObject obj,
                                 GjsConstString   property_name,
diff --git a/cjs/runtime.cpp b/cjs/runtime.cpp
index 3c9c2061..3f7aaff3 100644
--- a/cjs/runtime.cpp
+++ b/cjs/runtime.cpp
@@ -310,7 +310,7 @@ gjs_runtime_for_current_thread(void)
         // JS_SetGCParameter(runtime, JSGC_DECOMMIT_THRESHOLD, 32);
         JS_SetLocaleCallbacks(runtime, &gjs_locale_callbacks);
         JS_AddFinalizeCallback(runtime, gjs_finalize_callback, data);
-        JS_SetErrorReporter(runtime, gjs_error_reporter);
+        JS::SetWarningReporter(runtime, gjs_warning_reporter);
 
         g_private_set(&thread_runtime, runtime);
     }
diff --git a/modules/console.cpp b/modules/console.cpp
index 76bae67f..c4f18f76 100644
--- a/modules/console.cpp
+++ b/modules/console.cpp
@@ -58,15 +58,11 @@
 #include "cjs/jsapi-wrapper.h"
 
 static void
-gjs_console_print_error(const char *message, JSErrorReport *report)
+gjs_console_print_error(JSErrorReport *report)
 {
     /* Code modified from SpiderMonkey js/src/jscntxt.cpp, js::PrintError() */
 
-    if (!report) {
-        fprintf(stderr, "%s\n", message);
-        fflush(stderr);
-        return;
-    }
+    g_assert(report);
 
     char *prefix = nullptr;
     if (report->filename)
@@ -85,6 +81,8 @@ gjs_console_print_error(const char *message, JSErrorReport *report)
         g_free(tmp);
     }
 
+    const char *message = report->message().c_str();
+
     /* embedded newlines -- argh! */
     const char *ctmp;
     while ((ctmp = strchr(message, '\n')) != 0) {
@@ -135,9 +133,9 @@ gjs_console_print_error(const char *message, JSErrorReport *report)
 }
 
 static void
-gjs_console_error_reporter(JSContext *cx, const char *message, JSErrorReport *report)
+gjs_console_warning_reporter(JSContext *cx, JSErrorReport *report)
 {
-    gjs_console_print_error(message, report);
+    gjs_console_print_error(report);
 }
 
 /* Based on js::shell::AutoReportException from SpiderMonkey. */
@@ -162,7 +160,18 @@ class AutoReportException {
 
         g_assert(!JSREPORT_IS_WARNING(report->flags));
 
-        JS_ReportPendingException(m_cx);
+        gjs_console_print_error(report);
+
+        JS::RootedObject stack(m_cx, ExceptionStackOrNull(exn));
+        if (stack) {
+            GjsAutoChar stack_str = gjs_format_stack_trace(m_cx, stack);
+            if (!stack_str)
+                g_printerr("(Unable to print stack trace)\n");
+            else
+                g_printerr("%s", stack_str.get());
+        }
+
+        JS_ClearPendingException(m_cx);
     }
 };
 
@@ -245,7 +254,7 @@ gjs_console_interact(JSContext *context,
     int startline;
     FILE *file = stdin;
 
-    JS_SetErrorReporter(JS_GetRuntime(context), gjs_console_error_reporter);
+    JS::SetWarningReporter(context, gjs_console_warning_reporter);
 
         /* It's an interactive filehandle; drop into read-eval-print loop. */
     lineno = 1;

From 631f608c5ffffc8c2a14568db7c0d35f0e532b6b Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 2 May 2017 22:00:03 -0700
Subject: [PATCH 066/154] js: Replace JSRuntime APIs that now take JSContext

Many APIs that adapted to the removal of JSRuntime can be trivially
replaced with JSContext without any other code changes.

JS_AbortIfWrongThread() also takes JSContext instead of JSRuntime, but
we only called it to check that we were creating a JSContext on the
correct thread. Before creating the JSContext, there is no point in
calling it, so remove it.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/context.cpp           | 14 +++++++-------
 cjs/coverage.cpp          |  7 ++-----
 cjs/jsapi-util.cpp        |  2 +-
 gi/gtype.cpp              |  5 ++---
 gi/object.cpp             |  4 ++--
 modules/system.cpp        |  6 +++---
 test/gjs-test-rooting.cpp |  6 +++---
 7 files changed, 20 insertions(+), 24 deletions(-)

diff --git a/cjs/context.cpp b/cjs/context.cpp
index 36691c0b..a8b7633b 100644
--- a/cjs/context.cpp
+++ b/cjs/context.cpp
@@ -114,7 +114,7 @@ static GMutex contexts_lock;
 static GList *all_contexts = NULL;
 
 static void
-on_garbage_collect(JSRuntime *rt,
+on_garbage_collect(JSContext *cx,
                    JSGCStatus status,
                    void      *data)
 {
@@ -217,7 +217,7 @@ gjs_context_dispose(GObject *object)
          * that we may not have the JS_GetPrivate() to access the
          * context
          */
-        JS_GC(js_context->runtime);
+        JS_GC(js_context->context);
         JS_EndRequest(js_context->context);
 
         js_context->destroying = true;
@@ -233,7 +233,7 @@ gjs_context_dispose(GObject *object)
             js_context->auto_gc_id = 0;
         }
 
-        JS_RemoveExtraGCRootsTracer(js_context->runtime, gjs_context_tracer,
+        JS_RemoveExtraGCRootsTracer(js_context->context, gjs_context_tracer,
                                     js_context);
         js_context->global = NULL;
 
@@ -285,7 +285,6 @@ gjs_context_constructed(GObject *object)
 
     js_context->runtime = gjs_runtime_ref();
 
-    JS_AbortIfWrongThread(js_context->runtime);
     js_context->owner_thread = g_thread_self();
 
     js_context->context = JS_NewContext(js_context->runtime, 8192 /* stack chunk size */);
@@ -300,7 +299,7 @@ gjs_context_constructed(GObject *object)
 
     JS_BeginRequest(js_context->context);
 
-    JS_SetGCCallback(js_context->runtime, on_garbage_collect, js_context);
+    JS_SetGCCallback(js_context->context, on_garbage_collect, js_context);
 
     /* set ourselves as the private data */
     JS_SetContextPrivate(js_context->context, js_context);
@@ -329,7 +328,8 @@ gjs_context_constructed(GObject *object)
     JSAutoCompartment ac(js_context->context, global);
 
     new (&js_context->global) JS::Heap<JSObject *>(global);
-    JS_AddExtraGCRootsTracer(js_context->runtime, gjs_context_tracer, js_context);
+    JS_AddExtraGCRootsTracer(js_context->context, gjs_context_tracer,
+                             js_context);
 
     JS::RootedObject importer(js_context->context,
         gjs_create_root_importer(js_context->context, js_context->search_path ?
@@ -509,7 +509,7 @@ gjs_context_maybe_gc (GjsContext  *context)
 void
 gjs_context_gc (GjsContext  *context)
 {
-    JS_GC(context->runtime);
+    JS_GC(context->context);
 }
 
 /**
diff --git a/cjs/coverage.cpp b/cjs/coverage.cpp
index 6485d238..cafbbab7 100644
--- a/cjs/coverage.cpp
+++ b/cjs/coverage.cpp
@@ -1630,9 +1630,7 @@ bootstrap_coverage(GjsCoverage *coverage)
         }
 
         /* Add a tracer, as suggested by jdm on #jsapi */
-        JS_AddExtraGCRootsTracer(JS_GetRuntime(context),
-                                 coverage_statistics_tracer,
-                                 coverage);
+        JS_AddExtraGCRootsTracer(context, coverage_statistics_tracer, coverage);
 
         priv->coverage_statistics = coverage_statistics;
     }
@@ -1711,8 +1709,7 @@ gjs_clear_js_side_statistics_from_coverage_object(GjsCoverage *coverage)
 
         /* Remove GC roots trace after we've decomissioned the object
          * and no longer need it to be traced here. */
-        JS_RemoveExtraGCRootsTracer(JS_GetRuntime(js_context),
-                                    coverage_statistics_tracer,
+        JS_RemoveExtraGCRootsTracer(js_context, coverage_statistics_tracer,
                                     coverage);
 
         priv->coverage_statistics = NULL;
diff --git a/cjs/jsapi-util.cpp b/cjs/jsapi-util.cpp
index 465b04f5..48f71f44 100644
--- a/cjs/jsapi-util.cpp
+++ b/cjs/jsapi-util.cpp
@@ -709,7 +709,7 @@ gjs_gc_if_needed (JSContext *context)
          */
         if (rss_size > linux_rss_trigger) {
             linux_rss_trigger = (gulong) MIN(G_MAXULONG, rss_size * 1.25);
-            JS_GC(JS_GetRuntime(context));
+            JS_GC(context);
             last_gc_time = now;
         } else if (rss_size < (0.75 * linux_rss_trigger)) {
             /* If we've shrunk by 75%, lower the trigger */
diff --git a/gi/gtype.cpp b/gi/gtype.cpp
index 41b882a8..5a27ce94 100644
--- a/gi/gtype.cpp
+++ b/gi/gtype.cpp
@@ -58,7 +58,7 @@ gjs_get_gtype_wrapper_quark(void)
 }
 
 static void
-update_gtype_weak_pointers(JSRuntime     *rt,
+update_gtype_weak_pointers(JSContext     *cx,
                            JSCompartment *compartment,
                            void          *data)
 {
@@ -76,8 +76,7 @@ static void
 ensure_weak_pointer_callback(JSContext *cx)
 {
     if (!weak_pointer_callback) {
-        JS_AddWeakPointerCompartmentCallback(JS_GetRuntime(cx),
-                                             update_gtype_weak_pointers,
+        JS_AddWeakPointerCompartmentCallback(cx, update_gtype_weak_pointers,
                                              nullptr);
         weak_pointer_callback = true;
     }
diff --git a/gi/object.cpp b/gi/object.cpp
index 880627a6..c8f663b7 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -1127,7 +1127,7 @@ init_object_private (JSContext       *context,
 }
 
 static void
-update_heap_wrapper_weak_pointers(JSRuntime     *rt,
+update_heap_wrapper_weak_pointers(JSContext     *cx,
                                   JSCompartment *compartment,
                                   gpointer       data)
 {
@@ -1157,7 +1157,7 @@ static void
 ensure_weak_pointer_callback(JSContext *cx)
 {
     if (!weak_pointer_callback) {
-        JS_AddWeakPointerCompartmentCallback(JS_GetRuntime(cx),
+        JS_AddWeakPointerCompartmentCallback(cx,
                                              update_heap_wrapper_weak_pointers,
                                              nullptr);
         weak_pointer_callback = true;
diff --git a/modules/system.cpp b/modules/system.cpp
index 3406a39a..240caa06 100644
--- a/modules/system.cpp
+++ b/modules/system.cpp
@@ -112,11 +112,11 @@ gjs_dump_heap(JSContext *cx,
 
     if (filename) {
         FILE *fp = fopen(filename, "a");
-        js::DumpHeap(JS_GetRuntime(cx), fp, js::IgnoreNurseryObjects);
+        js::DumpHeap(cx, fp, js::IgnoreNurseryObjects);
         fclose(fp);
         g_free(filename);
     } else {
-        js::DumpHeap(JS_GetRuntime(cx), stdout, js::IgnoreNurseryObjects);
+        js::DumpHeap(cx, stdout, js::IgnoreNurseryObjects);
     }
 
     args.rval().setUndefined();
@@ -131,7 +131,7 @@ gjs_gc(JSContext *context,
     JS::CallArgs argv = JS::CallArgsFromVp (argc, vp);
     if (!gjs_parse_call_args(context, "gc", argv, ""))
         return false;
-    JS_GC(JS_GetRuntime(context));
+    JS_GC(context);
     argv.rval().setUndefined();
     return true;
 }
diff --git a/test/gjs-test-rooting.cpp b/test/gjs-test-rooting.cpp
index b48d4797..b5f6b9be 100644
--- a/test/gjs-test-rooting.cpp
+++ b/test/gjs-test-rooting.cpp
@@ -52,7 +52,7 @@ test_obj_new(GjsRootingFixture *fx)
 }
 
 static void
-on_gc(JSRuntime *rt,
+on_gc(JSContext *cx,
       JSGCStatus status,
       void      *data)
 {
@@ -70,7 +70,7 @@ setup(GjsRootingFixture *fx,
       gconstpointer      unused)
 {
     gjs_unit_test_fixture_setup(PARENT(fx), unused);
-    JS_SetGCCallback(JS_GetRuntime(PARENT(fx)->cx), on_gc, fx);
+    JS_SetGCCallback(PARENT(fx)->cx, on_gc, fx);
 }
 
 static void
@@ -85,7 +85,7 @@ wait_for_gc(GjsRootingFixture *fx)
 {
     int count = g_atomic_int_get(&gc_counter);
 
-    JS_GC(JS_GetRuntime(PARENT(fx)->cx));
+    JS_GC(PARENT(fx)->cx);
 
     g_mutex_lock(&gc_lock);
     while (count == g_atomic_int_get(&gc_counter)) {

From b591c2e1eba986cb40249061edbb67c6da3c900c Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 22:30:42 -0500
Subject: [PATCH 067/154] js: Remove JSRuntime

JSRuntime is merged into JSContext in SpiderMonkey 52.

We reorganize things a bit to reflect the new situation. The files
runtime.cpp and runtime.h are renamed to engine.cpp and engine.h, and
will contain everything having to do with the SpiderMonkey engine:
initializing the JSContext, and any callbacks that the engine requires
embedders to set.

https://bugzilla.gnome.org/show_bug.cgi?id=784196

https://github.com/GNOME/gjs/commit/ec0d71407d837c6ba14d5540864ab824aeea6bf6#diff-044a079258e1ba105086eb30b78da01f
---
 cjs/context-private.h           |   6 ++
 cjs/context.cpp                 |  90 ++++++++---------------
 cjs/{runtime.cpp => engine.cpp} | 159 +++++++++++++++-------------------------
 cjs/{runtime.h => engine.h}     |  14 ++--
 cjs/jsapi-util.h                |   1 -
 gi/function.cpp                 |   4 +-
 gi/value.cpp                    |   5 +-
 gjs-srcs.mk                     |   4 +-
 8 files changed, 110 insertions(+), 173 deletions(-)
 rename cjs/{runtime.cpp => engine.cpp} (64%)
 rename cjs/{runtime.h => engine.h} (83%)

diff --git a/cjs/context-private.h b/cjs/context-private.h
index 2d8834de..d6207dab 100644
--- a/cjs/context-private.h
+++ b/cjs/context-private.h
@@ -27,6 +27,7 @@
 #include <inttypes.h>
 
 #include "context.h"
+#include "jsapi-wrapper.h"
 
 G_BEGIN_DECLS
 
@@ -42,6 +43,11 @@ bool _gjs_context_get_is_owner_thread(GjsContext *js_context);
 bool _gjs_context_should_exit(GjsContext *js_context,
                               uint8_t    *exit_code_p);
 
+void _gjs_context_set_sweeping(GjsContext *js_context,
+                               bool        sweeping);
+
+bool _gjs_context_is_sweeping(JSContext *cx);
+
 G_END_DECLS
 
 #endif  /* __GJS_CONTEXT_PRIVATE_H__ */
diff --git a/cjs/context.cpp b/cjs/context.cpp
index a8b7633b..962e51c5 100644
--- a/cjs/context.cpp
+++ b/cjs/context.cpp
@@ -28,6 +28,7 @@
 #include <gio/gio.h>
 
 #include "context-private.h"
+#include "engine.h"
 #include "global.h"
 #include "importer.h"
 #include "jsapi-private.h"
@@ -35,7 +36,6 @@
 #include "jsapi-wrapper.h"
 #include "native.h"
 #include "byteArray.h"
-#include "runtime.h"
 #include "gi/object.h"
 #include "gi/repo.h"
 
@@ -66,7 +66,6 @@ static void     gjs_context_set_property      (GObject               *object,
 struct _GjsContext {
     GObject parent;
 
-    JSRuntime *runtime;
     JSContext *context;
     JS::Heap<JSObject*> global;
     GThread *owner_thread;
@@ -76,6 +75,7 @@ struct _GjsContext {
     char **search_path;
 
     bool destroying;
+    bool in_gc_sweep;
 
     bool should_exit;
     uint8_t exit_code;
@@ -113,19 +113,6 @@ enum {
 static GMutex contexts_lock;
 static GList *all_contexts = NULL;
 
-static void
-on_garbage_collect(JSContext *cx,
-                   JSGCStatus status,
-                   void      *data)
-{
-    /* We finalize any pending toggle refs before doing any garbage collection,
-     * so that we can collect the JS wrapper objects, and in order to minimize
-     * the chances of objects having a pending toggle up queued when they are
-     * garbage collected. */
-    if (status == JSGC_BEGIN)
-        gjs_object_clear_toggles();
-}
-
 static void
 gjs_context_init(GjsContext *js_context)
 {
@@ -243,7 +230,6 @@ gjs_context_dispose(GObject *object)
         /* Tear down JS */
         JS_DestroyContext(js_context->context);
         js_context->context = NULL;
-        g_clear_pointer(&js_context->runtime, gjs_runtime_unref);
     }
 }
 
@@ -283,74 +269,48 @@ gjs_context_constructed(GObject *object)
 
     G_OBJECT_CLASS(gjs_context_parent_class)->constructed(object);
 
-    js_context->runtime = gjs_runtime_ref();
-
     js_context->owner_thread = g_thread_self();
 
-    js_context->context = JS_NewContext(js_context->runtime, 8192 /* stack chunk size */);
-    if (js_context->context == NULL)
+    JSContext *cx = gjs_create_js_context(js_context);
+    if (!cx)
         g_error("Failed to create javascript context");
+    js_context->context = cx;
 
     for (i = 0; i < GJS_STRING_LAST; i++) {
-        js_context->const_strings[i] =
-            new JS::PersistentRootedId(js_context->context,
-                gjs_intern_string_to_id(js_context->context, const_strings[i]));
-    }
-
-    JS_BeginRequest(js_context->context);
-
-    JS_SetGCCallback(js_context->context, on_garbage_collect, js_context);
-
-    /* set ourselves as the private data */
-    JS_SetContextPrivate(js_context->context, js_context);
-
-    /* setExtraWarnings: Be extra strict about code that might hide a bug */
-    if (!g_getenv("GJS_DISABLE_EXTRA_WARNINGS")) {
-        gjs_debug(GJS_DEBUG_CONTEXT, "Enabling extra warnings");
-        JS::ContextOptionsRef(js_context->context).setExtraWarnings(true);
+        js_context->const_strings[i] = new JS::PersistentRootedId(cx,
+            gjs_intern_string_to_id(cx, const_strings[i]));
     }
 
-    if (!g_getenv("GJS_DISABLE_JIT")) {
-        gjs_debug(GJS_DEBUG_CONTEXT, "Enabling JIT");
-        JS::ContextOptionsRef(js_context->context)
-            .setIon(true)
-            .setBaseline(true)
-            .setAsmJS(true);
-    }
+    JS_BeginRequest(cx);
 
-    JS::RootedObject global(js_context->context,
-        gjs_create_global_object(js_context->context));
+    JS::RootedObject global(cx, gjs_create_global_object(cx));
     if (!global) {
         gjs_log_exception(js_context->context);
         g_error("Failed to initialize global object");
     }
 
-    JSAutoCompartment ac(js_context->context, global);
+    JSAutoCompartment ac(cx, global);
 
     new (&js_context->global) JS::Heap<JSObject *>(global);
-    JS_AddExtraGCRootsTracer(js_context->context, gjs_context_tracer,
-                             js_context);
+    JS_AddExtraGCRootsTracer(cx, gjs_context_tracer, js_context);
 
-    JS::RootedObject importer(js_context->context,
-        gjs_create_root_importer(js_context->context, js_context->search_path ?
-                                 js_context->search_path : nullptr));
+    JS::RootedObject importer(cx, gjs_create_root_importer(cx,
+        js_context->search_path ? js_context->search_path : nullptr));
     if (!importer)
         g_error("Failed to create root importer");
 
-    JS::Value v_importer = gjs_get_global_slot(js_context->context,
-                                               GJS_GLOBAL_SLOT_IMPORTS);
+    JS::Value v_importer = gjs_get_global_slot(cx, GJS_GLOBAL_SLOT_IMPORTS);
     g_assert(((void) "Someone else already created root importer",
               v_importer.isUndefined()));
 
-    gjs_set_global_slot(js_context->context, GJS_GLOBAL_SLOT_IMPORTS,
-                        JS::ObjectValue(*importer));
+    gjs_set_global_slot(cx, GJS_GLOBAL_SLOT_IMPORTS, JS::ObjectValue(*importer));
 
-    if (!gjs_define_global_properties(js_context->context, global)) {
-        gjs_log_exception(js_context->context);
+    if (!gjs_define_global_properties(cx, global)) {
+        gjs_log_exception(cx);
         g_error("Failed to define properties on global object");
     }
 
-    JS_EndRequest(js_context->context);
+    JS_EndRequest(cx);
 
     g_mutex_lock (&contexts_lock);
     all_contexts = g_list_prepend(all_contexts, object);
@@ -472,6 +432,20 @@ _gjs_context_get_is_owner_thread(GjsContext *js_context)
     return js_context->owner_thread == g_thread_self();
 }
 
+void
+_gjs_context_set_sweeping(GjsContext *js_context,
+                          bool        sweeping)
+{
+    js_context->in_gc_sweep = sweeping;
+}
+
+bool
+_gjs_context_is_sweeping(JSContext *cx)
+{
+    auto js_context = static_cast<GjsContext *>(JS_GetContextPrivate(cx));
+    return js_context->in_gc_sweep;
+}
+
 /**
  * gjs_context_maybe_gc:
  * @context: a #GjsContext
diff --git a/cjs/runtime.cpp b/cjs/engine.cpp
similarity index 64%
rename from cjs/runtime.cpp
rename to cjs/engine.cpp
index 3f7aaff3..9676166f 100644
--- a/cjs/runtime.cpp
+++ b/cjs/engine.cpp
@@ -26,27 +26,17 @@
 #include "jsapi-wrapper.h"
 #include <js/Initialization.h>
 
+#include "context-private.h"
+#include "engine.h"
+#include "gi/object.h"
 #include "jsapi-util.h"
-#include "runtime.h"
+#include "util/log.h"
 
 #ifdef G_OS_WIN32
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
 #endif
 
-struct RuntimeData {
-  unsigned refcount;
-  bool in_gc_sweep;
-};
-
-bool
-gjs_runtime_is_sweeping (JSRuntime *runtime)
-{
-  RuntimeData *data = (RuntimeData*) JS_GetRuntimePrivate(runtime);
-
-  return data->in_gc_sweep;
-}
-
 /* Implementations of locale-specific operations; these are used
  * in the implementation of String.localeCompare(), Date.toLocaleDateString(),
  * and so forth. We take the straight-forward approach of converting
@@ -144,18 +134,6 @@ gjs_locale_to_unicode (JSContext  *context,
     return success;
 }
 
-static void
-destroy_runtime(gpointer data)
-{
-    JSRuntime *runtime = (JSRuntime *) data;
-    RuntimeData *rtdata = (RuntimeData *) JS_GetRuntimePrivate(runtime);
-
-    JS_DestroyRuntime(runtime);
-    g_free(rtdata);
-}
-
-static GPrivate thread_runtime = G_PRIVATE_INIT(destroy_runtime);
-
 static JSLocaleCallbacks gjs_locale_callbacks =
 {
     gjs_locale_to_upper_case,
@@ -168,9 +146,9 @@ static void
 gjs_finalize_callback(JSFreeOp         *fop,
                       JSFinalizeStatus  status,
                       bool              isCompartment,
-                      void             *user_data)
+                      void             *data)
 {
-  RuntimeData *data = static_cast<RuntimeData *>(user_data);
+    auto js_context = static_cast<GjsContext *>(data);
 
   /* Implementation note for mozjs 24:
      sweeping happens in two phases, in the first phase all
@@ -213,17 +191,22 @@ gjs_finalize_callback(JSFreeOp         *fop,
   */
 
   if (status == JSFINALIZE_GROUP_START)
-    data->in_gc_sweep = true;
+        _gjs_context_set_sweeping(js_context, true);
   else if (status == JSFINALIZE_GROUP_END)
-    data->in_gc_sweep = false;
+        _gjs_context_set_sweeping(js_context, false);
 }
 
-/* Destroys the current thread's runtime regardless of refcount. No-op if there
- * is no runtime */
 static void
-gjs_destroy_runtime_for_current_thread(void)
+on_garbage_collect(JSContext *cx,
+                   JSGCStatus status,
+                   void      *data)
 {
-    g_private_replace(&thread_runtime, NULL);
+    /* We finalize any pending toggle refs before doing any garbage collection,
+     * so that we can collect the JS wrapper objects, and in order to minimize
+     * the chances of objects having a pending toggle up queued when they are
+     * garbage collected. */
+    if (status == JSGC_BEGIN)
+        gjs_object_clear_toggles();
 }
 
 #ifdef G_OS_WIN32
@@ -243,7 +226,6 @@ LPVOID    lpvReserved)
     break;
 
   case DLL_THREAD_DETACH:
-    gjs_destroy_runtime_for_current_thread();
     JS_ShutDown ();
     break;
 
@@ -264,8 +246,6 @@ class GjsInit {
     }
 
     ~GjsInit() {
-        /* No-op if the runtime was already destroyed */
-        gjs_destroy_runtime_for_current_thread();
         JS_ShutDown();
     }
 
@@ -277,69 +257,52 @@ class GjsInit {
 static GjsInit gjs_is_inited;
 #endif
 
-static JSRuntime *
-gjs_runtime_for_current_thread(void)
+JSContext *
+gjs_create_js_context(GjsContext *js_context)
 {
-    JSRuntime *runtime = (JSRuntime *) g_private_get(&thread_runtime);
-    RuntimeData *data;
-
-    if (!runtime) {
-        g_assert(gjs_is_inited);
-        runtime = JS_NewRuntime(32 * 1024 * 1024 /* max bytes */);
-        if (runtime == NULL)
-            g_error("Failed to create javascript runtime");
-
-        data = g_new0(RuntimeData, 1);
-        JS_SetRuntimePrivate(runtime, data);
-
-        // commented are defaults in moz-24
-        JS_SetNativeStackQuota(runtime, 1024*1024);
-        JS_SetGCParameter(runtime, JSGC_MAX_MALLOC_BYTES, 128*1024*1024);
-        JS_SetGCParameter(runtime, JSGC_MAX_BYTES, -1);
-        JS_SetGCParameter(runtime, JSGC_MODE, JSGC_MODE_INCREMENTAL);
-        JS_SetGCParameter(runtime, JSGC_SLICE_TIME_BUDGET, 10); /* ms */
-        // JS_SetGCParameter(runtime, JSGC_HIGH_FREQUENCY_TIME_LIMIT, 1000); /* ms */
-        JS_SetGCParameter(runtime, JSGC_DYNAMIC_MARK_SLICE, true);
-        JS_SetGCParameter(runtime, JSGC_DYNAMIC_HEAP_GROWTH, true);
-        // JS_SetGCParameter(runtime, JSGC_LOW_FREQUENCY_HEAP_GROWTH, 150);
-        // JS_SetGCParameter(runtime, JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN, 150);
-        // JS_SetGCParameter(runtime, JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX, 300);
-        // JS_SetGCParameter(runtime, JSGC_HIGH_FREQUENCY_LOW_LIMIT, 100);
-        // JS_SetGCParameter(runtime, JSGC_HIGH_FREQUENCY_HIGH_LIMIT, 500);
-        // JS_SetGCParameter(runtime, JSGC_ALLOCATION_THRESHOLD, 30);
-        // JS_SetGCParameter(runtime, JSGC_DECOMMIT_THRESHOLD, 32);
-        JS_SetLocaleCallbacks(runtime, &gjs_locale_callbacks);
-        JS_AddFinalizeCallback(runtime, gjs_finalize_callback, data);
-        JS::SetWarningReporter(runtime, gjs_warning_reporter);
-
-        g_private_set(&thread_runtime, runtime);
+    g_assert(gjs_is_inited);
+    JSContext *cx = JS_NewContext(32 * 1024 * 1024 /* max bytes */);
+    if (!cx)
+        return nullptr;
+
+    // commented are defaults in moz-24
+    JS_SetNativeStackQuota(cx, 1024 * 1024);
+    JS_SetGCParameter(cx, JSGC_MAX_MALLOC_BYTES, 128 * 1024 * 1024);
+    JS_SetGCParameter(cx, JSGC_MAX_BYTES, -1);
+    JS_SetGCParameter(cx, JSGC_MODE, JSGC_MODE_INCREMENTAL);
+    JS_SetGCParameter(cx, JSGC_SLICE_TIME_BUDGET, 10); /* ms */
+    // JS_SetGCParameter(cx, JSGC_HIGH_FREQUENCY_TIME_LIMIT, 1000); /* ms */
+    JS_SetGCParameter(cx, JSGC_DYNAMIC_MARK_SLICE, true);
+    JS_SetGCParameter(cx, JSGC_DYNAMIC_HEAP_GROWTH, true);
+    // JS_SetGCParameter(cx, JSGC_LOW_FREQUENCY_HEAP_GROWTH, 150);
+    // JS_SetGCParameter(cx, JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN, 150);
+    // JS_SetGCParameter(cx, JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX, 300);
+    // JS_SetGCParameter(cx, JSGC_HIGH_FREQUENCY_LOW_LIMIT, 100);
+    // JS_SetGCParameter(cx, JSGC_HIGH_FREQUENCY_HIGH_LIMIT, 500);
+    // JS_SetGCParameter(cx, JSGC_ALLOCATION_THRESHOLD, 30);
+    // JS_SetGCParameter(cx, JSGC_DECOMMIT_THRESHOLD, 32);
+
+    /* set ourselves as the private data */
+    JS_SetContextPrivate(cx, js_context);
+
+    JS_AddFinalizeCallback(cx, gjs_finalize_callback, js_context);
+    JS_SetGCCallback(cx, on_garbage_collect, js_context);
+    JS_SetLocaleCallbacks(cx, &gjs_locale_callbacks);
+    JS::SetWarningReporter(cx, gjs_warning_reporter);
+
+    /* setExtraWarnings: Be extra strict about code that might hide a bug */
+    if (!g_getenv("GJS_DISABLE_EXTRA_WARNINGS")) {
+        gjs_debug(GJS_DEBUG_CONTEXT, "Enabling extra warnings");
+        JS::ContextOptionsRef(cx).setExtraWarnings(true);
     }
 
-    return runtime;
-}
-
-/* These two act on the current thread's runtime. In the future they will go
- * away because SpiderMonkey is going to merge JSContext and JSRuntime.
- */
-
-/* Creates a new runtime with one reference if there is no runtime yet */
-JSRuntime *
-gjs_runtime_ref(void)
-{
-    JSRuntime *rt = static_cast<JSRuntime *>(gjs_runtime_for_current_thread());
-    RuntimeData *data = static_cast<RuntimeData *>(JS_GetRuntimePrivate(rt));
-    g_atomic_int_inc(&data->refcount);
-    return rt;
-}
+    if (!g_getenv("GJS_DISABLE_JIT")) {
+        gjs_debug(GJS_DEBUG_CONTEXT, "Enabling JIT");
+        JS::ContextOptionsRef(cx)
+            .setIon(true)
+            .setBaseline(true)
+            .setAsmJS(true);
+    }
 
-/* No-op if there is no runtime */
-void
-gjs_runtime_unref(void)
-{
-    JSRuntime *rt = static_cast<JSRuntime *>(g_private_get(&thread_runtime));
-    if (rt == NULL)
-        return;
-    RuntimeData *data = static_cast<RuntimeData *>(JS_GetRuntimePrivate(rt));
-    if (g_atomic_int_dec_and_test(&data->refcount))
-        gjs_destroy_runtime_for_current_thread();
+    return cx;
 }
diff --git a/cjs/runtime.h b/cjs/engine.h
similarity index 83%
rename from cjs/runtime.h
rename to cjs/engine.h
index 6f31fd21..46bce817 100644
--- a/cjs/runtime.h
+++ b/cjs/engine.h
@@ -21,14 +21,12 @@
  * IN THE SOFTWARE.
  */
 
-#ifndef __GJS_RUNTIME_H__
-#define __GJS_RUNTIME_H__
+#ifndef GJS_ENGINE_H
+#define GJS_ENGINE_H
 
-#include <stdbool.h>
+#include "context.h"
+#include "jsapi-wrapper.h"
 
-JSRuntime *gjs_runtime_ref(void);
-void gjs_runtime_unref(void);
+JSContext *gjs_create_js_context(GjsContext *js_context);
 
-bool        gjs_runtime_is_sweeping        (JSRuntime *runtime);
-
-#endif /* __GJS_RUNTIME_H__ */
+#endif  /* GJS_ENGINE_H */
diff --git a/cjs/jsapi-util.h b/cjs/jsapi-util.h
index c3d89f21..8b276a66 100644
--- a/cjs/jsapi-util.h
+++ b/cjs/jsapi-util.h
@@ -30,7 +30,6 @@
 #include <glib-object.h>
 
 #include "jsapi-wrapper.h"
-#include "cjs/runtime.h"
 #include "gi/gtype.h"
 
 class GjsAutoChar : public std::unique_ptr<char, decltype(&g_free)> {
diff --git a/gi/function.cpp b/gi/function.cpp
index 0eaac9a0..bef5b7b0 100644
--- a/gi/function.cpp
+++ b/gi/function.cpp
@@ -173,7 +173,6 @@ gjs_callback_closure(ffi_cif *cif,
                      void *data)
 {
     JSContext *context;
-    JSRuntime *runtime;
     JSObject *func_obj;
     GjsCallbackTrampoline *trampoline;
     int i, n_args, n_jsargs, n_outargs;
@@ -186,8 +185,7 @@ gjs_callback_closure(ffi_cif *cif,
     gjs_callback_trampoline_ref(trampoline);
 
     context = trampoline->context;
-    runtime = JS_GetRuntime(context);
-    if (G_UNLIKELY (gjs_runtime_is_sweeping(runtime))) {
+    if (G_UNLIKELY(_gjs_context_is_sweeping(context))) {
         g_critical("Attempting to call back into JSAPI during the sweeping phase of GC. "
                    "This is most likely caused by not destroying a Clutter actor or Gtk+ "
                    "widget with ::destroy signals connected, but can also be caused by "
diff --git a/gi/value.cpp b/gi/value.cpp
index 48063347..32000304 100644
--- a/gi/value.cpp
+++ b/gi/value.cpp
@@ -36,6 +36,7 @@
 #include "union.h"
 #include "gtype.h"
 #include "gerror.h"
+#include "cjs/context-private.h"
 #include "cjs/jsapi-wrapper.h"
 
 #include <girepository.h>
@@ -118,7 +119,6 @@ closure_marshal(GClosure        *closure,
                 gpointer         marshal_data)
 {
     JSContext *context;
-    JSRuntime *runtime;
     JSObject *obj;
     unsigned i;
     GSignalQuery signal_query = { 0, };
@@ -137,8 +137,7 @@ closure_marshal(GClosure        *closure,
     }
 
     context = gjs_closure_get_context(closure);
-    runtime = JS_GetRuntime(context);
-    if (G_UNLIKELY (gjs_runtime_is_sweeping(runtime))) {
+    if (G_UNLIKELY(_gjs_context_is_sweeping(context))) {
         GSignalInvocationHint *hint = (GSignalInvocationHint*) invocation_hint;
 
         g_critical("Attempting to call back into JSAPI during the sweeping phase of GC. "
diff --git a/gjs-srcs.mk b/gjs-srcs.mk
index 9cdd5cc4..8c69355a 100644
--- a/gjs-srcs.mk
+++ b/gjs-srcs.mk
@@ -54,6 +54,8 @@ gjs_srcs =				\
 	cjs/context-private.h		\
 	cjs/coverage-internal.h		\
 	cjs/coverage.cpp 		\
+	cjs/engine.cpp			\
+	cjs/engine.h			\
 	cjs/global.cpp			\
 	cjs/global.h		  \
 	cjs/importer.cpp		\
@@ -77,8 +79,6 @@ gjs_srcs =				\
 	cjs/module.cpp			\
 	cjs/native.cpp			\
 	cjs/native.h			\
-	cjs/runtime.cpp			\
-	cjs/runtime.h			\
 	cjs/stack.cpp			\
 	modules/modules.cpp		\
 	modules/modules.h		\

From d2670a27e5583614389994ceb7804af03965d562 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 2 May 2017 22:06:58 -0700
Subject: [PATCH 068/154] js: Adapt to misc API changes in SpiderMonkey 52

- JS::InitSelfHostedCode() is now required to be called before the first
  global object is created.
- js::GCMethods<T>::initial was moved from the friend API to the public
  API and renamed JS::GCPolicy<T>::initial.
- JSPropertyDescriptor was renamed JS::PropertyDescriptor.
- JS::CloneAndExecuteScript() now takes a return value parameter, even
  though we don't use it in this case.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/coverage.cpp      | 3 ++-
 cjs/engine.cpp        | 3 +++
 cjs/importer.cpp      | 2 +-
 cjs/jsapi-util-root.h | 4 ++--
 4 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/cjs/coverage.cpp b/cjs/coverage.cpp
index cafbbab7..b2861ee7 100644
--- a/cjs/coverage.cpp
+++ b/cjs/coverage.cpp
@@ -1302,7 +1302,8 @@ gjs_context_eval_file_in_compartment(GjsContext      *context,
                      &compiled_script))
         return false;
 
-    if (!JS::CloneAndExecuteScript(js_context, compiled_script)) {
+    JS::RootedValue dummy_rval(js_context);
+    if (!JS::CloneAndExecuteScript(js_context, compiled_script, &dummy_rval)) {
         g_free(script);
         gjs_log_exception(js_context);
         g_set_error(error, GJS_ERROR, GJS_ERROR_FAILED, "Failed to evaluate %s", filename);
diff --git a/cjs/engine.cpp b/cjs/engine.cpp
index 9676166f..30aaeef7 100644
--- a/cjs/engine.cpp
+++ b/cjs/engine.cpp
@@ -265,6 +265,9 @@ gjs_create_js_context(GjsContext *js_context)
     if (!cx)
         return nullptr;
 
+    if (!JS::InitSelfHostedCode(cx))
+        return nullptr;
+
     // commented are defaults in moz-24
     JS_SetNativeStackQuota(cx, 1024 * 1024);
     JS_SetGCParameter(cx, JSGC_MAX_MALLOC_BYTES, 128 * 1024 * 1024);
diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index 1ecf2379..e7da12ab 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -196,7 +196,7 @@ seal_import(JSContext       *cx,
             JS::HandleId     id,
             const char      *name)
 {
-    JS::Rooted<JSPropertyDescriptor> descr(cx);
+    JS::Rooted<JS::PropertyDescriptor> descr(cx);
 
     if (!JS_GetOwnPropertyDescriptorById(cx, obj, id, &descr) ||
         descr.object() == NULL) {
diff --git a/cjs/jsapi-util-root.h b/cjs/jsapi-util-root.h
index f4caaba2..c80e758d 100644
--- a/cjs/jsapi-util-root.h
+++ b/cjs/jsapi-util-root.h
@@ -217,7 +217,7 @@ class GjsMaybeOwned {
     {
         debug("root()");
         g_assert(!m_rooted);
-        g_assert(m_heap.get() == js::GCMethods<T>::initial());
+        g_assert(m_heap.get() == JS::GCPolicy<T>::initial());
         m_rooted = true;
         m_cx = cx;
         m_notify = notify;
@@ -244,7 +244,7 @@ class GjsMaybeOwned {
     {
         debug("reset()");
         if (!m_rooted) {
-            m_heap = js::GCMethods<T>::initial();
+            m_heap = JS::GCPolicy<T>::initial();
             return;
         }
 

From 5e5a9a1d0501f4d4cc16dacf7517ac7e0ae598da Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 4 Jun 2017 16:13:53 -0400
Subject: [PATCH 069/154] js: Unbarriered read while in weak ptr callback

Inside the weak pointer callback, we only need to compare the pointer to
nullptr. Since we don't actually use the pointer's location, no read
barrier is needed.

Previously this was not a problem, but SpiderMonkey 52 now asserts that
the heap is not active when exposing a pointer to active JS through a
read barrier, so the weak pointer callback will crash if we try to use a
read barrier.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/jsapi-util-root.h | 12 +++++++++++-
 gi/closure.cpp        |  8 ++++----
 gi/gtype.cpp          |  5 ++++-
 3 files changed, 19 insertions(+), 6 deletions(-)

diff --git a/cjs/jsapi-util-root.h b/cjs/jsapi-util-root.h
index c80e758d..31601441 100644
--- a/cjs/jsapi-util-root.h
+++ b/cjs/jsapi-util-root.h
@@ -75,7 +75,7 @@ struct GjsHeapOperation<JSObject *> {
     update_after_gc(JS::Heap<JSObject *> *location)
     {
         JS_UpdateWeakPointerAfterGC(location);
-        return (*location == nullptr);
+        return (location->unbarrieredGet() == nullptr);
     }
 };
 
@@ -197,6 +197,16 @@ class GjsMaybeOwned {
     }
     inline bool operator!=(const T& other) const { return !(*this == other); }
 
+    /* We can access the pointer without a read barrier if the only thing we
+     * are doing with it is comparing it to nullptr. */
+    bool
+    operator==(std::nullptr_t) const
+    {
+        if (m_rooted)
+            return m_root->get() == nullptr;
+        return m_heap.unbarrieredGet() == nullptr;
+    }
+
     /* You can get a Handle<T> if the thing is rooted, so that you can use this
      * wrapper with stack rooting. However, you must not do this if the
      * JSContext can be destroyed while the Handle is live. */
diff --git a/gi/closure.cpp b/gi/closure.cpp
index 0047441a..d2780d71 100644
--- a/gi/closure.cpp
+++ b/gi/closure.cpp
@@ -86,7 +86,7 @@ invalidate_js_pointers(GjsClosure *gc)
 
     c = &gc->priv;
 
-    if (c->obj == NULL)
+    if (c->obj == nullptr)
         return;
 
     c->obj.reset();
@@ -139,7 +139,7 @@ closure_invalidated(gpointer data,
     gjs_debug_closure("Invalidating closure %p which calls object %p",
                       closure, c->obj.get());
 
-    if (c->obj == NULL) {
+    if (c->obj == nullptr) {
         gjs_debug_closure("   (closure %p already dead, nothing to do)",
                           closure);
         return;
@@ -192,7 +192,7 @@ gjs_closure_invoke(GClosure                   *closure,
 
     c = &((GjsClosure*) closure)->priv;
 
-    if (c->obj == NULL) {
+    if (c->obj == nullptr) {
         /* We were destroyed; become a no-op */
         c->context = NULL;
         return;
@@ -272,7 +272,7 @@ gjs_closure_trace(GClosure *closure,
 
     c = &((GjsClosure*) closure)->priv;
 
-    if (c->obj == NULL)
+    if (c->obj == nullptr)
         return;
 
     c->obj.trace(tracer, "signal connection");
diff --git a/gi/gtype.cpp b/gi/gtype.cpp
index 5a27ce94..d762a09e 100644
--- a/gi/gtype.cpp
+++ b/gi/gtype.cpp
@@ -65,7 +65,10 @@ update_gtype_weak_pointers(JSContext     *cx,
     for (auto iter = weak_pointer_list.begin(); iter != weak_pointer_list.end(); ) {
         auto heap_wrapper = static_cast<JS::Heap<JSObject *> *>(g_type_get_qdata(*iter, gjs_get_gtype_wrapper_quark()));
         JS_UpdateWeakPointerAfterGC(heap_wrapper);
-        if (*heap_wrapper == nullptr)
+
+        /* No read barriers are needed if the only thing we are doing with the
+         * pointer is comparing it to nullptr. */
+        if (heap_wrapper->unbarrieredGet() == nullptr)
             iter = weak_pointer_list.erase(iter);
         else
             iter++;

From 6e9c287c93b50e9b0a57406cc2fa217ff341d7eb Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 22:36:52 -0500
Subject: [PATCH 070/154] docs: Overview of SpiderMonkey 52 features in NEWS

Distilled from Mozilla's documentation.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 NEWS | 186 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 186 insertions(+)

diff --git a/NEWS b/NEWS
index 766e4a08..44a5e74e 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,189 @@
+NEXT
+----
+
+- New JavaScript features! This version of GJS is based on SpiderMonkey 52, an
+  upgrade from the previous ESR (Extended Support Release) of SpiderMonkey 38.
+  GJS now uses the latest ESR in its engine and the plan is to upgrade again
+  when SpiderMonkey 59 is released in March 2018, pending maintainer
+  availability. Here are the highlights of the new JavaScript features.
+  For more information, look them up on MDN or devdocs.io.
+
+  * New language features
+    + ES6 classes
+    + Async functions and await operator
+    + Reflect - built-in object with methods for interceptable operations
+
+  * New syntax
+    + Exponentiation operator: `**`
+    + Variable-length Unicode code point escapes: `"\u{1f369}"`
+    + Destructured default arguments: `function f([x, y]=[1, 2], {z: z}={z: 3})`
+    + Destructured rest parameters: `function f(...[a, b, c])`
+    + `new.target` allows a constructor access to the original constructor that
+      was invoked
+    + Unicode (u) flag for regular expressions, and corresponding RegExp.unicode
+      property
+    + Trailing comma in function parameter lists now allowed
+
+  * New APIs
+    + New Array, String, and TypedArray method: includes()
+    + TypedArray sort(), toLocaleString(), and toString() methods, to correspond
+      with regular arrays
+    + New Object.getOwnPropertyDescriptors() and Object.values() methods
+    + New Proxy traps: getPrototypeOf() and setPrototypeOf()
+    + [Symbol.toPrimitive] property specifying how to convert an object to a
+      primitive value
+    + [Symbol.species] property allowing to override the default constructor
+      for objects
+    + [Symbol.match], [Symbol.replace], [Symbol.search], and [Symbol.split]
+      properties allowing to customize matching behaviour in RegExp subclasses
+    + [Symbol.hasInstance] property allowing to customize the behaviour of
+      the instanceof operator for objects
+    + [Symbol.toStringTag] property allowing to customize the message printed
+      by Object.toString() without overriding it
+    + [Symbol.isConcatSpreadable] property allowing to control the behaviour of
+      an array subclass in an argument list to Array.concat()
+    + [Symbol.unscopables] property allowing to control which object properties
+      are lifted into the scope of a with statement
+    + New Intl.getCanonicalLocales() method
+    + Date.toString() and RegExp.toString() generic methods
+    + Typed arrays can now be constructed from any iterable object
+    + Array.toLocaleString() gained optional locales and options arguments, to
+      correspond with other toLocaleString() methods
+
+  * New behaviour
+    + The "arguments" object is now iterable
+    + Date.prototype, WeakMap.prototype, and WeakSet.prototype are now ordinary
+      objects, not instances
+    + Full ES6-compliant implementation of let keyword
+    + RegExp.sticky ('y' flag) behaviour is ES6 standard, it used to be subject
+      to a long-standing bug in Firefox
+    + RegExp constructor with RegExp first argument and flags no longer throws
+      an exception (`new RegExp(/ab+c/, 'i')` works now)
+    + Generators are no longer constructible, as per ES6 (`function* f {}`
+      followed by `new f` will not work)
+    + It is now required to construct ArrayBuffer, TypedArray, Map, Set, and
+      WeakMap with the new operator
+    + Block-level functions (e.g. `{ function foo() {} }`) are now allowed in
+      strict mode; they are scoped to their block
+    + The options.timeZone argument to Date.toLocaleDateString(),
+      Date.toLocaleString(), Date.toLocaleTimeString(), and the constructor of
+      Intl.DateTimeFormat now understands IANA time zone names (such as
+      "America/Vancouver")
+
+  * Backwards-incompatible changes
+    + Non-standard "let expressions" and "let blocks" (e.g.,
+      `let (x = 5) { use(x) }`) are not supported any longer
+    + Non-standard flags argument to String.match(), String.replace(), and
+      String.search() (e.g. `str.replace('foo', 'bar', 'g')`) is now ignored
+    + Non-standard WeakSet.clear() method has been removed
+    + Variables declared with let and const are now 'global lexical bindings',
+      as per the ES6 standard, meaning that they will not be exported in
+      modules. We are maintaining the old behaviour for the time being as a
+      compatibility workaround, but please change "let" or "const" to "var"
+      inside your module file. A warning will remind you of this. For more
+      information, read:
+      https://blog.mozilla.org/addons/2015/10/14/breaking-changes-let-const-firefox-nightly-44/
+
+  * Experimental features (may change in future versions)
+    + String.padEnd(), String.padStart() methods (proposed in ES2017)
+    + Intl.DateTimeFormat.formatToParts() method (proposed in ES2017)
+    + Object.entries() method (proposed in ES2017)
+    + Atomics, SharedArrayBuffer, and WebAssembly are disabled by default, but
+      can be enabled if you compile mozjs yourself
+
+Version 1.49.3
+--------------
+
+- This will be the last release using SpiderMonkey 38.
+- Fixes in preparation for SpiderMonkey 52 [Philip Chimento]
+- Use the Centricular fork of libffi to build on Windows [Chun-wei Fan]
+
+- Closed bugs:
+
+  * [RFC] Use a C++ auto pointer instead of g_autofree [#777597, Chun-wei Fan,
+    Daniel Boles, Philip Chimento]
+  * Build failure in GNOME Continuous [#783031, Chun-wei Fan]
+
+Version 1.48.4
+--------------
+
+- Closed bugs:
+
+  * gnome-shell 3.24.1 crash on wayland [#781799, Philip Chimento]; thanks to
+    everyone who contributed clues
+
+Version 1.49.2
+--------------
+
+- New feature: When building an app with the Package module, using the Meson
+  build system, you can now run the app with "ninja run" and all the paths will
+  be set up correctly.
+
+- New feature: Gio.ListStore is now iterable.
+
+- New API: Package.requireSymbol(), a companion for the already existing
+  Package.require(), that not only checks for a GIR library but also for a
+  symbol defined in that library.
+
+- New API: Package.checkSymbol(), similar to Package.requireSymbol() but does
+  not exit if the symbol was not found. Use this to support older versions of
+  a GIR library with fallback functionality.
+
+- New API: System.dumpHeap(), for debugging only. Prints the state of the JS
+  engine's heap to standard output. Takes an optional filename parameter which
+  will dump to a file instead if given.
+
+- Closed bugs:
+
+  * Make gjs build on Windows/Visual Studio [#775868, Chun-wei Fan]
+  * Bring back fancy error reporter in gjs-console [#781882, Philip Chimento]
+  * Add Meson running from source support to package.js [#781882, Patrick
+    Griffis]
+  * package: Fix initSubmodule() when running from source in Meson [#782065,
+    Patrick Griffis]
+  * package: Set GSETTINGS_SCHEMA_DIR when ran from source [#782069, Patrick
+    Griffis]
+  * Add imports.gi.has() to check for symbol availability [#779593, Florian
+    Müllner]
+  * overrides: Implement Gio.ListStore[Symbol.iterator] [#782310, Patrick
+    Griffis]
+  * tweener: Explicitly check for undefined properties [#781219, Debarshi Ray,
+    Philip Chimento]
+  * Add a way to dump the heap [#780106, Juan Pablo Ugarte]
+
+- Fixes in preparation for SpiderMonkey 52 [Philip Chimento]
+- Misc fixes [Philip Chimento]
+
+Version 1.48.3
+--------------
+
+- Closed bugs:
+
+  * arg: don't crash when asked to convert a null strv to an array [#775679,
+    Cosimo Cecchi, Sam Spilsbury]
+  * gjs 1.48.0: does not compile on macOS with clang [#780350, Tom Schoonjans,
+    Philip Chimento]
+  * Modernize shell scripts [#781806, Claudio André]
+
+Version 1.49.1
+--------------
+
+- Closed bugs:
+
+  * test GObject Class failure [#693676, Stef Walter]
+  * Enable incremental GCs [#724797, Giovanni Campagna]
+  * Don't silently accept extra arguments to C functions [#680215, Jasper
+    St. Pierre, Philip Chimento]
+  * Special case GValues in signals and properties [#688128, Giovanni Campagna,
+    Philip Chimento]
+  * [cairo] Instantiate wrappers properly [#614413, Philip Chimento,
+    Johan Dahlin]
+  * Warn if we're importing an unversioned namespace [#689654, Colin Walters,
+    Philip Chimento]
+
+- Fixes in preparation for SpiderMonkey 45 [Philip Chimento]
+- Misc fixes [Philip Chimento, Chun-wei Fan, Dan Winship]
+
 Version 1.48.2
 --------------
 

From b3a9b153b365d07a78bf4430efaf7f6e7764a893 Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 22:42:37 -0500
Subject: [PATCH 071/154] GjsAutoChar: Add a proper operator= (const char*)

Assignment from const char* is a valid thing to do, so long as we copy
it and manage the copy.

https://bugzilla.gnome.org/show_bug.cgi?id=777597

https://github.com/GNOME/gjs/commit/2ff21f1cc69285596ca2b03b4e5f8569c1aa59dc
---
 cjs/jsapi-util.h | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/cjs/jsapi-util.h b/cjs/jsapi-util.h
index 8b276a66..1b076019 100644
--- a/cjs/jsapi-util.h
+++ b/cjs/jsapi-util.h
@@ -43,6 +43,10 @@ class GjsAutoChar : public std::unique_ptr<char, decltype(&g_free)> {
     void operator= (char *str) {
         reset(str);
     }
+
+    void operator= (const char *str) {
+        reset(g_strdup(str));
+    }
 };
 
 template <typename T>

From fa32732a73ee4e9fa6bf3b67dcc2b0bcc26950c4 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sat, 24 Jun 2017 22:28:32 -0700
Subject: [PATCH 072/154] js: Allow access to modules' lexical scope

For compatibility with pre-ES6 code, we allow imported modules to access
members of the lexical scope (i.e. variables defined with 'const' or
'let') as if they were properties, because that is how SpiderMonkey
previously implemented 'let' and 'const'.

When such properties are accessed, however, we log a warning that tells
people to fix their code. Hopefully such uses will become rare and we can
remove this compatibility workaround.

https://bugzilla.gnome.org/show_bug.cgi?id=784196
---
 cjs/module.cpp                     | 49 +++++++++++++++++++++++++++++++++++++-
 installed-tests/js/testImporter.js | 17 +++++++++++++
 2 files changed, 65 insertions(+), 1 deletion(-)

diff --git a/cjs/module.cpp b/cjs/module.cpp
index 5028d06f..6b03c967 100644
--- a/cjs/module.cpp
+++ b/cjs/module.cpp
@@ -138,6 +138,53 @@ class GjsModule {
 
     /* JSClass operations */
 
+    bool
+    resolve_impl(JSContext       *cx,
+                 JS::HandleObject module,
+                 JS::HandleId     id,
+                 bool            *resolved)
+    {
+        JS::RootedObject lexical(cx, JS_ExtensibleLexicalEnvironment(module));
+        if (!lexical) {
+            *resolved = false;
+            return true;  /* nothing imported yet */
+        }
+
+        if (!JS_HasPropertyById(cx, lexical, id, resolved))
+            return false;
+        if (!*resolved)
+            return true;
+
+        /* The property is present in the lexical environment. This should not
+         * be supported according to ES6. For compatibility with earlier GJS,
+         * we treat it as if it were a real property, but warn about it. */
+
+        GjsAutoJSChar prop_name(cx);
+        if (!gjs_get_string_id(cx, id, &prop_name))
+            return false;
+
+        g_warning("Some code accessed the property '%s' on the module '%s'. "
+                  "That property was defined with 'let' or 'const' inside the "
+                  "module. This was previously supported, but is not correct "
+                  "according to the ES6 standard. Any symbols to be exported "
+                  "from a module must be defined with 'var'. The property "
+                  "access will work as previously for the time being, but "
+                  "please fix your code anyway.", prop_name.get(), m_name);
+
+        JS::Rooted<JS::PropertyDescriptor> desc(cx);
+        return JS_GetPropertyDescriptorById(cx, lexical, id, &desc) &&
+            JS_DefinePropertyById(cx, module, id, desc);
+    }
+
+    static bool
+    resolve(JSContext       *cx,
+            JS::HandleObject module,
+            JS::HandleId     id,
+            bool            *resolved)
+    {
+        return priv(module)->resolve_impl(cx, module, id, resolved);
+    }
+
     static void
     finalize(JSFreeOp *op,
              JSObject *module)
@@ -151,7 +198,7 @@ class GjsModule {
         nullptr,  /* getProperty */
         nullptr,  /* setProperty */
         nullptr,  /* enumerate */
-        nullptr,  /* resolve */
+        &GjsModule::resolve,
         nullptr,  /* mayResolve */
         &GjsModule::finalize,
     };
diff --git a/installed-tests/js/testImporter.js b/installed-tests/js/testImporter.js
index 35879b1a..e2165619 100644
--- a/installed-tests/js/testImporter.js
+++ b/installed-tests/js/testImporter.js
@@ -164,6 +164,23 @@ describe('Importer', function () {
             LexicalScope = imports.lexicalScope;
         });
 
+        it('will log a compatibility warning when accessed', function () {
+            const GLib = imports.gi.GLib;
+            GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+                "Some code accessed the property 'b' on the module " +
+                "'lexicalScope'.*");
+            GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+                "Some code accessed the property 'c' on the module " +
+                "'lexicalScope'.*");
+
+            void LexicalScope.b;
+            void LexicalScope.c;
+
+            // g_test_assert_expected_messages() is a macro, not introspectable
+            GLib.test_assert_expected_messages_internal('Gjs',
+                'testImporter.js', 179, '');
+        });
+
         it('can be accessed', function () {
             expect(LexicalScope.a).toEqual(1);
             expect(LexicalScope.b).toEqual(2);

From 5dc358a04293e99c5a6b5ef930d2b83fbf09b95c Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Mon, 17 Jul 2017 16:56:25 -0700
Subject: [PATCH 073/154] tests: Re-enable JIT

Whatever long-standing JIT bug was causing the leak here, it has been
fixed in SpiderMonkey 52.

https://bugzilla.gnome.org/show_bug.cgi?id=616193
---
 installed-tests/minijasmine.cpp | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/installed-tests/minijasmine.cpp b/installed-tests/minijasmine.cpp
index 40225540..dfeefc76 100644
--- a/installed-tests/minijasmine.cpp
+++ b/installed-tests/minijasmine.cpp
@@ -49,11 +49,6 @@ main(int argc, char **argv)
     if (argc < 2)
         g_error("Need a test file");
 
-    /* The tests are known to fail in the presence of the JIT;
-     * we leak objects.
-     * https://bugzilla.gnome.org/show_bug.cgi?id=616193
-     */
-    g_setenv("GJS_DISABLE_JIT", "1", false);
     /* The fact that this isn't the default is kind of lame... */
     g_setenv("GJS_DEBUG_OUTPUT", "stderr", false);
     /* Jasmine library has some code style nits that trip this */

From f2afff74ab505d7c4e8e0054fd42172783066c29 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Mon, 17 Jul 2017 17:04:08 -0700
Subject: [PATCH 074/154] release: Include NEWS from 1.48.5

---
 NEWS | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/NEWS b/NEWS
index 44a5e74e..66906f57 100644
--- a/NEWS
+++ b/NEWS
@@ -91,6 +91,17 @@ NEXT
     + Atomics, SharedArrayBuffer, and WebAssembly are disabled by default, but
       can be enabled if you compile mozjs yourself
 
+Version 1.48.5
+--------------
+
+- Closed bugs:
+
+  * GJS crash in needsPostBarrier, possible access from wrong thread [#783935,
+    Philip Chimento]
+
+- Fix format string, caught by static analysis [Claudio André]
+- Fixes for regression in 1.48.4 [Philip Chimento]
+
 Version 1.49.3
 --------------
 

From e939cb26428dd32cf2064d0cfd9543064adaa61e Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Mon, 17 Jul 2017 17:10:40 -0700
Subject: [PATCH 075/154] release: Prepare for 1.49.4

---
 NEWS | 12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

diff --git a/NEWS b/NEWS
index 66906f57..26664279 100644
--- a/NEWS
+++ b/NEWS
@@ -1,5 +1,5 @@
-NEXT
-----
+Version 1.49.4
+--------------
 
 - New JavaScript features! This version of GJS is based on SpiderMonkey 52, an
   upgrade from the previous ESR (Extended Support Release) of SpiderMonkey 38.
@@ -91,6 +91,14 @@ NEXT
     + Atomics, SharedArrayBuffer, and WebAssembly are disabled by default, but
       can be enabled if you compile mozjs yourself
 
+- Closed bugs:
+
+  * Prepare for SpiderMonkey 45 and 52 [#781429, Philip Chimento]
+  * Add a static analysis tool as a make target [#783214, Claudio André]
+  * Fix the build with debug logs enabled [#784469, Tomas Popela]
+  * Switch to SpiderMonkey 52 [#784196, Philip Chimento, Chun-wei Fan]
+  * Test suite fails when run with JIT enabled [#616193, Philip Chimento]
+
 Version 1.48.5
 --------------
 

From 7e71ff1de8fb03521e7b1f6b0fd6dab594891742 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Thu, 13 Jul 2017 10:31:10 -0700
Subject: [PATCH 076/154] build: Use 'always inline' macro in more places

On GCC 4.9, the inliner heuristic starts to complain again, because
SpiderMonkey 52 includes more 'always inline' functions, so when we add
ours in there, the inliner decides that functions are growing too much in
size due to inlined code.

Add a GJS_ALWAYS_INLINE macro just like Mozilla does in their code, and
use it for our templated code and other boilerplate.

https://bugzilla.gnome.org/show_bug.cgi?id=785040
---
 cjs/jsapi-class.h     |  4 +++-
 cjs/jsapi-util-args.h | 29 ++++++++++++-----------------
 cjs/jsapi-util.h      |  6 ++++++
 3 files changed, 21 insertions(+), 18 deletions(-)

diff --git a/cjs/jsapi-class.h b/cjs/jsapi-class.h
index 29c44bee..508c828e 100644
--- a/cjs/jsapi-class.h
+++ b/cjs/jsapi-class.h
@@ -69,13 +69,15 @@ JSObject *gjs_construct_object_dynamic(JSContext                  *cx,
  *                              do_base_typecheck and priv_from_js
  */
 #define GJS_DEFINE_PRIV_FROM_JS(type, klass)                          \
-    G_GNUC_UNUSED static inline bool                                    \
+    GJS_ALWAYS_INLINE G_GNUC_UNUSED                                     \
+    static inline bool                                                  \
     do_base_typecheck(JSContext       *context,                         \
                       JS::HandleObject object,                          \
                       bool             throw_error)                     \
     {                                                                   \
         return gjs_typecheck_instance(context, object, &klass, throw_error);  \
     }                                                                   \
+    GJS_ALWAYS_INLINE                                                   \
     static inline type *                                                \
     priv_from_js(JSContext       *context,                              \
                  JS::HandleObject object)                               \
diff --git a/cjs/jsapi-util-args.h b/cjs/jsapi-util-args.h
index 1fb3ec79..d0baa128 100644
--- a/cjs/jsapi-util-args.h
+++ b/cjs/jsapi-util-args.h
@@ -30,13 +30,7 @@
 #include "jsapi-util.h"
 #include "jsapi-wrapper.h"
 
-#ifdef __GNUC__
-#define GNUC_ALWAYS_INLINE __attribute__((always_inline))
-#else
-#define GNUC_ALWAYS_INLINE
-#endif
-
-GNUC_ALWAYS_INLINE
+GJS_ALWAYS_INLINE
 static inline bool
 check_nullable(const char*& fchar,
                const char*& fmt_string)
@@ -53,7 +47,7 @@ check_nullable(const char*& fchar,
 
 /* This preserves the previous behaviour of gjs_parse_args(), but maybe we want
  * to use JS::ToBoolean instead? */
-GNUC_ALWAYS_INLINE
+GJS_ALWAYS_INLINE
 static inline void
 assign(JSContext      *cx,
        char            c,
@@ -72,7 +66,7 @@ assign(JSContext      *cx,
 
 /* This preserves the previous behaviour of gjs_parse_args(), but maybe we want
  * to box primitive types instead of throwing? */
-GNUC_ALWAYS_INLINE
+GJS_ALWAYS_INLINE
 static inline void
 assign(JSContext              *cx,
        char                    c,
@@ -91,7 +85,7 @@ assign(JSContext              *cx,
     ref.set(&value.toObject());
 }
 
-GNUC_ALWAYS_INLINE
+GJS_ALWAYS_INLINE
 static inline void
 assign(JSContext      *cx,
        char            c,
@@ -118,7 +112,8 @@ assign(JSContext      *cx,
 
     *ref = tmp_ref.copy();
 }
-GNUC_ALWAYS_INLINE
+
+GJS_ALWAYS_INLINE
 static inline void
 assign(JSContext      *cx,
        char            c,
@@ -134,7 +129,7 @@ assign(JSContext      *cx,
         throw g_strdup("Couldn't convert to integer");
 }
 
-GNUC_ALWAYS_INLINE
+GJS_ALWAYS_INLINE
 static inline void
 assign(JSContext      *cx,
        char            c,
@@ -155,7 +150,7 @@ assign(JSContext      *cx,
     *ref = num;
 }
 
-GNUC_ALWAYS_INLINE
+GJS_ALWAYS_INLINE
 static inline void
 assign(JSContext      *cx,
        char            c,
@@ -171,7 +166,7 @@ assign(JSContext      *cx,
         throw g_strdup("Couldn't convert to 64-bit integer");
 }
 
-GNUC_ALWAYS_INLINE
+GJS_ALWAYS_INLINE
 static inline void
 assign(JSContext      *cx,
        char            c,
@@ -191,7 +186,7 @@ assign(JSContext      *cx,
  * prevent instantiation for any other types besides pointer-to-enum */
 template<typename T,
          typename std::enable_if<std::is_enum<T>::value, int>::type = 0>
-GNUC_ALWAYS_INLINE
+GJS_ALWAYS_INLINE
 static inline void
 assign(JSContext      *cx,
        char            c,
@@ -217,7 +212,7 @@ template<typename T,
 static inline void
 free_if_necessary(T param_ref) {}
 
-GNUC_ALWAYS_INLINE
+GJS_ALWAYS_INLINE
 static inline void
 free_if_necessary(JS::MutableHandleObject param_ref)
 {
@@ -227,7 +222,7 @@ free_if_necessary(JS::MutableHandleObject param_ref)
     param_ref.set(NULL);
 }
 
-GNUC_ALWAYS_INLINE
+GJS_ALWAYS_INLINE
 static inline void
 free_if_necessary(char **param_ref)
 {
diff --git a/cjs/jsapi-util.h b/cjs/jsapi-util.h
index 1b076019..e30c7428 100644
--- a/cjs/jsapi-util.h
+++ b/cjs/jsapi-util.h
@@ -32,6 +32,12 @@
 #include "jsapi-wrapper.h"
 #include "gi/gtype.h"
 
+#ifdef __GNUC__
+#define GJS_ALWAYS_INLINE __attribute__((always_inline))
+#else
+#define GJS_ALWAYS_INLINE
+#endif
+
 class GjsAutoChar : public std::unique_ptr<char, decltype(&g_free)> {
 public:
     GjsAutoChar(char *str = nullptr) : unique_ptr(str, g_free) {}

From f7fff1717863bb22c094ed9fef3e773155b09426 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Thu, 13 Jul 2017 10:43:45 -0700
Subject: [PATCH 077/154] js: Use correct autoptr in gjs_string_to_filename()

The return value of g_filename_from_utf8() (must be freed with g_free())
was getting assigned to a GjsAutoJSChar (which would be freed with
JS_free()). Instead gjs_string_to_filename() must have a GjsAutoChar
output parameter.

This requires changing gjs_parse_call_args() as well. We improve it by
allowing to pass in autoptrs for 's' or 'F' args instead of char**.

Fixes a few minor memory leaks, mostly in error paths in Cairo functions.

https://bugzilla.gnome.org/show_bug.cgi?id=785040
---
 cjs/coverage.cpp                |  7 ++----
 cjs/jsapi-util-args.h           | 45 ++++++++++++++++++-----------------
 cjs/jsapi-util-string.cpp       |  8 +++----
 cjs/jsapi-util.h                |  7 +++---
 cjs/stack.cpp                   |  2 +-
 gi/arg.cpp                      | 43 ++++++++++++++++++++--------------
 gi/object.cpp                   | 39 +++++++++++--------------------
 modules/cairo-context.cpp       |  6 ++---
 modules/cairo-image-surface.cpp |  4 ++--
 modules/cairo-pdf-surface.cpp   |  7 ++----
 modules/cairo-ps-surface.cpp    |  7 ++----
 modules/cairo-surface.cpp       |  8 +++----
 modules/cairo-svg-surface.cpp   |  7 ++----
 modules/system.cpp              |  3 +--
 test/gjs-test-call-args.cpp     | 52 +++++++++++++++++++++++------------------
 15 files changed, 114 insertions(+), 131 deletions(-)

diff --git a/cjs/coverage.cpp b/cjs/coverage.cpp
index b2861ee7..3e8c51af 100644
--- a/cjs/coverage.cpp
+++ b/cjs/coverage.cpp
@@ -1363,17 +1363,14 @@ coverage_log(JSContext *context,
 static GFile *
 get_file_from_call_args_filename(JSContext    *context,
                                  JS::CallArgs &args) {
-    char *filename = NULL;
+    GjsAutoJSChar filename(context);
 
     if (!gjs_parse_call_args(context, "getFileContents", args, "s",
                              "filename", &filename))
         return NULL;
 
     /* path could be a resource, so use g_file_new_for_commandline_arg. */
-    GFile *file = g_file_new_for_commandline_arg(filename);
-
-    g_free(filename);
-    return file;
+    return g_file_new_for_commandline_arg(filename);
 }
 
 static bool
diff --git a/cjs/jsapi-util-args.h b/cjs/jsapi-util-args.h
index d0baa128..520ac8f6 100644
--- a/cjs/jsapi-util-args.h
+++ b/cjs/jsapi-util-args.h
@@ -91,26 +91,34 @@ assign(JSContext      *cx,
        char            c,
        bool            nullable,
        JS::HandleValue value,
-       char          **ref)
+       GjsAutoJSChar  *ref)
 {
-    if (nullable && (c == 's' || c == 'F') && value.isNull()) {
-        *ref = NULL;
+    if (c != 's')
+        throw g_strdup_printf("Wrong type for %c, got GjsAutoJSChar*", c);
+    if (nullable && value.isNull()) {
+        ref->reset(cx, nullptr);
         return;
     }
+    if (!gjs_string_to_utf8(cx, value, ref))
+        throw g_strdup("Couldn't convert to string");
+}
 
-    GjsAutoJSChar tmp_ref(cx);
-
-    if (c == 's') {
-        if (!gjs_string_to_utf8(cx, value, &tmp_ref))
-            throw g_strdup("Couldn't convert to string");
-    } else if (c == 'F') {
-        if (!gjs_string_to_filename(cx, value, &tmp_ref))
-            throw g_strdup("Couldn't convert to filename");
-    } else {
-        throw g_strdup_printf("Wrong type for %c, got char**", c);
+GJS_ALWAYS_INLINE
+static inline void
+assign(JSContext      *cx,
+       char            c,
+       bool            nullable,
+       JS::HandleValue value,
+       GjsAutoChar    *ref)
+{
+    if (c != 'F')
+        throw g_strdup_printf("Wrong type for %c, got GjsAutoChar*", c);
+    if (nullable && value.isNull()) {
+        ref->release();
+        return;
     }
-
-    *ref = tmp_ref.copy();
+    if (!gjs_string_to_filename(cx, value, ref))
+        throw g_strdup("Couldn't convert to filename");
 }
 
 GJS_ALWAYS_INLINE
@@ -222,13 +230,6 @@ free_if_necessary(JS::MutableHandleObject param_ref)
     param_ref.set(NULL);
 }
 
-GJS_ALWAYS_INLINE
-static inline void
-free_if_necessary(char **param_ref)
-{
-    g_free(*param_ref);
-}
-
 template<typename T>
 static bool
 parse_call_args_helper(JSContext    *cx,
diff --git a/cjs/jsapi-util-string.cpp b/cjs/jsapi-util-string.cpp
index bc8cb740..53f32f5e 100644
--- a/cjs/jsapi-util-string.cpp
+++ b/cjs/jsapi-util-string.cpp
@@ -93,11 +93,10 @@ gjs_string_from_utf8(JSContext             *context,
 bool
 gjs_string_to_filename(JSContext      *context,
                        const JS::Value filename_val,
-                       GjsAutoJSChar  *filename_string_p)
+                       GjsAutoChar    *filename_string)
 {
     GError *error;
     GjsAutoJSChar tmp(context);
-    char *filename_string;
 
     /* gjs_string_to_filename verifies that filename_val is a string */
 
@@ -107,13 +106,12 @@ gjs_string_to_filename(JSContext      *context,
     }
 
     error = NULL;
-    filename_string = g_filename_from_utf8(tmp, -1, NULL, NULL, &error);
-    if (!filename_string) {
+    *filename_string = g_filename_from_utf8(tmp, -1, NULL, NULL, &error);
+    if (!*filename_string) {
         gjs_throw_g_error(context, error);
         return false;
     }
 
-    filename_string_p->reset(context, filename_string);
     return true;
 }
 
diff --git a/cjs/jsapi-util.h b/cjs/jsapi-util.h
index e30c7428..fe5b524f 100644
--- a/cjs/jsapi-util.h
+++ b/cjs/jsapi-util.h
@@ -215,9 +215,10 @@ bool gjs_string_from_utf8(JSContext             *context,
                           ssize_t                n_bytes,
                           JS::MutableHandleValue value_p);
 
-bool        gjs_string_to_filename           (JSContext       *context,
-                                              const JS::Value  string_val,
-                                              GjsAutoJSChar   *filename_string_p);
+bool gjs_string_to_filename(JSContext       *cx,
+                            const JS::Value  string_val,
+                            GjsAutoChar     *filename_string);
+
 bool gjs_string_from_filename(JSContext             *context,
                               const char            *filename_string,
                               ssize_t                n_bytes,
diff --git a/cjs/stack.cpp b/cjs/stack.cpp
index 00963931..2d3a7cb9 100644
--- a/cjs/stack.cpp
+++ b/cjs/stack.cpp
@@ -89,7 +89,7 @@ gjs_context_print_stack_stderr(GjsContext *context)
 {
     JSContext *cx = (JSContext*) gjs_context_get_native_context(context);
     JS::RootedValue v_stack(cx);
-    GjsAutoJSChar stack(cx);
+    GjsAutoChar stack;
 
     g_printerr("== Stack trace for context %p ==\n", context);
 
diff --git a/gi/arg.cpp b/gi/arg.cpp
index b6a59b75..d5aa0c30 100644
--- a/gi/arg.cpp
+++ b/gi/arg.cpp
@@ -414,24 +414,31 @@ value_to_ghashtable_key(JSContext      *cx,
 
 #undef HANDLE_UNSIGNED_INT
 
-#define HANDLE_STRING(type, lctype)                                   \
-    case GI_TYPE_TAG_##type: {                                        \
-        GjsAutoJSChar cstr(cx);                                       \
-        JS::RootedValue str_val(cx, value);                           \
-        if (!str_val.isString()) {                                    \
-            JS::RootedString str(cx, JS::ToString(cx, str_val));      \
-            str_val.setString(str);                                   \
-        }                                                             \
-        if (!gjs_string_to_##lctype(cx, str_val, &cstr))              \
-            return false;                                             \
-        *pointer_out = cstr.copy();                                   \
-        break;                                                        \
+    case GI_TYPE_TAG_FILENAME: {
+        GjsAutoChar cstr;
+        JS::RootedValue str_val(cx, value);
+        if (!str_val.isString()) {
+            JS::RootedString str(cx, JS::ToString(cx, str_val));
+            str_val.setString(str);
+        }
+        if (!gjs_string_to_filename(cx, str_val, &cstr))
+            return false;
+        *pointer_out = cstr.release();
+        break;
     }
 
-    HANDLE_STRING(FILENAME, filename);
-    HANDLE_STRING(UTF8, utf8);
-
-#undef HANDLE_STRING
+    case GI_TYPE_TAG_UTF8: {
+        GjsAutoJSChar cstr(cx);
+        JS::RootedValue str_val(cx, value);
+        if (!str_val.isString()) {
+            JS::RootedString str(cx, JS::ToString(cx, str_val));
+            str_val.setString(str);
+        }
+        if (!gjs_string_to_utf8(cx, str_val, &cstr))
+            return false;
+        *pointer_out = cstr.copy();
+        break;
+    }
 
     case GI_TYPE_TAG_FLOAT:
     case GI_TYPE_TAG_DOUBLE:
@@ -1467,9 +1474,9 @@ gjs_value_to_g_argument(JSContext      *context,
         if (value.isNull()) {
             arg->v_pointer = NULL;
         } else if (value.isString()) {
-            GjsAutoJSChar filename_str(context);
+            GjsAutoChar filename_str;
             if (gjs_string_to_filename(context, value, &filename_str))
-                arg->v_pointer = filename_str.copy();
+                arg->v_pointer = filename_str.release();
             else
                 wrong = true;
         } else {
diff --git a/gi/object.cpp b/gi/object.cpp
index c8f663b7..c5a337b4 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -2107,7 +2107,7 @@ static void
 find_vfunc_info (JSContext *context,
                  GType implementor_gtype,
                  GIBaseInfo *vfunc_info,
-                 gchar *vfunc_name,
+                 const char   *vfunc_name,
                  gpointer *implementor_vtable_ret,
                  GIFieldInfo **field_info_ret)
 {
@@ -2184,7 +2184,7 @@ gjs_hook_up_vfunc(JSContext *cx,
                   JS::Value *vp)
 {
     JS::CallArgs argv = JS::CallArgsFromVp (argc, vp);
-    gchar *name;
+    GjsAutoJSChar name(cx);
     JS::RootedObject object(cx), function(cx);
     ObjectInstance *priv;
     GType gtype, info_gtype;
@@ -2249,9 +2249,8 @@ gjs_hook_up_vfunc(JSContext *cx,
     }
 
     if (!vfunc) {
-        gjs_throw(cx, "Could not find definition of virtual function %s", name);
-
-        g_free(name);
+        gjs_throw(cx, "Could not find definition of virtual function %s",
+                  name.get());
         return false;
     }
 
@@ -2285,7 +2284,6 @@ gjs_hook_up_vfunc(JSContext *cx,
     }
 
     g_base_info_unref(vfunc);
-    g_free(name);
     return true;
 }
 
@@ -2430,7 +2428,7 @@ gjs_override_property(JSContext *cx,
                       JS::Value *vp)
 {
     JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
-    gchar *name = NULL;
+    GjsAutoJSChar name(cx);
     JS::RootedObject type(cx);
     GParamSpec *pspec;
     GParamSpec *new_pspec;
@@ -2443,7 +2441,6 @@ gjs_override_property(JSContext *cx,
 
     if ((gtype = gjs_gtype_get_actual_gtype(cx, type)) == G_TYPE_INVALID) {
         gjs_throw(cx, "Invalid parameter type was not a GType");
-        g_clear_pointer(&name, g_free);
         return false;
     }
 
@@ -2459,14 +2456,12 @@ gjs_override_property(JSContext *cx,
     }
 
     if (pspec == NULL) {
-        gjs_throw(cx, "No such property '%s' to override on type '%s'", name,
-                  g_type_name(gtype));
-        g_clear_pointer(&name, g_free);
+        gjs_throw(cx, "No such property '%s' to override on type '%s'",
+                  name.get(), g_type_name(gtype));
         return false;
     }
 
     new_pspec = g_param_spec_override(name, pspec);
-    g_clear_pointer(&name, g_free);
 
     g_param_spec_set_qdata(new_pspec, gjs_is_custom_property_quark(), GINT_TO_POINTER(1));
 
@@ -2694,7 +2689,7 @@ gjs_register_interface(JSContext *cx,
                        JS::Value *vp)
 {
     JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
-    char *name = NULL;
+    GjsAutoJSChar name(cx);
     guint32 i, n_interfaces, n_properties;
     GType *iface_types;
     GType interface_type;
@@ -2721,29 +2716,23 @@ gjs_register_interface(JSContext *cx,
         return false;
 
     if (!validate_interfaces_and_properties_args(cx, interfaces, properties,
-                                                 &n_interfaces, &n_properties)) {
-        g_clear_pointer(&name, g_free);
+                                                 &n_interfaces, &n_properties))
         return false;
-    }
 
     iface_types = (GType *) g_alloca(sizeof(GType) * n_interfaces);
 
     /* We do interface addition in two passes so that any failure
        is caught early, before registering the GType (which we can't undo) */
-    if (!get_interface_gtypes(cx, interfaces, n_interfaces, iface_types)) {
-        g_clear_pointer(&name, g_free);
+    if (!get_interface_gtypes(cx, interfaces, n_interfaces, iface_types))
         return false;
-    }
 
     if (g_type_from_name(name) != G_TYPE_INVALID) {
-        gjs_throw(cx, "Type name %s is already registered", name);
-        g_clear_pointer(&name, g_free);
+        gjs_throw(cx, "Type name %s is already registered", name.get());
         return false;
     }
 
     interface_type = g_type_register_static(G_TYPE_INTERFACE, name, &type_info,
                                             (GTypeFlags) 0);
-    g_clear_pointer(&name, g_free);
 
     g_type_set_qdata(interface_type, gjs_is_custom_type_quark(), GINT_TO_POINTER(1));
 
@@ -2771,7 +2760,7 @@ gjs_register_type(JSContext *cx,
                   JS::Value *vp)
 {
     JS::CallArgs argv = JS::CallArgsFromVp (argc, vp);
-    gchar *name;
+    GjsAutoJSChar name(cx);
     GType instance_type, parent_type;
     GTypeQuery query;
     ObjectInstance *parent_priv;
@@ -2820,7 +2809,7 @@ gjs_register_type(JSContext *cx,
         return false;
 
     if (g_type_from_name(name) != G_TYPE_INVALID) {
-        gjs_throw (cx, "Type name %s is already registered", name);
+        gjs_throw(cx, "Type name %s is already registered", name.get());
         return false;
     }
 
@@ -2843,8 +2832,6 @@ gjs_register_type(JSContext *cx,
     instance_type = g_type_register_static(parent_type, name, &type_info,
                                            (GTypeFlags) 0);
 
-    g_free(name);
-
     g_type_set_qdata (instance_type, gjs_is_custom_type_quark(), GINT_TO_POINTER (1));
 
     if (!save_properties_for_class_init(cx, properties, n_properties, instance_type))
diff --git a/modules/cairo-context.cpp b/modules/cairo-context.cpp
index e929b162..83bf1226 100644
--- a/modules/cairo-context.cpp
+++ b/modules/cairo-context.cpp
@@ -656,7 +656,7 @@ showText_func(JSContext *context,
               JS::Value *vp)
 {
     GJS_GET_PRIV(context, argc, vp, argv, obj, GjsCairoContext, priv);
-    char *utf8;
+    GjsAutoJSChar utf8(context);
     cairo_t *cr = priv ? priv->cr : NULL;
 
     if (!gjs_parse_call_args(context, "showText", argv, "s",
@@ -664,7 +664,6 @@ showText_func(JSContext *context,
         return false;
 
     cairo_show_text(cr, utf8);
-    g_free(utf8);
 
     if (!gjs_cairo_check_status(context, cairo_status(cr), "context"))
         return false;
@@ -680,7 +679,7 @@ selectFontFace_func(JSContext *context,
                     JS::Value *vp)
 {
     GJS_GET_PRIV(context, argc, vp, argv, obj, GjsCairoContext, priv);
-    char *family;
+    GjsAutoJSChar family(context);
     cairo_font_slant_t slant;
     cairo_font_weight_t weight;
     cairo_t *cr = priv ? priv->cr : NULL;
@@ -692,7 +691,6 @@ selectFontFace_func(JSContext *context,
         return false;
 
     cairo_select_font_face(cr, family, slant, weight);
-    g_free(family);
 
     if (!gjs_cairo_check_status(context, cairo_status(cr), "context"))
         return false;
diff --git a/modules/cairo-image-surface.cpp b/modules/cairo-image-surface.cpp
index 08118c91..8140e30c 100644
--- a/modules/cairo-image-surface.cpp
+++ b/modules/cairo-image-surface.cpp
@@ -79,10 +79,10 @@ createFromPNG_func(JSContext *context,
                    JS::Value *vp)
 {
     JS::CallArgs argv = JS::CallArgsFromVp (argc, vp);
-    char *filename = nullptr;
+    GjsAutoChar filename;
     cairo_surface_t *surface;
 
-    if (!gjs_parse_call_args(context, "createFromPNG", argv, "s",
+    if (!gjs_parse_call_args(context, "createFromPNG", argv, "F",
                              "filename", &filename))
         return false;
 
diff --git a/modules/cairo-pdf-surface.cpp b/modules/cairo-pdf-surface.cpp
index ce58d716..d4f8fb6d 100644
--- a/modules/cairo-pdf-surface.cpp
+++ b/modules/cairo-pdf-surface.cpp
@@ -39,7 +39,7 @@ GJS_DEFINE_PROTO_WITH_PARENT("PDFSurface", cairo_pdf_surface,
 GJS_NATIVE_CONSTRUCTOR_DECLARE(cairo_pdf_surface)
 {
     GJS_NATIVE_CONSTRUCTOR_VARIABLES(cairo_pdf_surface)
-    char *filename = nullptr;
+    GjsAutoChar filename;
     double width, height;
     cairo_surface_t *surface;
 
@@ -54,14 +54,11 @@ GJS_NATIVE_CONSTRUCTOR_DECLARE(cairo_pdf_surface)
     surface = cairo_pdf_surface_create(filename, width, height);
 
     if (!gjs_cairo_check_status(context, cairo_surface_status(surface),
-                                "surface")) {
-        g_free(filename);
+                                "surface"))
         return false;
-    }
 
     gjs_cairo_surface_construct(context, object, surface);
     cairo_surface_destroy(surface);
-    g_free(filename);
 
     GJS_NATIVE_CONSTRUCTOR_FINISH(cairo_pdf_surface);
 
diff --git a/modules/cairo-ps-surface.cpp b/modules/cairo-ps-surface.cpp
index 01a9906d..7818e5e6 100644
--- a/modules/cairo-ps-surface.cpp
+++ b/modules/cairo-ps-surface.cpp
@@ -39,7 +39,7 @@ GJS_DEFINE_PROTO_WITH_PARENT("PSSurface", cairo_ps_surface, cairo_surface,
 GJS_NATIVE_CONSTRUCTOR_DECLARE(cairo_ps_surface)
 {
     GJS_NATIVE_CONSTRUCTOR_VARIABLES(cairo_ps_surface)
-    char *filename = nullptr;
+    GjsAutoChar filename;
     double width, height;
     cairo_surface_t *surface;
 
@@ -54,14 +54,11 @@ GJS_NATIVE_CONSTRUCTOR_DECLARE(cairo_ps_surface)
     surface = cairo_ps_surface_create(filename, width, height);
 
     if (!gjs_cairo_check_status(context, cairo_surface_status(surface),
-                                "surface")) {
-        g_free(filename);
+                                "surface"))
         return false;
-    }
 
     gjs_cairo_surface_construct(context, object, surface);
     cairo_surface_destroy(surface);
-    g_free(filename);
 
     GJS_NATIVE_CONSTRUCTOR_FINISH(cairo_ps_surface);
 
diff --git a/modules/cairo-surface.cpp b/modules/cairo-surface.cpp
index 8154a5da..22c9ef06 100644
--- a/modules/cairo-surface.cpp
+++ b/modules/cairo-surface.cpp
@@ -66,7 +66,7 @@ writeToPNG_func(JSContext *context,
                 JS::Value *vp)
 {
     GJS_GET_THIS(context, argc, vp, argv, obj);
-    char *filename = nullptr;
+    GjsAutoChar filename;
     cairo_surface_t *surface;
 
     if (!gjs_parse_call_args(context, "writeToPNG", argv, "F",
@@ -74,12 +74,10 @@ writeToPNG_func(JSContext *context,
         return false;
 
     surface = gjs_cairo_surface_get_surface(context, obj);
-    if (!surface) {
-        g_free(filename);
+    if (!surface)
         return false;
-    }
+
     cairo_surface_write_to_png(surface, filename);
-    g_free(filename);
     if (!gjs_cairo_check_status(context, cairo_surface_status(surface),
                                 "surface"))
         return false;
diff --git a/modules/cairo-svg-surface.cpp b/modules/cairo-svg-surface.cpp
index dc7ec028..8140ed6b 100644
--- a/modules/cairo-svg-surface.cpp
+++ b/modules/cairo-svg-surface.cpp
@@ -39,7 +39,7 @@ GJS_DEFINE_PROTO_WITH_PARENT("SVGSurface", cairo_svg_surface,
 GJS_NATIVE_CONSTRUCTOR_DECLARE(cairo_svg_surface)
 {
     GJS_NATIVE_CONSTRUCTOR_VARIABLES(cairo_svg_surface)
-    char *filename = nullptr;
+    GjsAutoChar filename;
     double width, height;
     cairo_surface_t *surface;
 
@@ -54,14 +54,11 @@ GJS_NATIVE_CONSTRUCTOR_DECLARE(cairo_svg_surface)
     surface = cairo_svg_surface_create(filename, width, height);
 
     if (!gjs_cairo_check_status(context, cairo_surface_status(surface),
-                                "surface")) {
-        g_free(filename);
+                                "surface"))
         return false;
-    }
 
     gjs_cairo_surface_construct(context, object, surface);
     cairo_surface_destroy(surface);
-    g_free(filename);
 
     GJS_NATIVE_CONSTRUCTOR_FINISH(cairo_svg_surface);
 
diff --git a/modules/system.cpp b/modules/system.cpp
index 240caa06..5759adf6 100644
--- a/modules/system.cpp
+++ b/modules/system.cpp
@@ -105,7 +105,7 @@ gjs_dump_heap(JSContext *cx,
               JS::Value *vp)
 {
     JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
-    char *filename = nullptr;
+    GjsAutoChar filename;
 
     if (!gjs_parse_call_args(cx, "dumpHeap", args, "|F", "filename", &filename))
         return false;
@@ -114,7 +114,6 @@ gjs_dump_heap(JSContext *cx,
         FILE *fp = fopen(filename, "a");
         js::DumpHeap(cx, fp, js::IgnoreNurseryObjects);
         fclose(fp);
-        g_free(filename);
     } else {
         js::DumpHeap(cx, stdout, js::IgnoreNurseryObjects);
     }
diff --git a/test/gjs-test-call-args.cpp b/test/gjs-test-call-args.cpp
index 30df44e4..333d47cd 100644
--- a/test/gjs-test-call-args.cpp
+++ b/test/gjs-test-call-args.cpp
@@ -85,7 +85,8 @@ JSNATIVE_TEST_FUNC_END
 
 JSNATIVE_TEST_FUNC_BEGIN(one_of_each_type)
     bool boolval;
-    char *strval, *fileval;
+    GjsAutoJSChar strval(cx);
+    GjsAutoChar fileval;
     int intval;
     unsigned uintval;
     int64_t int64val;
@@ -108,8 +109,6 @@ JSNATIVE_TEST_FUNC_BEGIN(one_of_each_type)
     g_assert_cmpint(int64val, ==, 1);
     g_assert_cmpfloat(dblval, ==, 1.0);
     g_assert_nonnull(objval);
-    g_free(strval);
-    g_free(fileval);
 JSNATIVE_TEST_FUNC_END
 
 JSNATIVE_TEST_FUNC_BEGIN(optional_args_all)
@@ -156,7 +155,8 @@ JSNATIVE_TEST_FUNC_BEGIN(signed_enum_arg)
 JSNATIVE_TEST_FUNC_END
 
 JSNATIVE_TEST_FUNC_BEGIN(one_of_each_nullable_type)
-    char *strval, *fileval;
+    GjsAutoJSChar strval(cx);
+    GjsAutoChar fileval;
     JS::RootedObject objval(cx);
     retval = gjs_parse_call_args(cx, "oneOfEachNullableType", args, "?s?F?o",
                                  "strval", &strval,
@@ -168,18 +168,14 @@ JSNATIVE_TEST_FUNC_BEGIN(one_of_each_nullable_type)
 JSNATIVE_TEST_FUNC_END
 
 JSNATIVE_TEST_FUNC_BEGIN(unwind_free_test)
-    char *strval, *fileval;
     int intval;
     unsigned uval;
     JS::RootedObject objval(cx);
-    retval = gjs_parse_call_args(cx, "unwindFreeTest", args, "sFoiu",
-                                 "strval", &strval,
-                                 "fileval", &fileval,
+    retval = gjs_parse_call_args(cx, "unwindFreeTest", args, "oiu",
                                  "objval", &objval,
                                  "intval", &intval,
                                  "error", &uval);
     g_assert_null(objval);
-    /* Sadly, we cannot assert that strval and fileval have been freed */
 JSNATIVE_TEST_FUNC_END
 
 #define JSNATIVE_BAD_NULLABLE_TEST_FUNC(type, fmt)                 \
@@ -210,16 +206,22 @@ JSNATIVE_BAD_TYPE_TEST_FUNC(int, "u");
 JSNATIVE_BAD_TYPE_TEST_FUNC(unsigned, "t");
 JSNATIVE_BAD_TYPE_TEST_FUNC(int64_t, "f");
 JSNATIVE_BAD_TYPE_TEST_FUNC(double, "b");
-typedef char *charptr;
-JSNATIVE_BAD_TYPE_TEST_FUNC(charptr, "i");
+JSNATIVE_BAD_TYPE_TEST_FUNC(GjsAutoChar, "i");
 
 #undef JSNATIVE_BAD_TYPE_TEST_FUNC
 
-JSNATIVE_TEST_FUNC_BEGIN(object_invalid_type)
-    JS::RootedObject val(cx);
-    retval = gjs_parse_call_args(cx, "objectInvalidType", args, "i",
-                                 "val", &val);
-JSNATIVE_TEST_FUNC_END
+#define JSNATIVE_CONSTRUCTED_BAD_TYPE_TEST_FUNC(type, ch)                \
+    JSNATIVE_TEST_FUNC_BEGIN(type##_invalid_type)                        \
+        type val(cx);                                                    \
+        retval = gjs_parse_call_args(cx, #type "InvalidType", args, ch,  \
+                                     "val", &val);                       \
+    JSNATIVE_TEST_FUNC_END
+
+using JS::RootedObject;
+JSNATIVE_CONSTRUCTED_BAD_TYPE_TEST_FUNC(GjsAutoJSChar, "i");
+JSNATIVE_CONSTRUCTED_BAD_TYPE_TEST_FUNC(RootedObject, "i");
+
+#undef JSNATIVE_CONSTRUCTED_BAD_TYPE_TEST_FUNC
 
 static JSFunctionSpec native_test_funcs[] = {
     JS_FS("noArgs", no_args, 0, 0),
@@ -247,8 +249,9 @@ static JSFunctionSpec native_test_funcs[] = {
     JS_FS("unsignedInvalidType", unsigned_invalid_type, 0, 0),
     JS_FS("int64_tInvalidType", int64_t_invalid_type, 0, 0),
     JS_FS("doubleInvalidType", double_invalid_type, 0, 0),
-    JS_FS("charptrInvalidType", charptr_invalid_type, 0, 0),
-    JS_FS("objectInvalidType", object_invalid_type, 0, 0),
+    JS_FS("GjsAutoCharInvalidType", GjsAutoChar_invalid_type, 0, 0),
+    JS_FS("GjsAutoJSCharInvalidType", GjsAutoJSChar_invalid_type, 0, 0),
+    JS_FS("RootedObjectInvalidType", RootedObject_invalid_type, 0, 0),
     JS_FS_END
 };
 
@@ -347,7 +350,7 @@ gjs_test_add_tests_for_parse_call_args(void)
     ADD_CALL_ARGS_TEST("passing-all-arguments-when-all-optional",
                        "onlyOptionalArgs(1, 1)");
     ADD_CALL_ARGS_TEST_XFAIL("allocated-args-are-freed-on-error",
-                             "unwindFreeTest('', '', {}, 1, -1)"
+                             "unwindFreeTest({}, 1, -1)"
                              "//*Value * is out of range");
     ADD_CALL_ARGS_TEST_XFAIL("nullable-bool-is-invalid",
                              "boolInvalidNullable(true)"
@@ -379,11 +382,14 @@ gjs_test_add_tests_for_parse_call_args(void)
     ADD_CALL_ARGS_TEST_XFAIL("invalid-double-type",
                              "doubleInvalidType(false)"
                              "//*Wrong type for b, got double?");
-    ADD_CALL_ARGS_TEST_XFAIL("invalid-string-type",
-                             "charptrInvalidType(1)"
-                             "//*Wrong type for i, got char??");
+    ADD_CALL_ARGS_TEST_XFAIL("invalid-autochar-type",
+                             "GjsAutoCharInvalidType(1)"
+                             "//*Wrong type for i, got GjsAutoChar?");
+    ADD_CALL_ARGS_TEST_XFAIL("invalid-autojschar-type",
+                             "GjsAutoJSCharInvalidType(1)"
+                             "//*Wrong type for i, got GjsAutoJSChar?");
     ADD_CALL_ARGS_TEST_XFAIL("invalid-object-type",
-                             "objectInvalidType(1)"
+                             "RootedObjectInvalidType(1)"
                              "//*Wrong type for i, got JS::MutableHandleObject");
     ADD_CALL_ARGS_TEST_XFAIL("invalid-boolean",
                              "boolArgNoAssert({})//*Not a boolean");

From b4e7699df888cfaa470572f109ac2ce36f9e8bde Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Thu, 13 Jul 2017 18:12:23 -0700
Subject: [PATCH 078/154] function: Better message about call during GC

GJS can attempt to call back into JS during garbage collection if you
implement vfunc_remove() on your container class. (Destroying a container
will remove all its child widgets, and if you have implemented
vfunc_remove() in JS then that will cause a JS call.)

Note this possibility in the warning message, and also add whatever
information we can get about the offending callback without calling into
JSAPI.

https://bugzilla.gnome.org/show_bug.cgi?id=785040
---
 gi/function.cpp | 10 ++++++++--
 gi/value.cpp    |  5 +++--
 2 files changed, 11 insertions(+), 4 deletions(-)

diff --git a/gi/function.cpp b/gi/function.cpp
index bef5b7b0..f6abeeb8 100644
--- a/gi/function.cpp
+++ b/gi/function.cpp
@@ -189,8 +189,14 @@ gjs_callback_closure(ffi_cif *cif,
         g_critical("Attempting to call back into JSAPI during the sweeping phase of GC. "
                    "This is most likely caused by not destroying a Clutter actor or Gtk+ "
                    "widget with ::destroy signals connected, but can also be caused by "
-                   "using the destroy() or dispose() vfuncs. Because it would crash the "
-                   "application, it has been blocked and the JS callback not invoked.");
+                   "using the destroy(), dispose(), or remove() vfuncs. "
+                   "Because it would crash the application, it has been "
+                   "blocked and the JS callback not invoked.");
+        if (trampoline->info) {
+            const char *name = g_base_info_get_name(static_cast<GIBaseInfo *>(trampoline->info));
+            g_critical("The offending callback was %s()%s.", name,
+                       trampoline->is_vfunc ? ", a vfunc" : "");
+        }
         /* A gjs_dumpstack() would be nice here, but we can't,
            because that works by creating a new Error object and
            reading the stack property, which is the worst possible
diff --git a/gi/value.cpp b/gi/value.cpp
index 32000304..30f68e14 100644
--- a/gi/value.cpp
+++ b/gi/value.cpp
@@ -143,8 +143,9 @@ closure_marshal(GClosure        *closure,
         g_critical("Attempting to call back into JSAPI during the sweeping phase of GC. "
                    "This is most likely caused by not destroying a Clutter actor or Gtk+ "
                    "widget with ::destroy signals connected, but can also be caused by "
-                   "using the destroy() or dispose() vfuncs. Because it would crash the "
-                   "application, it has been blocked and the JS callback not invoked.");
+                   "using the destroy(), dispose(), or remove() vfuncs. "
+                   "Because it would crash the application, it has been "
+                   "blocked and the JS callback not invoked.");
         if (hint) {
             gpointer instance;
             g_signal_query(hint->signal_id, &signal_query);

From fb0598e75fca9511847b4f83f72cd18782c5df93 Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 22:46:43 -0500
Subject: [PATCH 079/154] promise: Move to native promises

SpiderMonkey 52 includes native promises, so we can remove the embedded
JS implementation of promises. Queueing up and resolving of promises is
now done inside SpiderMonkey itself, and we must implement some
SpiderMonkey extension points in order to get this to integrate with our
GLib main loops.

The implementation is adapted from what SpiderMonkey does internally in
its js::RunJobs() function; see the code in jscntxt.cpp.

https://bugzilla.gnome.org/show_bug.cgi?id=784713

Based on https://github.com/GNOME/gjs/commit/4570bb5bc1e71f371c324ac618f4087262095cfb
---
 cjs/context-private.h                      |   5 +
 cjs/context.cpp                            | 130 ++++++++++-
 cjs/engine.cpp                             |  13 ++
 cjs/global.cpp                             |  50 +----
 installed-tests/scripts/testCommandLine.sh |  23 +-
 modules/_lie.js                            | 344 -----------------------------
 modules/console.cpp                        |  19 +-
 modules/modules.gresource.xml              |   1 -
 8 files changed, 184 insertions(+), 401 deletions(-)
 delete mode 100644 modules/_lie.js

diff --git a/cjs/context-private.h b/cjs/context-private.h
index d6207dab..824c47e2 100644
--- a/cjs/context-private.h
+++ b/cjs/context-private.h
@@ -48,6 +48,11 @@ void _gjs_context_set_sweeping(GjsContext *js_context,
 
 bool _gjs_context_is_sweeping(JSContext *cx);
 
+bool _gjs_context_enqueue_job(GjsContext      *gjs_context,
+                              JS::HandleObject job);
+
+bool _gjs_context_run_jobs(GjsContext *gjs_context);
+
 G_END_DECLS
 
 #endif  /* __GJS_CONTEXT_PRIVATE_H__ */
diff --git a/cjs/context.cpp b/cjs/context.cpp
index 962e51c5..db55181f 100644
--- a/cjs/context.cpp
+++ b/cjs/context.cpp
@@ -63,6 +63,9 @@ static void     gjs_context_set_property      (GObject               *object,
                                                   guint                  prop_id,
                                                   const GValue          *value,
                                                   GParamSpec            *pspec);
+
+using JobQueue = JS::GCVector<JSObject *, 0, js::SystemAllocPolicy>;
+
 struct _GjsContext {
     GObject parent;
 
@@ -83,6 +86,10 @@ struct _GjsContext {
     guint    auto_gc_id;
 
     std::array<JS::PersistentRootedId*, GJS_STRING_LAST> const_strings;
+
+    JS::PersistentRooted<JobQueue> *job_queue;
+    unsigned idle_drain_handler;
+    bool draining_job_queue;
 };
 
 /* Keep this consistent with GjsConstString */
@@ -227,6 +234,8 @@ gjs_context_dispose(GObject *object)
         for (auto& root : js_context->const_strings)
             delete root;
 
+        delete js_context->job_queue;
+
         /* Tear down JS */
         JS_DestroyContext(js_context->context);
         js_context->context = NULL;
@@ -281,6 +290,10 @@ gjs_context_constructed(GObject *object)
             gjs_intern_string_to_id(cx, const_strings[i]));
     }
 
+    js_context->job_queue = new JS::PersistentRooted<JobQueue>(cx);
+    if (!js_context->job_queue)
+        g_error("Failed to initialize promise job queue");
+
     JS_BeginRequest(cx);
 
     JS::RootedObject global(cx, gjs_create_global_object(cx));
@@ -446,6 +459,112 @@ _gjs_context_is_sweeping(JSContext *cx)
     return js_context->in_gc_sweep;
 }
 
+static gboolean
+drain_job_queue_idle_handler(void *data)
+{
+    auto gjs_context = static_cast<GjsContext *>(data);
+    _gjs_context_run_jobs(gjs_context);
+    /* Uncatchable exceptions are swallowed here - no way to get a handle on
+     * the main loop to exit it from this idle handler */
+    g_assert(((void) "_gjs_context_run_jobs() should have emptied queue",
+              gjs_context->idle_drain_handler == 0));
+    return G_SOURCE_REMOVE;
+}
+
+/* See engine.cpp and JS::SetEnqueuePromiseJobCallback(). */
+bool
+_gjs_context_enqueue_job(GjsContext      *gjs_context,
+                         JS::HandleObject job)
+{
+    if (gjs_context->idle_drain_handler)
+        g_assert(gjs_context->job_queue->length() > 0);
+    else
+        g_assert(gjs_context->job_queue->length() == 0);
+
+    if (!gjs_context->job_queue->append(job))
+        return false;
+    if (!gjs_context->idle_drain_handler)
+        gjs_context->idle_drain_handler =
+            g_idle_add(drain_job_queue_idle_handler, gjs_context);
+
+    return true;
+}
+
+/**
+ * _gjs_context_run_jobs:
+ * @gjs_context: The #GjsContext instance
+ *
+ * Drains the queue of promise callbacks that the JS engine has reported
+ * finished, calling each one and logging any exceptions that it throws.
+ *
+ * Adapted from js::RunJobs() in SpiderMonkey's default job queue
+ * implementation.
+ *
+ * Returns: false if one of the jobs threw an uncatchable exception;
+ * otherwise true.
+ */
+bool
+_gjs_context_run_jobs(GjsContext *gjs_context)
+{
+    bool retval = true;
+    g_assert(gjs_context->job_queue);
+
+    if (gjs_context->draining_job_queue || gjs_context->should_exit)
+        return true;
+
+    auto cx = static_cast<JSContext *>(gjs_context_get_native_context(gjs_context));
+    JSAutoRequest ar(cx);
+
+    gjs_context->draining_job_queue = true;  /* Ignore reentrant calls */
+
+    JS::RootedObject job(cx);
+    JS::HandleValueArray args(JS::HandleValueArray::empty());
+    JS::RootedValue rval(cx);
+
+    /* Execute jobs in a loop until we've reached the end of the queue.
+     * Since executing a job can trigger enqueueing of additional jobs,
+     * it's crucial to recheck the queue length during each iteration. */
+    for (size_t ix = 0; ix < gjs_context->job_queue->length(); ix++) {
+        /* A previous job might have set this flag. e.g., System.exit(). */
+        if (gjs_context->should_exit)
+            break;
+
+        job = gjs_context->job_queue->get()[ix];
+
+        /* It's possible that job draining was interrupted prematurely,
+         * leaving the queue partly processed. In that case, slots for
+         * already-executed entries will contain nullptrs, which we should
+         * just skip. */
+        if (!job)
+            continue;
+
+        gjs_context->job_queue->get()[ix] = nullptr;
+        {
+            JSAutoCompartment ac(cx, job);
+            if (!JS::Call(cx, JS::UndefinedHandleValue, job, args, &rval)) {
+                /* Uncatchable exception - return false so that
+                 * System.exit() works in the interactive shell and when
+                 * exiting the interpreter. */
+                if (!JS_IsExceptionPending(cx)) {
+                    retval = false;
+                    continue;
+                }
+
+                /* There's nowhere for the exception to go at this point */
+                gjs_log_exception(cx);
+            }
+        }
+    }
+
+    gjs_context->draining_job_queue = false;
+    gjs_context->job_queue->clear();
+    if (gjs_context->idle_drain_handler) {
+        g_source_remove(gjs_context->idle_drain_handler);
+        gjs_context->idle_drain_handler = 0;
+    }
+    return retval;
+}
+
 /**
  * gjs_context_maybe_gc:
  * @context: a #GjsContext
@@ -537,8 +656,15 @@ gjs_context_eval(GjsContext   *js_context,
     g_object_ref(G_OBJECT(js_context));
 
     JS::RootedValue retval(js_context->context);
-    if (!gjs_eval_with_scope(js_context->context, nullptr, script,
-                             script_len, filename, &retval)) {
+    bool ok = gjs_eval_with_scope(js_context->context, nullptr, script,
+                                  script_len, filename, &retval);
+
+    /* The promise job queue should be drained even on error, to finish
+     * outstanding async tasks before the context is torn down. Drain after
+     * uncaught exceptions have been reported since draining runs callbacks. */
+    ok = _gjs_context_run_jobs(js_context) && ok;
+
+    if (!ok) {
         uint8_t code;
         if (_gjs_context_should_exit(js_context, &code)) {
             /* exit_status_p is public API so can't be changed, but should be
diff --git a/cjs/engine.cpp b/cjs/engine.cpp
index 30aaeef7..ea9ab3e3 100644
--- a/cjs/engine.cpp
+++ b/cjs/engine.cpp
@@ -209,6 +209,17 @@ on_garbage_collect(JSContext *cx,
         gjs_object_clear_toggles();
 }
 
+static bool
+on_enqueue_promise_job(JSContext       *cx,
+                       JS::HandleObject callback,
+                       JS::HandleObject allocation_site,
+                       JS::HandleObject global,
+                       void            *data)
+{
+    auto gjs_context = static_cast<GjsContext *>(data);
+    return _gjs_context_enqueue_job(gjs_context, callback);
+}
+
 #ifdef G_OS_WIN32
 HMODULE gjs_dll;
 static bool gjs_is_inited = false;
@@ -292,6 +303,8 @@ gjs_create_js_context(GjsContext *js_context)
     JS_SetGCCallback(cx, on_garbage_collect, js_context);
     JS_SetLocaleCallbacks(cx, &gjs_locale_callbacks);
     JS::SetWarningReporter(cx, gjs_warning_reporter);
+    JS::SetGetIncumbentGlobalCallback(cx, gjs_get_import_global);
+    JS::SetEnqueuePromiseJobCallback(cx, on_enqueue_promise_job, js_context);
 
     /* setExtraWarnings: Be extra strict about code that might hide a bug */
     if (!g_getenv("GJS_DISABLE_EXTRA_WARNINGS")) {
diff --git a/cjs/global.cpp b/cjs/global.cpp
index 295df552..16dd5bd1 100644
--- a/cjs/global.cpp
+++ b/cjs/global.cpp
@@ -201,44 +201,6 @@ class GjsGlobal {
         JS_FS_END
     };
 
-    static bool
-    define_promise_object(JSContext       *cx,
-                          JS::HandleObject global)
-    {
-        /* This is not a regular import, we just load the module's code from the
-         * GResource and evaluate it */
-
-        GError *error = NULL;
-        GBytes *lie_bytes = g_resources_lookup_data("/org/gnome/gjs/modules/_lie.js",
-                                                    G_RESOURCE_LOOKUP_FLAGS_NONE,
-                                                    &error);
-        if (lie_bytes == NULL) {
-            g_critical("Failed to load Promise resource: %s", error->message);
-            g_clear_error(&error);
-            return false;
-        }
-
-        /* It should be OK to cast these bytes to const char *, since the module is
-         * a text file and we setUTF8(true) below */
-        size_t lie_length;
-        const char *lie_code = static_cast<const char *>(g_bytes_get_data(lie_bytes,
-                                                                          &lie_length));
-        JS::CompileOptions options(cx);
-        options.setUTF8(true)
-            .setSourceIsLazy(true)
-            .setFile("<Promise>");
-
-        JS::RootedValue promise(cx);
-        if (!JS::Evaluate(cx, options, lie_code, lie_length, &promise)) {
-            g_bytes_unref(lie_bytes);
-            return false;
-        }
-        g_bytes_unref(lie_bytes);
-
-        return JS_DefineProperty(cx, global, "Promise", promise,
-                                 JSPROP_READONLY | JSPROP_PERMANENT);
-    }
-
 public:
 
     static JSObject *
@@ -280,15 +242,9 @@ class GjsGlobal {
 
         /* Wrapping is a no-op if the importer is already in the same
          * compartment. */
-        if (!JS_WrapObject(cx, &root_importer) ||
-            !gjs_object_define_property(cx, global, GJS_STRING_IMPORTS,
-                                        root_importer, GJS_MODULE_PROP_FLAGS))
-            return false;
-
-        /* FIXME: We should define the Promise object before any imports, in
-         * case the imports want to use it. Currently that's not possible as it
-         * needs to import GLib */
-        return define_promise_object(cx, global);
+        return JS_WrapObject(cx, &root_importer) &&
+            gjs_object_define_property(cx, global, GJS_STRING_IMPORTS,
+                                       root_importer, GJS_MODULE_PROP_FLAGS);
     }
 };
 
diff --git a/installed-tests/scripts/testCommandLine.sh b/installed-tests/scripts/testCommandLine.sh
index 2e0d55e8..096b7932 100755
--- a/installed-tests/scripts/testCommandLine.sh
+++ b/installed-tests/scripts/testCommandLine.sh
@@ -27,6 +27,18 @@ if (ARGV.indexOf('--help') == -1)
 System.exit(0);
 EOF
 
+# this JS script should print one string (jobs are run before the interpreter
+# finishes) and should not print the other (jobs should not be run after the
+# interpreter is instructed to quit)
+cat <<EOF >promise.js
+const System = imports.system;
+Promise.resolve().then(() => {
+    print('Should be printed');
+    System.exit(42);
+});
+Promise.resolve().then(() => print('Should not be printed'));
+EOF
+
 total=0
 
 report () {
@@ -126,6 +138,15 @@ report "--version after -c should be passed to script"
 test -z "$("$gjs" -c "$script" --version)"
 report "--version after -c should not print anything"
 
-rm -f exit.js help.js
+# interpreter handles queued promise jobs correctly
+output=$("$gjs" promise.js)
+test $? -eq 42
+report "interpreter should exit with the correct exit code from a queued promise job"
+test -n "$output" -a -z "${output##*Should be printed*}"
+report "interpreter should run queued promise jobs before finishing"
+test -n "${output##*Should not be printed*}"
+report "interpreter should stop running jobs when one calls System.exit()"
+
+rm -f exit.js help.js promise.js
 
 echo "1..$total"
diff --git a/modules/_lie.js b/modules/_lie.js
deleted file mode 100644
index 602b52d8..00000000
--- a/modules/_lie.js
+++ /dev/null
@@ -1,344 +0,0 @@
-// jscs:disable validateIndentation
-(function () {
-'use strict';
-const GLib = imports.gi.GLib;
-
-var reqs = {
-  immediate: function () {
-    return function (func, priority=GLib.PRIORITY_DEFAULT_IDLE) {
-      GLib.idle_add(priority, function () {
-        func();
-        return GLib.SOURCE_REMOVE;
-      });
-    };
-  },
-};
-function require(req) {
-  return reqs[req]();
-}
-
-var process = {
-  emit: function (event, error) {
-    if (event === 'unhandledRejection') {
-      log('Unhandled rejection');
-      throw error;
-    }
-  },
-};
-
-// Copyright (c) 2014 Calvin Metcalf
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to deal
-// in the Software without restriction, including without limitation the rights
-// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-// copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-// SOFTWARE.
-
-// BEGIN CODE FROM lie/lib/index.js
-// https://raw.githubusercontent.com/calvinmetcalf/lie/master/lib/index.js
-
-// 'use strict';  // Moved for GJS
-var immediate = require('immediate');
-
-/* istanbul ignore next */
-function INTERNAL() {}
-
-var handlers = {};
-
-var REJECTED = ['REJECTED'];
-var FULFILLED = ['FULFILLED'];
-var PENDING = ['PENDING'];
-/* istanbul ignore else */
-if (!process.browser) {
-  // in which we actually take advantage of JS scoping
-  var UNHANDLED = ['UNHANDLED'];
-}
-
-// module.exports = Promise;  // removed for GJS
-
-function Promise(resolver) {
-  if (typeof this !== 'object') {
-    throw new TypeError('this must be an object');
-  }
-  if (typeof resolver !== 'function') {
-    throw new TypeError('resolver must be a function');
-  }
-  if (this instanceof Promise && typeof this.state !== 'undefined') {
-    throw new TypeError('this must not be an already-constructed promise');
-  }
-  this.state = PENDING;
-  this.queue = [];
-  this.outcome = void 0;
-  /* istanbul ignore else */
-  if (!process.browser) {
-    this.handled = UNHANDLED;
-  }
-  if (resolver !== INTERNAL) {
-    safelyResolveThenable(this, resolver);
-  }
-}
-
-Promise.prototype.catch = function (onRejected) {
-  return this.then(null, onRejected);
-};
-Promise.prototype.then = function (onFulfilled, onRejected) {
-  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
-    typeof onRejected !== 'function' && this.state === REJECTED) {
-    return this;
-  }
-  var promise = new this.constructor(INTERNAL);
-  /* istanbul ignore else */
-  if (!process.browser) {
-    if (this.handled === UNHANDLED) {
-      this.handled = null;
-    }
-  }
-  if (this.state !== PENDING) {
-    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
-    unwrap(promise, resolver, this.outcome);
-  } else {
-    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
-  }
-
-  return promise;
-};
-function QueueItem(promise, onFulfilled, onRejected) {
-  this.promise = promise;
-  if (typeof onFulfilled === 'function') {
-    this.onFulfilled = onFulfilled;
-    this.callFulfilled = this.otherCallFulfilled;
-  }
-  if (typeof onRejected === 'function') {
-    this.onRejected = onRejected;
-    this.callRejected = this.otherCallRejected;
-  }
-}
-QueueItem.prototype.callFulfilled = function (value) {
-  handlers.resolve(this.promise, value);
-};
-QueueItem.prototype.otherCallFulfilled = function (value) {
-  unwrap(this.promise, this.onFulfilled, value);
-};
-QueueItem.prototype.callRejected = function (value) {
-  handlers.reject(this.promise, value);
-};
-QueueItem.prototype.otherCallRejected = function (value) {
-  unwrap(this.promise, this.onRejected, value);
-};
-
-function unwrap(promise, func, value) {
-  immediate(function () {
-    var returnValue;
-    try {
-      returnValue = func(value);
-    } catch (e) {
-      handlers.reject(promise, e); // Changed for GJS
-      return; // Added for GJS
-    }
-    if (returnValue === promise) {
-      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
-    } else {
-      handlers.resolve(promise, returnValue);
-    }
-  });
-}
-
-handlers.resolve = function (self, value) {
-  var result = tryCatch(getThen, value);
-  if (result.status === 'error') {
-    return handlers.reject(self, result.value);
-  }
-  var thenable = result.value;
-
-  if (thenable) {
-    safelyResolveThenable(self, thenable);
-  } else {
-    self.state = FULFILLED;
-    self.outcome = value;
-    var i = -1;
-    var len = self.queue.length;
-    while (++i < len) {
-      self.queue[i].callFulfilled(value);
-    }
-  }
-  return self;
-};
-handlers.reject = function (self, error) {
-  self.state = REJECTED;
-  self.outcome = error;
-  /* istanbul ignore else */
-  if (!process.browser) {
-    if (self.handled === UNHANDLED) {
-      immediate(function () {
-        if (self.handled === UNHANDLED) {
-          process.emit('unhandledRejection', error, self);
-        }
-      });
-    }
-  }
-  var i = -1;
-  var len = self.queue.length;
-  while (++i < len) {
-    self.queue[i].callRejected(error);
-  }
-  return self;
-};
-
-function getThen(obj) {
-  // Make sure we only access the accessor once as required by the spec
-  var then = obj && obj.then;
-  if (obj && typeof obj === 'object' && typeof then === 'function') {
-    return function appyThen() {
-      then.apply(obj, arguments);
-    };
-  }
-  return undefined; // added for GJS
-}
-
-function safelyResolveThenable(self, thenable) {
-  // Either fulfill, reject or reject with error
-  var called = false;
-  function onError(value) {
-    if (called) {
-      return;
-    }
-    called = true;
-    handlers.reject(self, value);
-  }
-
-  function onSuccess(value) {
-    if (called) {
-      return;
-    }
-    called = true;
-    handlers.resolve(self, value);
-  }
-
-  function tryToUnwrap() {
-    thenable(onSuccess, onError);
-  }
-
-  var result = tryCatch(tryToUnwrap);
-  if (result.status === 'error') {
-    onError(result.value);
-  }
-}
-
-function tryCatch(func, value) {
-  var out = {};
-  try {
-    out.value = func(value);
-    out.status = 'success';
-  } catch (e) {
-    out.status = 'error';
-    out.value = e;
-  }
-  return out;
-}
-
-Promise.resolve = resolve;
-function resolve(value) {
-  if (value instanceof this) {
-    return value;
-  }
-  return handlers.resolve(new this(INTERNAL), value);
-}
-
-Promise.reject = reject;
-function reject(reason) {
-  var promise = new this(INTERNAL);
-  return handlers.reject(promise, reason);
-}
-
-Promise.all = all;
-function all(iterable) {
-  var self = this;
-  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
-    return this.reject(new TypeError('must be an array'));
-  }
-
-  var len = iterable.length;
-  var called = false;
-  if (!len) {
-    return this.resolve([]);
-  }
-
-  var values = new Array(len);
-  var resolved = 0;
-  var i = -1;
-  var promise = new this(INTERNAL);
-
-  while (++i < len) {
-    allResolver(iterable[i], i);
-  }
-  // return promise; // moved for GJS
-  function allResolver(value, i) {
-    self.resolve(value).then(resolveFromAll, function (error) {
-      if (!called) {
-        called = true;
-        handlers.reject(promise, error);
-      }
-    });
-    function resolveFromAll(outValue) {
-      values[i] = outValue;
-      if (++resolved === len && !called) {
-        called = true;
-        handlers.resolve(promise, values);
-      }
-    }
-  }
-  return promise; // Added for GJS
-}
-
-Promise.race = race;
-function race(iterable) {
-  var self = this;
-  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
-    return this.reject(new TypeError('must be an array'));
-  }
-
-  var len = iterable.length;
-  var called = false;
-  if (!len) {
-    return this.resolve([]);
-  }
-
-  var i = -1;
-  var promise = new this(INTERNAL);
-
-  while (++i < len) {
-    resolver(iterable[i]);
-  }
-  // return promise; // Moved for GJS
-  function resolver(value) {
-    self.resolve(value).then(function (response) {
-      if (!called) {
-        called = true;
-        handlers.resolve(promise, response);
-      }
-    }, function (error) {
-      if (!called) {
-        called = true;
-        handlers.reject(promise, error);
-      }
-    });
-  }
-  return promise; // Added for GJS
-}
-
-// END CODE FROM lie/lib/index.js
-
-return Promise;
-})();
diff --git a/modules/console.cpp b/modules/console.cpp
index c4f18f76..5b61f10a 100644
--- a/modules/console.cpp
+++ b/modules/console.cpp
@@ -54,6 +54,7 @@
 
 #include "console.h"
 #include "cjs/context.h"
+#include "cjs/context-private.h"
 #include "cjs/jsapi-private.h"
 #include "cjs/jsapi-wrapper.h"
 
@@ -279,19 +280,25 @@ gjs_console_interact(JSContext *context,
         } while (!JS_BufferIsCompilableUnit(context, global,
                                             buffer->str, buffer->len));
 
-        AutoReportException are(context);
-        if (!gjs_console_eval_and_print(context, buffer->str, buffer->len,
-                                        startline)) {
+        bool ok;
+        {
+            AutoReportException are(context);
+            ok = gjs_console_eval_and_print(context, buffer->str, buffer->len,
+                                            startline);
+        }
+        g_string_free(buffer, true);
+
+        auto gjs_context = static_cast<GjsContext *>(JS_GetContextPrivate(context));
+        ok = _gjs_context_run_jobs(gjs_context) && ok;
+
+        if (!ok) {
             /* If this was an uncatchable exception, throw another uncatchable
              * exception on up to the surrounding JS::Evaluate() in main(). This
              * happens when you run gjs-console and type imports.system.exit(0);
              * at the prompt. If we don't throw another uncatchable exception
              * here, then it's swallowed and main() won't exit. */
-            g_string_free(buffer, true);
             return false;
         }
-
-        g_string_free(buffer, true);
     } while (!eof);
 
     g_fprintf(stdout, "\n");
diff --git a/modules/modules.gresource.xml b/modules/modules.gresource.xml
index cb2784d6..47319355 100644
--- a/modules/modules.gresource.xml
+++ b/modules/modules.gresource.xml
@@ -14,7 +14,6 @@
     <file>modules/coverage.js</file>
     <file>modules/gettext.js</file>
     <file>modules/lang.js</file>
-    <file>modules/_lie.js</file>
     <file>modules/mainloop.js</file>
     <file>modules/jsUnit.js</file>
     <file>modules/signals.js</file>

From 9da22f8205bf49237d6d0175800c7fc1a2650fdb Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sat, 8 Jul 2017 20:45:07 -0700
Subject: [PATCH 080/154] promise: Report unhandled rejections

A known gotcha with promises is forgetting to attach a .catch() handler,
in which case a failed promise is swallowed silently. This will log a
warning when that happens.

https://bugzilla.gnome.org/show_bug.cgi?id=784713
---
 cjs/context-private.h                      |  8 ++++++
 cjs/context.cpp                            | 39 ++++++++++++++++++++++++++++++
 cjs/engine.cpp                             | 23 ++++++++++++++++++
 installed-tests/scripts/testCommandLine.sh | 18 +++++++++++++-
 4 files changed, 87 insertions(+), 1 deletion(-)

diff --git a/cjs/context-private.h b/cjs/context-private.h
index 824c47e2..6dbe6690 100644
--- a/cjs/context-private.h
+++ b/cjs/context-private.h
@@ -27,6 +27,7 @@
 #include <inttypes.h>
 
 #include "context.h"
+#include "jsapi-util.h"
 #include "jsapi-wrapper.h"
 
 G_BEGIN_DECLS
@@ -53,6 +54,13 @@ bool _gjs_context_enqueue_job(GjsContext      *gjs_context,
 
 bool _gjs_context_run_jobs(GjsContext *gjs_context);
 
+void _gjs_context_unregister_unhandled_promise_rejection(GjsContext *gjs_context,
+                                                         uint64_t    promise_id);
+
 G_END_DECLS
 
+void _gjs_context_register_unhandled_promise_rejection(GjsContext   *gjs_context,
+                                                       uint64_t      promise_id,
+                                                       GjsAutoChar&& stack);
+
 #endif  /* __GJS_CONTEXT_PRIVATE_H__ */
diff --git a/cjs/context.cpp b/cjs/context.cpp
index db55181f..b950a8eb 100644
--- a/cjs/context.cpp
+++ b/cjs/context.cpp
@@ -24,6 +24,7 @@
 #include <config.h>
 
 #include <array>
+#include <unordered_map>
 
 #include <gio/gio.h>
 
@@ -90,6 +91,8 @@ struct _GjsContext {
     JS::PersistentRooted<JobQueue> *job_queue;
     unsigned idle_drain_handler;
     bool draining_job_queue;
+
+    std::unordered_map<uint64_t, GjsAutoChar> unhandled_rejection_stacks;
 };
 
 /* Keep this consistent with GjsConstString */
@@ -189,6 +192,21 @@ gjs_context_tracer(JSTracer *trc, void *data)
     JS::TraceEdge<JSObject *>(trc, &gjs_context->global, "GJS global object");
 }
 
+static void
+warn_about_unhandled_promise_rejections(GjsContext *gjs_context)
+{
+    for (auto& kv : gjs_context->unhandled_rejection_stacks) {
+        const char *stack = kv.second;
+        g_warning("Unhandled promise rejection. To suppress this warning, add "
+                  "an error handler to your promise chain with .catch() or a "
+                  "try-catch block around your await expression. %s%s",
+                  stack ? "Stack trace of the failed promise:\n" :
+                    "Unfortunately there is no stack trace of the failed promise.",
+                  stack ? stack : "");
+    }
+    gjs_context->unhandled_rejection_stacks.clear();
+}
+
 static void
 gjs_context_dispose(GObject *object)
 {
@@ -205,6 +223,8 @@ gjs_context_dispose(GObject *object)
         gjs_debug(GJS_DEBUG_CONTEXT,
                   "Destroying JS context");
 
+        warn_about_unhandled_promise_rejections(js_context);
+
         JS_BeginRequest(js_context->context);
 
         /* Do a full GC here before tearing down, since once we do
@@ -267,6 +287,7 @@ gjs_context_finalize(GObject *object)
     g_mutex_unlock(&contexts_lock);
 
     js_context->global.~Heap();
+    js_context->unhandled_rejection_stacks.~unordered_map();
     G_OBJECT_CLASS(gjs_context_parent_class)->finalize(object);
 }
 
@@ -285,6 +306,7 @@ gjs_context_constructed(GObject *object)
         g_error("Failed to create javascript context");
     js_context->context = cx;
 
+    new (&js_context->unhandled_rejection_stacks) std::unordered_map<uint64_t, GjsAutoChar>;
     for (i = 0; i < GJS_STRING_LAST; i++) {
         js_context->const_strings[i] = new JS::PersistentRootedId(cx,
             gjs_intern_string_to_id(cx, const_strings[i]));
@@ -565,6 +587,23 @@ _gjs_context_run_jobs(GjsContext *gjs_context)
     return retval;
 }
 
+void
+_gjs_context_register_unhandled_promise_rejection(GjsContext   *gjs_context,
+                                                  uint64_t      id,
+                                                  GjsAutoChar&& stack)
+{
+    gjs_context->unhandled_rejection_stacks[id] = std::move(stack);
+}
+
+void
+_gjs_context_unregister_unhandled_promise_rejection(GjsContext *gjs_context,
+                                                    uint64_t    id)
+{
+    size_t erased = gjs_context->unhandled_rejection_stacks.erase(id);
+    g_assert(((void)"Handler attached to rejected promise that wasn't "
+              "previously marked as unhandled", erased == 1));
+}
+
 /**
  * gjs_context_maybe_gc:
  * @context: a #GjsContext
diff --git a/cjs/engine.cpp b/cjs/engine.cpp
index ea9ab3e3..a6d5f48c 100644
--- a/cjs/engine.cpp
+++ b/cjs/engine.cpp
@@ -220,6 +220,27 @@ on_enqueue_promise_job(JSContext       *cx,
     return _gjs_context_enqueue_job(gjs_context, callback);
 }
 
+static void
+on_promise_unhandled_rejection(JSContext                    *cx,
+                               JS::HandleObject              promise,
+                               PromiseRejectionHandlingState state,
+                               void                         *data)
+{
+    auto gjs_context = static_cast<GjsContext *>(data);
+    uint64_t id = JS::GetPromiseID(promise);
+
+    if (state == PromiseRejectionHandlingState::Handled) {
+        /* This happens when catching an exception from an await expression. */
+        _gjs_context_unregister_unhandled_promise_rejection(gjs_context, id);
+        return;
+    }
+
+    JS::RootedObject allocation_site(cx, JS::GetPromiseAllocationSite(promise));
+    GjsAutoChar stack = gjs_format_stack_trace(cx, allocation_site);
+    _gjs_context_register_unhandled_promise_rejection(gjs_context, id,
+                                                      std::move(stack));
+}
+
 #ifdef G_OS_WIN32
 HMODULE gjs_dll;
 static bool gjs_is_inited = false;
@@ -305,6 +326,8 @@ gjs_create_js_context(GjsContext *js_context)
     JS::SetWarningReporter(cx, gjs_warning_reporter);
     JS::SetGetIncumbentGlobalCallback(cx, gjs_get_import_global);
     JS::SetEnqueuePromiseJobCallback(cx, on_enqueue_promise_job, js_context);
+    JS::SetPromiseRejectionTrackerCallback(cx, on_promise_unhandled_rejection,
+                                           js_context);
 
     /* setExtraWarnings: Be extra strict about code that might hide a bug */
     if (!g_getenv("GJS_DISABLE_EXTRA_WARNINGS")) {
diff --git a/installed-tests/scripts/testCommandLine.sh b/installed-tests/scripts/testCommandLine.sh
index 096b7932..74ce17d9 100755
--- a/installed-tests/scripts/testCommandLine.sh
+++ b/installed-tests/scripts/testCommandLine.sh
@@ -39,6 +39,17 @@ Promise.resolve().then(() => {
 Promise.resolve().then(() => print('Should not be printed'));
 EOF
 
+# this JS script should not cause an unhandled promise rejection
+cat <<EOF >awaitcatch.js
+async function foo() { throw new Error('foo'); }
+async function bar() {
+    try {
+        await foo();
+    } catch (e) {}
+}
+bar();
+EOF
+
 total=0
 
 report () {
@@ -147,6 +158,11 @@ report "interpreter should run queued promise jobs before finishing"
 test -n "${output##*Should not be printed*}"
 report "interpreter should stop running jobs when one calls System.exit()"
 
-rm -f exit.js help.js promise.js
+"$gjs" -c "Promise.resolve().then(() => { throw new Error(); });" 2>&1 | grep -q 'Gjs-WARNING.*Unhandled promise rejection.*[sS]tack trace'
+report "unhandled promise rejection should be reported"
+test -z $("$gjs" awaitcatch.js)
+report "catching an await expression should not cause unhandled rejection"
+
+rm -f exit.js help.js promise.js awaitcatch.js
 
 echo "1..$total"

From 1d38c5ad2fd18791671ab6bd488cc93d26a2c1e0 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Tue, 18 Jul 2017 18:42:03 -0700
Subject: [PATCH 081/154] context: Properly create const strings array

The std::array object in GjsContext never had its constructor and
destructor called. That happens to work, but it depends on the
implementation, so do it properly.

https://bugzilla.gnome.org/show_bug.cgi?id=784713
---
 cjs/context.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/cjs/context.cpp b/cjs/context.cpp
index b950a8eb..33f4ad51 100644
--- a/cjs/context.cpp
+++ b/cjs/context.cpp
@@ -287,6 +287,7 @@ gjs_context_finalize(GObject *object)
     g_mutex_unlock(&contexts_lock);
 
     js_context->global.~Heap();
+    js_context->const_strings.~array();
     js_context->unhandled_rejection_stacks.~unordered_map();
     G_OBJECT_CLASS(gjs_context_parent_class)->finalize(object);
 }
@@ -307,6 +308,7 @@ gjs_context_constructed(GObject *object)
     js_context->context = cx;
 
     new (&js_context->unhandled_rejection_stacks) std::unordered_map<uint64_t, GjsAutoChar>;
+    new (&js_context->const_strings) std::array<JS::PersistentRootedId*, GJS_STRING_LAST>;
     for (i = 0; i < GJS_STRING_LAST; i++) {
         js_context->const_strings[i] = new JS::PersistentRootedId(cx,
             gjs_intern_string_to_id(cx, const_strings[i]));

From a6a3852483d13906d1c5aa740a15b2cf3d602b1c Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sat, 22 Jul 2017 20:45:07 -0700
Subject: [PATCH 082/154] importer: Give module objects a [Symbol.toStringTag]

Instead of defining a toString() function on module objects, give them a
[Symbol.toStringTag] property. This avoids overwriting a toString()
property that the module may have defined itself.

https://bugzilla.gnome.org/show_bug.cgi?id=781623
---
 cjs/importer.cpp                     | 44 ++++++++++--------------------------
 installed-tests/js/modules/foobar.js |  6 +++++
 installed-tests/js/testImporter.js   | 10 ++++++--
 3 files changed, 26 insertions(+), 34 deletions(-)

diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index e7da12ab..f63c5088 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -130,6 +130,7 @@ define_meta_properties(JSContext       *context,
     JS::RootedValue module_name_val(context, JS::NullValue());
     JS::RootedValue parent_module_val(context, JS::NullValue());
     JS::RootedValue module_path(context, JS::NullValue());
+    JS::RootedValue to_string_tag(context);
     if (parent_is_module) {
         module_name_val.setString(JS_NewStringCopyZ(context, module_name));
         parent_module_val.setObject(*parent);
@@ -150,6 +151,12 @@ define_meta_properties(JSContext       *context,
             module_path_buf = g_strdup_printf("%s.%s", parent_path.get(), module_name);
         }
         module_path.setString(JS_NewStringCopyZ(context, module_path_buf));
+
+        GjsAutoChar to_string_tag_buf = g_strdup_printf("GjsModule %s",
+                                                        module_path_buf.get());
+        to_string_tag.setString(JS_NewStringCopyZ(context, to_string_tag_buf));
+    } else {
+        to_string_tag.setString(JS_AtomizeString(context, "GjsModule"));
     }
 
     if (!JS_DefineProperty(context, module_obj,
@@ -164,7 +171,11 @@ define_meta_properties(JSContext       *context,
                            attrs))
         return false;
 
-    return true;
+    JS::RootedId to_string_tag_name(context,
+        SYMBOL_TO_JSID(JS::GetWellKnownSymbol(context,
+                                              JS::SymbolCode::toStringTag)));
+    return JS_DefinePropertyById(context, module_obj, to_string_tag_name,
+                                 to_string_tag, attrs);
 }
 
 static bool
@@ -251,29 +262,6 @@ cancel_import(JSContext       *context,
     }
 }
 
-static bool
-module_to_string(JSContext *cx,
-                 unsigned   argc,
-                 JS::Value *vp)
-{
-    GJS_GET_THIS(cx, argc, vp, args, module);
-
-    JS::RootedValue module_path(cx);
-    if (!gjs_object_get_property(cx, module, GJS_STRING_MODULE_PATH,
-                                 &module_path))
-        return false;
-
-    g_assert(!module_path.isNull());
-
-    GjsAutoJSChar path(cx);
-    if (!gjs_string_to_utf8(cx, module_path, &path))
-        return false;
-    GjsAutoChar output = g_strdup_printf("[GjsModule %s]", path.get());
-
-    args.rval().setString(JS_NewStringCopyZ(cx, output));
-    return true;
-}
-
 static bool
 import_native_file(JSContext       *context,
                    JS::HandleObject obj,
@@ -289,10 +277,6 @@ import_native_file(JSContext       *context,
     if (!define_meta_properties(context, module_obj, NULL, name, obj))
         return false;
 
-    if (!JS_DefineFunction(context, module_obj, "toString", module_to_string,
-                           0, 0))
-        return false;
-
     if (JS_IsExceptionPending(context)) {
         /* I am not sure whether this can happen, but if it does we want to trap it.
          */
@@ -452,10 +436,6 @@ import_file_on_module(JSContext       *context,
     if (!define_meta_properties(context, module_obj, full_path, name, obj))
         goto out;
 
-    if (!JS_DefineFunction(context, module_obj, "toString", module_to_string,
-                           0, 0))
-        goto out;
-
     if (!seal_import(context, obj, id, name))
         goto out;
 
diff --git a/installed-tests/js/modules/foobar.js b/installed-tests/js/modules/foobar.js
index cdd5cade..4ac0a24b 100644
--- a/installed-tests/js/modules/foobar.js
+++ b/installed-tests/js/modules/foobar.js
@@ -2,3 +2,9 @@
 
 var foo = "This is foo";
 var bar = "This is bar";
+
+var toString = x => x;
+
+function testToString(x) {
+    return toString(x);
+}
diff --git a/installed-tests/js/testImporter.js b/installed-tests/js/testImporter.js
index e2165619..e46781f5 100644
--- a/installed-tests/js/testImporter.js
+++ b/installed-tests/js/testImporter.js
@@ -79,6 +79,10 @@ describe('Importer', function () {
         expect(foobar.bar).toEqual('This is bar');
     });
 
+    it('can import a module with a toString property', function () {
+        expect(foobar.testToString('foo')).toEqual('foo');
+    });
+
     it('makes deleting the import a no-op', function () {
         expect(delete imports.foobar).toBeFalsy();
         expect(imports.foobar).toBe(foobar);
@@ -98,8 +102,10 @@ describe('Importer', function () {
     });
 
     it('imports modules with a toString representation', function () {
-        expect(foobar.toString()).toEqual('[GjsModule foobar]');
-        expect(subFoobar.toString()).toEqual('[GjsModule subA.subB.foobar]');
+        expect(Object.prototype.toString.call(foobar))
+            .toEqual('[object GjsModule foobar]');
+        expect(subFoobar.toString())
+            .toEqual('[object GjsModule subA.subB.foobar]');
     });
 
     it('does not share the same object for a module on a different path', function () {

From 5882d617dbe82b62244bef4dfaaf8b7acda0eb0a Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Fri, 28 Jul 2017 00:23:38 +0100
Subject: [PATCH 084/154] release: Include NEWS from 1.48.6

---
 NEWS | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/NEWS b/NEWS
index 26664279..4963c636 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,11 @@
+Version 1.48.6
+--------------
+
+- Closed bugs:
+
+  * GJS crash in needsPostBarrier, possible access from wrong thread [#783935,
+    Philip Chimento] (again)
+
 Version 1.49.4
 --------------
 

From f5a30d03cc6d00f9dfbe38fbb23ccb5f0d736609 Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 22:51:35 -0500
Subject: [PATCH 085/154] object: Don't let a method shadow a property

This changed due to a change in property access code in SpiderMonkey 45.
Previously, the getProperty hook was apparently called for every property
access. Now, it's never called if the resolve hook defines a lazy
property first.

This is unfortunate; we may still change this behaviour (see
https://bugzilla.gnome.org/show_bug.cgi?id=690450#c30), but if we do
change it then we want it to be intentional.

https://bugzilla.gnome.org/show_bug.cgi?id=785091

Based on https://github.com/GNOME/gjs/commit/40b7b1767dcd5176d3c493cb02e2a3ff1fca7eae
---
 gi/object.cpp                                    | 82 +++++++++++++++++++++++-
 installed-tests/js/testEverythingEncapsulated.js | 10 +++
 2 files changed, 89 insertions(+), 3 deletions(-)

diff --git a/gi/object.cpp b/gi/object.cpp
index c5a337b4..647b5f27 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -320,6 +320,14 @@ lookup_field_info(GIObjectInfo *info,
         g_clear_pointer(&retval, g_base_info_unref);
     }
 
+    if (!retval)
+        return nullptr;
+
+    if (!(g_field_info_get_flags(retval) & GI_FIELD_IS_READABLE)) {
+        g_base_info_unref(retval);
+        return nullptr;
+    }
+
     return retval;
 }
 
@@ -343,9 +351,6 @@ get_prop_from_field(JSContext             *cx,
     GITypeTag tag;
     GIArgument arg = { 0 };
 
-    if (!(g_field_info_get_flags(field) & GI_FIELD_IS_READABLE))
-        goto out;
-
     gjs_debug_jsprop(GJS_DEBUG_GOBJECT, "Overriding %s with GObject field",
                      name);
 
@@ -648,6 +653,65 @@ object_instance_resolve_no_info(JSContext       *context,
     return true;
 }
 
+/* Taken from GLib */
+static void
+canonicalize_key(char *key)
+{
+    for (char *p = key; *p != 0; p++) {
+        char c = *p;
+
+        if (c != '-' &&
+            (c < '0' || c > '9') &&
+            (c < 'A' || c > 'Z') &&
+            (c < 'a' || c > 'z'))
+            *p = '-';
+    }
+}
+
+static bool
+is_gobject_property_name(GIObjectInfo *info,
+                         const char   *name)
+{
+    int n_props = g_object_info_get_n_properties(info);
+    int ix;
+    GIPropertyInfo *prop_info = nullptr;
+
+    char *canonical_name = gjs_hyphen_from_camel(name);
+    canonicalize_key(canonical_name);
+
+    for (ix = 0; ix < n_props; ix++) {
+        prop_info = g_object_info_get_property(info, ix);
+        const char *prop_name = g_base_info_get_name(prop_info);
+        if (strcmp(canonical_name, prop_name) == 0)
+            break;
+        g_clear_pointer(&prop_info, g_base_info_unref);
+    }
+
+    g_free(canonical_name);
+
+    if (!prop_info)
+        return false;
+
+    if (!(g_property_info_get_flags(prop_info) & G_PARAM_READABLE)) {
+        g_base_info_unref(prop_info);
+        return false;
+    }
+
+    g_base_info_unref(prop_info);
+    return true;
+}
+
+static bool
+is_gobject_field_name(GIObjectInfo *info,
+                      const char   *name)
+{
+    GIFieldInfo *field_info = lookup_field_info(info, name);
+    if (!field_info)
+        return false;
+    g_base_info_unref(field_info);
+    return true;
+}
+
 /*
  * The *objp out parameter, on success, should be null to indicate that id
  * was not resolved; and non-null, referring to obj or one of its prototypes,
@@ -746,6 +810,18 @@ object_instance_resolve(JSContext       *context,
          * method resolution. */
     }
 
+    /* If the name refers to a GObject property or field, don't resolve.
+     * Instead, let the getProperty hook handle fetching the property from
+     * GObject. */
+    if (is_gobject_property_name(priv->info, name) ||
+        is_gobject_field_name(priv->info, name)) {
+        gjs_debug_jsprop(GJS_DEBUG_GOBJECT,
+                         "Breaking out of %p resolve, '%s' is a GObject prop",
+                         obj.get(), name.get());
+        *resolved = false;
+        return true;
+    }
+
     /* find_method does not look at methods on parent classes,
      * we rely on javascript to walk up the __proto__ chain
      * and find those and define them in the right prototype.
diff --git a/installed-tests/js/testEverythingEncapsulated.js b/installed-tests/js/testEverythingEncapsulated.js
index 01421602..1039f0e0 100644
--- a/installed-tests/js/testEverythingEncapsulated.js
+++ b/installed-tests/js/testEverythingEncapsulated.js
@@ -231,6 +231,16 @@ describe('Introspected GObject', function () {
         obj.ownprop = 'foo';
         expect(obj.hasOwnProperty('ownprop')).toBeTruthy();
     });
+
+    // This test is not meant to be normative; a GObject behaving like this is
+    // doing something unsupported. However, we have been handling this so far
+    // in a certain way, and we don't want to break user code because of badly
+    // behaved libraries. This test ensures that any change to the behaviour
+    // must be intentional.
+    it('resolves properties when they are shadowed by methods', function () {
+        expect(obj.name_conflict).toEqual(42);
+        expect(obj.name_conflict instanceof Function).toBeFalsy();
+    });
 });
 
 describe('Introspected function length', function () {

From 49691c2361b8d8693600281d3d8163123caf2288 Mon Sep 17 00:00:00 2001
From: "luke.nukem.jones@gmail.com" <luke.nukem.jones@gmail.com>
Date: Sun, 30 Jul 2017 01:54:00 -0700
Subject: [PATCH 086/154] Backport of patch required for JSObject compare to
 nullptr

https://bugzilla.gnome.org/show_bug.cgi?id=785424
---
 cjs/byteArray.cpp         | 20 ++++++++++----------
 cjs/coverage.cpp          |  6 +++---
 cjs/global.cpp            |  4 ++--
 cjs/importer.cpp          | 13 ++++++-------
 cjs/jsapi-class.h         |  4 ++--
 cjs/jsapi-util-error.cpp  |  2 +-
 cjs/jsapi-util-string.cpp |  4 ++--
 cjs/jsapi-util.cpp        | 26 +++++++++++++-------------
 gi/arg.cpp                | 14 +++++++-------
 gi/boxed.cpp              |  4 ++--
 gi/closure.cpp            |  4 ++--
 gi/enumeration.cpp        |  2 +-
 gi/function.cpp           |  4 ++--
 gi/fundamental.cpp        |  6 +++---
 gi/gerror.cpp             |  2 +-
 gi/ns.cpp                 |  2 +-
 gi/object.cpp             | 16 ++++++++--------
 gi/param.cpp              |  4 ++--
 gi/repo.cpp               |  2 +-
 gi/union.cpp              |  2 +-
 modules/cairo-pattern.cpp |  2 +-
 modules/cairo-surface.cpp |  2 +-
 22 files changed, 72 insertions(+), 73 deletions(-)

diff --git a/cjs/byteArray.cpp b/cjs/byteArray.cpp
index 88b38e27..4c32e987 100644
--- a/cjs/byteArray.cpp
+++ b/cjs/byteArray.cpp
@@ -201,7 +201,7 @@ byte_array_get_prop(JSContext *context,
 
     priv = priv_from_js(context, obj);
 
-    if (priv == NULL)
+    if (!priv)
         return true; /* prototype, not an instance. */
 
     JS::RootedValue id_value(context);
@@ -231,7 +231,7 @@ byte_array_length_getter(JSContext *context,
     GJS_GET_PRIV(context, argc, vp, args, to, ByteArrayInstance, priv);
     gsize len = 0;
 
-    if (priv == NULL)
+    if (!priv)
         return true; /* prototype, not an instance. */
 
     if (priv->array != NULL)
@@ -250,7 +250,7 @@ byte_array_length_setter(JSContext *context,
     GJS_GET_PRIV(context, argc, vp, args, to, ByteArrayInstance, priv);
     gsize len = 0;
 
-    if (priv == NULL)
+    if (!priv)
         return true; /* prototype, not instance */
 
     byte_array_ensure_array(priv);
@@ -309,7 +309,7 @@ byte_array_set_prop(JSContext *context,
 
     priv = priv_from_js(context, obj);
 
-    if (priv == NULL)
+    if (!priv)
         return result.succeed(); /* prototype, not an instance. */
 
     JS::RootedValue id_value(context);
@@ -388,7 +388,7 @@ byte_array_finalize(JSFreeOp *fop,
 
     priv = (ByteArrayInstance*) JS_GetPrivate(obj);
 
-    if (priv == NULL)
+    if (!priv)
         return; /* prototype, not instance */
 
     if (priv->array) {
@@ -412,7 +412,7 @@ to_string_func(JSContext *context,
     bool encoding_is_utf8;
     gchar *data;
 
-    if (priv == NULL)
+    if (!priv)
         return true; /* prototype, not instance */
 
     byte_array_ensure_array(priv);
@@ -492,7 +492,7 @@ to_gbytes_func(JSContext *context,
     JSObject *ret_bytes_obj;
     GIBaseInfo *gbytes_info;
 
-    if (priv == NULL)
+    if (!priv)
         return true; /* prototype, not instance */
 
     byte_array_ensure_gbytes(priv);
@@ -534,7 +534,7 @@ from_string_func(JSContext *context,
     bool encoding_is_utf8;
     JS::RootedObject obj(context, byte_array_new(context));
 
-    if (obj == NULL)
+    if (!obj)
         return false;
 
     priv = priv_from_js(context, obj);
@@ -643,7 +643,7 @@ from_array_func(JSContext *context,
     bool is_array;
     JS::RootedObject obj(context, byte_array_new(context));
 
-    if (obj == NULL)
+    if (!obj)
         return false;
 
     priv = priv_from_js(context, obj);
@@ -715,7 +715,7 @@ from_gbytes_func(JSContext *context,
     gbytes = (GBytes*) gjs_c_struct_from_boxed(context, bytes_obj);
 
     JS::RootedObject obj(context, byte_array_new(context));
-    if (obj == NULL)
+    if (!obj)
         return false;
     priv = priv_from_js(context, obj);
     g_assert (priv != NULL);
diff --git a/cjs/coverage.cpp b/cjs/coverage.cpp
index 3e8c51af..e6a80a59 100644
--- a/cjs/coverage.cpp
+++ b/cjs/coverage.cpp
@@ -1341,11 +1341,11 @@ coverage_log(JSContext *context,
      * could not be converted to string */
     exc_state = JS_SaveExceptionState(context);
     JS::RootedString jstr(context, JS::ToString(context, argv[0]));
-    if (jstr != NULL)
+    if (jstr)
         argv[0].setString(jstr);  // GC root
     JS_RestoreExceptionState(context, exc_state);
 
-    if (jstr == NULL) {
+    if (!jstr) {
         g_message("JS LOG: <cannot convert value to string>");
         return true;
     }
@@ -1392,7 +1392,7 @@ coverage_get_file_modification_time(JSContext *context,
         mtime_values_array[1].setInt32(mtime.tv_usec);
         JS::RootedObject array_obj(context,
             JS_NewArrayObject(context, mtime_values_array));
-        if (array_obj == NULL)
+        if (!array_obj)
             goto out;
         args.rval().setObject(*array_obj);
     } else {
diff --git a/cjs/global.cpp b/cjs/global.cpp
index 16dd5bd1..0a65a48d 100644
--- a/cjs/global.cpp
+++ b/cjs/global.cpp
@@ -51,7 +51,7 @@ gjs_log(JSContext *cx,
     JS::RootedString jstr(cx, JS::ToString(cx, argv[0]));
     exc_state.restore();
 
-    if (jstr == NULL) {
+    if (!jstr) {
         g_message("JS LOG: <cannot convert value to string>");
         return true;
     }
@@ -114,7 +114,7 @@ gjs_print_parse_args(JSContext    *cx,
         JS::RootedString jstr(cx, JS::ToString(cx, argv[n]));
         exc_state.restore();
 
-        if (jstr != NULL) {
+        if (jstr) {
             GjsAutoJSChar s(cx);
             if (!gjs_string_to_utf8(cx, JS::StringValue(jstr), &s)) {
                 g_string_free(str, true);
diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index f63c5088..d53b5b07 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -195,7 +195,7 @@ import_directory(JSContext       *context,
      * this always succeeds.
      */
     importer = gjs_define_importer(context, obj, name, full_paths, false);
-    return importer != NULL;
+    return importer != nullptr;
 }
 
 /* Make the property we set in gjs_module_import() permanent;
@@ -209,8 +209,7 @@ seal_import(JSContext       *cx,
 {
     JS::Rooted<JS::PropertyDescriptor> descr(cx);
 
-    if (!JS_GetOwnPropertyDescriptorById(cx, obj, id, &descr) ||
-        descr.object() == NULL) {
+    if (!JS_GetOwnPropertyDescriptorById(cx, obj, id, &descr) || !descr.object()) {
         gjs_debug(GJS_DEBUG_IMPORTER,
                   "Failed to get attributes to seal '%s' in importer",
                   name);
@@ -370,7 +369,7 @@ load_module_elements(JSContext        *cx,
     size_t ix, length;
     JS::RootedObject module_obj(cx, load_module_init(cx, in_object, init_path));
 
-    if (module_obj == NULL)
+    if (!module_obj)
         return;
 
     JS::Rooted<JS::IdVector> ids(cx, cx);
@@ -774,7 +773,7 @@ importer_resolve(JSContext        *context,
     gjs_debug_jsprop(GJS_DEBUG_IMPORTER,
                      "Resolve prop '%s' hook obj %p priv %p",
                      name.get(), obj.get(), priv);
-    if (priv == NULL) {
+    if (!priv) {
         /* we are the prototype, or have the wrong class */
         *resolved = false;
         return true;
@@ -799,7 +798,7 @@ importer_finalize(js::FreeOp *fop,
     priv = (Importer*) JS_GetPrivate(obj);
     gjs_debug_lifecycle(GJS_DEBUG_IMPORTER,
                         "finalize, obj %p priv %p", obj, priv);
-    if (priv == NULL)
+    if (!priv)
         return; /* we are the prototype, not a real instance */
 
     GJS_DEC_COUNTER(importer);
@@ -866,7 +865,7 @@ importer_new(JSContext *context,
 
     JS::RootedObject importer(context,
         JS_NewObjectWithGivenProto(context, &gjs_importer_class, proto));
-    if (importer == NULL)
+    if (!importer)
         g_error("No memory to create importer");
 
     priv = g_slice_new0(Importer);
diff --git a/cjs/jsapi-class.h b/cjs/jsapi-class.h
index 508c828e..c3c8fa97 100644
--- a/cjs/jsapi-class.h
+++ b/cjs/jsapi-class.h
@@ -68,7 +68,7 @@ JSObject *gjs_construct_object_dynamic(JSContext                  *cx,
  * priv_from_js_with_typecheck: a convenience function to call
  *                              do_base_typecheck and priv_from_js
  */
-#define GJS_DEFINE_PRIV_FROM_JS(type, klass)                          \
+#define GJS_DEFINE_PRIV_FROM_JS(type, klass)                            \
     GJS_ALWAYS_INLINE G_GNUC_UNUSED                                     \
     static inline bool                                                  \
     do_base_typecheck(JSContext       *context,                         \
@@ -307,7 +307,7 @@ gjs_##name##_constructor(JSContext  *context,           \
         return false;                                                         \
     }                                                                         \
     object = JS_NewObjectForConstructor(context, &gjs_##name##_class, argv);  \
-    if (object == NULL)                                                       \
+    if (!object)                                                              \
         return false;                                                         \
 }
 
diff --git a/cjs/jsapi-util-error.cpp b/cjs/jsapi-util-error.cpp
index 1196bd0e..0af708d5 100644
--- a/cjs/jsapi-util-error.cpp
+++ b/cjs/jsapi-util-error.cpp
@@ -97,7 +97,7 @@ gjs_throw_valist(JSContext       *context,
     constructor = &v_constructor.toObject();
     new_exc = JS_New(context, constructor, error_args);
 
-    if (new_exc == NULL)
+    if (!new_exc)
         goto out;
 
     if (error_name != NULL) {
diff --git a/cjs/jsapi-util-string.cpp b/cjs/jsapi-util-string.cpp
index 53f32f5e..41929b55 100644
--- a/cjs/jsapi-util-string.cpp
+++ b/cjs/jsapi-util-string.cpp
@@ -87,7 +87,7 @@ gjs_string_from_utf8(JSContext             *context,
         value_p.setString(str);
 
     JS_EndRequest(context);
-    return str != NULL;
+    return str != nullptr;
 }
 
 bool
@@ -313,7 +313,7 @@ gjs_string_from_ucs4(JSContext             *cx,
     /* Avoid a copy - assumes that g_malloc == js_malloc == malloc */
     JS::RootedString str(cx, JS_NewUCString(cx, u16_string, u16_string_length));
 
-    if (str == NULL) {
+    if (!str) {
         gjs_throw(cx, "Failed to convert UCS-4 string to UTF-16");
         return false;
     }
diff --git a/cjs/jsapi-util.cpp b/cjs/jsapi-util.cpp
index 48f71f44..8627cb7a 100644
--- a/cjs/jsapi-util.cpp
+++ b/cjs/jsapi-util.cpp
@@ -311,11 +311,11 @@ gjs_define_string_array(JSContext       *context,
     JS::RootedObject array(context,
         gjs_build_string_array(context, array_length, (char **) array_values));
 
-    if (array == NULL)
-        return NULL;
+    if (!array)
+        return nullptr;
 
     if (!JS_DefineProperty(context, in_object, array_name, array, attrs))
-        return NULL;
+        return nullptr;
 
     return array;
 }
@@ -374,7 +374,7 @@ _gjs_g_utf8_make_valid (const char *name)
 
     g_return_val_if_fail (name != NULL, NULL);
 
-    string = NULL;
+    string = nullptr;
     remainder = name;
     remaining_bytes = strlen (name);
 
@@ -383,7 +383,7 @@ _gjs_g_utf8_make_valid (const char *name)
             break;
         valid_bytes = invalid - remainder;
 
-        if (string == NULL)
+        if (!string)
             string = g_string_sized_new (remaining_bytes);
 
         g_string_append_len (string, remainder, valid_bytes);
@@ -394,7 +394,7 @@ _gjs_g_utf8_make_valid (const char *name)
         remainder = invalid + 1;
     }
 
-    if (string == NULL)
+    if (!string)
         return g_strdup (name);
 
     g_string_append (string, remainder);
@@ -427,7 +427,7 @@ gjs_value_debug_string(JSContext      *context,
 
     JS::RootedString str(context, JS::ToString(context, value));
 
-    if (str == NULL) {
+    if (!str) {
         if (value.isObject()) {
             /* Specifically the Call object (see jsfun.c in spidermonkey)
              * does not have a toString; there may be others also.
@@ -436,7 +436,7 @@ gjs_value_debug_string(JSContext      *context,
             if (klass != NULL) {
                 str = JS_NewStringCopyZ(context, klass->name);
                 JS_ClearPendingException(context);
-                if (str == NULL) {
+                if (!str) {
                     JS_EndRequest(context);
                     return g_strdup("[out of memory copying class name]");
                 }
@@ -451,7 +451,7 @@ gjs_value_debug_string(JSContext      *context,
         }
     }
 
-    g_assert(str != NULL);
+    g_assert(str);
 
     bytes = JS_EncodeStringToUTF8(context, str);
     JS_EndRequest(context);
@@ -468,7 +468,7 @@ utf8_exception_from_non_gerror_value(JSContext      *cx,
 {
     GjsAutoJSChar utf8_exception(cx);
     JS::RootedString exc_str(cx, JS::ToString(cx, exc));
-    if (exc_str != NULL)
+    if (exc_str)
         gjs_string_to_utf8(cx, JS::StringValue(exc_str), &utf8_exception);
     return utf8_exception.copy();
 }
@@ -511,7 +511,7 @@ gjs_log_exception_full(JSContext       *context,
         }
     }
 
-    if (message != NULL)
+    if (message)
         gjs_string_to_utf8(context, JS::StringValue(message), &utf8_message);
 
     /* We log syntax errors differently, because the stack for those includes
@@ -536,7 +536,7 @@ gjs_log_exception_full(JSContext       *context,
 
         lineNumber = js_lineNumber.toInt32();
 
-        if (message != NULL) {
+        if (message) {
             g_critical("JS ERROR: %s: %s @ %s:%u", utf8_message.get(), utf8_exception,
                        utf8_filename.get(), lineNumber);
         } else {
@@ -557,7 +557,7 @@ gjs_log_exception_full(JSContext       *context,
             have_utf8_stack = true;
         }
 
-        if (message != nullptr) {
+        if (message) {
             if (have_utf8_stack)
                 g_warning("JS ERROR: %s: %s\n%s", utf8_message.get(), utf8_exception, utf8_stack.get());
             else
diff --git a/gi/arg.cpp b/gi/arg.cpp
index d5aa0c30..ec95e770 100644
--- a/gi/arg.cpp
+++ b/gi/arg.cpp
@@ -595,7 +595,7 @@ gjs_array_from_strv(JSContext             *context,
     }
 
     JS::RootedObject obj(context, JS_NewArrayObject(context, elems));
-    if (obj == NULL)
+    if (!obj)
         return false;
 
     value_p.setObject(*obj);
@@ -2188,7 +2188,7 @@ gjs_array_from_g_list (JSContext             *context,
     }
 
     JS::RootedObject obj(context, JS_NewArrayObject(context, elems));
-    if (obj == NULL)
+    if (!obj)
         return false;
 
     value_p.setObject(*obj);
@@ -2221,7 +2221,7 @@ gjs_array_from_carray_internal (JSContext             *context,
 
         JS::RootedObject obj(context,
             gjs_byte_array_from_byte_array(context, &gbytearray));
-        if (obj == NULL)
+        if (!obj)
             return false;
         value_p.setObject(*obj);
         return true;
@@ -2325,7 +2325,7 @@ gjs_array_from_carray_internal (JSContext             *context,
 #undef ITERATE
 
     JS::RootedObject obj(context, JS_NewArrayObject(context, elems));
-    if (obj == NULL)
+    if (!obj)
         return false;
 
     value_p.setObject(*obj);
@@ -2434,7 +2434,7 @@ gjs_array_from_zero_terminated_c_array (JSContext             *context,
 
         JS::RootedObject obj(context,
             gjs_byte_array_from_byte_array(context, &gbytearray));
-        if (obj == NULL)
+        if (!obj)
             return false;
         value_p.setObject(*obj);
         return true;
@@ -2515,7 +2515,7 @@ gjs_array_from_zero_terminated_c_array (JSContext             *context,
 #undef ITERATE
 
     JS::RootedObject obj(context, JS_NewArrayObject(context, elems));
-    if (obj == NULL)
+    if (!obj)
         return false;
 
     value_p.setObject(*obj);
@@ -2541,7 +2541,7 @@ gjs_object_from_g_hash (JSContext             *context,
     }
 
     JS::RootedObject obj(context, JS_NewPlainObject(context));
-    if (obj == NULL)
+    if (!obj)
         return false;
 
     value_p.setObject(*obj);
diff --git a/gi/boxed.cpp b/gi/boxed.cpp
index 33f9e78d..8053ec1b 100644
--- a/gi/boxed.cpp
+++ b/gi/boxed.cpp
@@ -561,7 +561,7 @@ get_nested_interface_object(JSContext             *context,
 
     obj = JS_NewObjectWithGivenProto(context, JS_GetClass(proto), proto);
 
-    if (obj == NULL)
+    if (!obj)
         return false;
 
     GJS_INC_COUNTER(boxed);
@@ -1257,7 +1257,7 @@ gjs_c_struct_from_boxed(JSContext       *context,
 {
     Boxed *priv;
 
-    if (obj == NULL)
+    if (!obj)
         return NULL;
 
     priv = priv_from_js(context, obj);
diff --git a/gi/closure.cpp b/gi/closure.cpp
index d2780d71..3041cce4 100644
--- a/gi/closure.cpp
+++ b/gi/closure.cpp
@@ -109,8 +109,8 @@ global_context_finalized(JS::HandleObject obj,
                       "which calls object %p",
                       c, c->obj.get());
 
-    if (c->obj != NULL) {
-        g_assert(c->obj == obj);
+    if (c->obj) {
+        g_assert(c->obj == obj.get());
 
         invalidate_js_pointers(gc);
     }
diff --git a/gi/enumeration.cpp b/gi/enumeration.cpp
index 4ca32c91..0eb56c15 100644
--- a/gi/enumeration.cpp
+++ b/gi/enumeration.cpp
@@ -165,7 +165,7 @@ gjs_define_enumeration(JSContext       *context,
     enum_name = g_base_info_get_name( (GIBaseInfo*) info);
 
     JS::RootedObject enum_obj(context, JS_NewPlainObject(context));
-    if (enum_obj == NULL) {
+    if (!enum_obj) {
         g_error("Could not create enumeration %s.%s",
                	g_base_info_get_namespace( (GIBaseInfo*) info),
                 enum_name);
diff --git a/gi/function.cpp b/gi/function.cpp
index f6abeeb8..83213617 100644
--- a/gi/function.cpp
+++ b/gi/function.cpp
@@ -1689,7 +1689,7 @@ function_new(JSContext      *context,
 
     JS::RootedObject function(context,
         JS_NewObjectWithGivenProto(context, &gjs_function_class, proto));
-    if (function == NULL) {
+    if (!function) {
         gjs_debug(GJS_DEBUG_GFUNCTION, "Failed to construct function");
         return NULL;
     }
@@ -1726,7 +1726,7 @@ gjs_define_function(JSContext       *context,
     JSAutoRequest ar(context);
 
     JS::RootedObject function(context, function_new(context, gtype, info));
-    if (function == NULL)
+    if (!function)
         return NULL;
 
     if (info_type == GI_INFO_TYPE_FUNCTION) {
diff --git a/gi/fundamental.cpp b/gi/fundamental.cpp
index 6ddfae66..3a939056 100644
--- a/gi/fundamental.cpp
+++ b/gi/fundamental.cpp
@@ -612,7 +612,7 @@ gjs_lookup_fundamental_prototype(JSContext    *context,
         constructor = &value.toObject();
     }
 
-    g_assert(constructor != NULL);
+    g_assert(constructor);
 
     if (!gjs_object_get_property(context, constructor,
                                  GJS_STRING_PROTOTYPE, &value))
@@ -772,7 +772,7 @@ gjs_object_from_g_fundamental(JSContext    *context,
 
     object = JS_NewObjectWithGivenProto(context, JS_GetClass(proto), proto);
 
-    if (object == NULL)
+    if (!object)
         goto out;
 
     init_fundamental_instance(context, object);
@@ -814,7 +814,7 @@ gjs_g_fundamental_from_object(JSContext       *context,
 {
     FundamentalInstance *priv;
 
-    if (obj == NULL)
+    if (!obj)
         return NULL;
 
     priv = priv_from_js(context, obj);
diff --git a/gi/gerror.cpp b/gi/gerror.cpp
index 849b2c26..766e0182 100644
--- a/gi/gerror.cpp
+++ b/gi/gerror.cpp
@@ -470,7 +470,7 @@ gjs_gerror_from_error(JSContext       *context,
 {
     Error *priv;
 
-    if (obj == NULL)
+    if (!obj)
         return NULL;
 
     /* If this is a plain GBoxed (i.e. a GError without metadata),
diff --git a/gi/ns.cpp b/gi/ns.cpp
index b041f13b..a6a910b7 100644
--- a/gi/ns.cpp
+++ b/gi/ns.cpp
@@ -190,7 +190,7 @@ ns_new(JSContext    *context,
 
     JS::RootedObject ns(context,
         JS_NewObjectWithGivenProto(context, &gjs_ns_class, proto));
-    if (ns == NULL)
+    if (!ns)
         g_error("No memory to create ns object");
 
     priv = g_slice_new0(Ns);
diff --git a/gi/object.cpp b/gi/object.cpp
index 647b5f27..5718ae5e 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -1363,7 +1363,7 @@ G_GNUC_END_IGNORE_DEPRECATIONS
     free_g_params(&params[0], params.size());
 
     ObjectInstance *other_priv = get_object_qdata(gobj);
-    if (other_priv && other_priv->keep_alive != object) {
+    if (other_priv && other_priv->keep_alive != object.get()) {
         /* g_object_newv returned an object that's already tracked by a JS
          * object. Let's assume this is a singleton like IBus.IBus and return
          * the existing JS wrapper object.
@@ -1589,7 +1589,7 @@ gjs_lookup_object_constructor_from_info(JSContext    *context,
         constructor = &value.toObject();
     }
 
-    g_assert(constructor != NULL);
+    g_assert(constructor);
 
     return constructor;
 }
@@ -1602,7 +1602,7 @@ gjs_lookup_object_prototype_from_info(JSContext    *context,
     JS::RootedObject constructor(context,
         gjs_lookup_object_constructor_from_info(context, info, gtype));
 
-    if (G_UNLIKELY (constructor == NULL))
+    if (G_UNLIKELY(!constructor))
         return NULL;
 
     JS::RootedValue value(context);
@@ -1963,7 +1963,7 @@ gjs_define_object_class(JSContext              *context,
     const char *ns;
     GType parent_type;
 
-    g_assert(in_object != NULL);
+    g_assert(in_object);
     g_assert(gtype != G_TYPE_INVALID);
 
     /*   http://egachine.berlios.de/embedding-sm-best-practice/apa.html
@@ -2080,7 +2080,7 @@ gjs_object_from_g_object(JSContext    *context,
 
         JS::RootedObject obj(context,
             JS_NewObjectWithGivenProto(context, JS_GetClass(proto), proto));
-        if (obj == NULL)
+        if (!obj)
             return nullptr;
 
         priv = init_object_private(context, obj);
@@ -2091,7 +2091,7 @@ gjs_object_from_g_object(JSContext    *context,
         /* see the comment in init_object_instance() for this */
         g_object_unref(gobj);
 
-        g_assert(priv->keep_alive == obj);
+        g_assert(priv->keep_alive == obj.get());
     }
 
     return priv->keep_alive;
@@ -2103,7 +2103,7 @@ gjs_g_object_from_object(JSContext       *context,
 {
     ObjectInstance *priv;
 
-    if (obj == NULL)
+    if (!obj)
         return NULL;
 
     priv = priv_from_js(context, obj);
@@ -2820,7 +2820,7 @@ gjs_register_interface(JSContext *cx,
 
     /* create a custom JSClass */
     JS::RootedObject module(cx, gjs_lookup_private_namespace(cx));
-    if (module == NULL)
+    if (!module)
         return false;  /* error will have been thrown already */
 
     JS::RootedObject constructor(cx);
diff --git a/gi/param.cpp b/gi/param.cpp
index c8ff6f2e..af2f6475 100644
--- a/gi/param.cpp
+++ b/gi/param.cpp
@@ -189,7 +189,7 @@ gjs_lookup_param_prototype(JSContext    *context)
         return NULL;
 
     JS::RootedObject constructor(context, &value.toObject());
-    g_assert(constructor != NULL);
+    g_assert(constructor);
 
     if (!gjs_object_get_property(context, constructor,
                                  GJS_STRING_PROTOTYPE, &value))
@@ -280,7 +280,7 @@ gjs_g_param_from_param(JSContext       *context,
 {
     Param *priv;
 
-    if (obj == NULL)
+    if (!obj)
         return NULL;
 
     priv = priv_from_js(context, obj);
diff --git a/gi/repo.cpp b/gi/repo.cpp
index 6af10462..fac0d625 100644
--- a/gi/repo.cpp
+++ b/gi/repo.cpp
@@ -770,7 +770,7 @@ gjs_lookup_generic_prototype(JSContext  *context,
 {
     JS::RootedObject constructor(context,
                                  gjs_lookup_generic_constructor(context, info));
-    if (G_UNLIKELY (constructor == NULL))
+    if (G_UNLIKELY(!constructor))
         return NULL;
 
     JS::RootedValue value(context);
diff --git a/gi/union.cpp b/gi/union.cpp
index 50214ff0..22369ee7 100644
--- a/gi/union.cpp
+++ b/gi/union.cpp
@@ -422,7 +422,7 @@ gjs_c_union_from_union(JSContext       *context,
 {
     Union *priv;
 
-    if (obj == NULL)
+    if (!obj)
         return NULL;
 
     priv = priv_from_js(context, obj);
diff --git a/modules/cairo-pattern.cpp b/modules/cairo-pattern.cpp
index 2f386af9..f24e11d7 100644
--- a/modules/cairo-pattern.cpp
+++ b/modules/cairo-pattern.cpp
@@ -114,7 +114,7 @@ gjs_cairo_pattern_construct(JSContext       *context,
     GjsCairoPattern *priv;
 
     g_return_if_fail(context != NULL);
-    g_return_if_fail(object != NULL);
+    g_return_if_fail(object != nullptr);
     g_return_if_fail(pattern != NULL);
 
     priv = g_slice_new0(GjsCairoPattern);
diff --git a/modules/cairo-surface.cpp b/modules/cairo-surface.cpp
index 22c9ef06..749adbae 100644
--- a/modules/cairo-surface.cpp
+++ b/modules/cairo-surface.cpp
@@ -150,7 +150,7 @@ gjs_cairo_surface_construct(JSContext       *context,
     GjsCairoSurface *priv;
 
     g_return_if_fail(context != NULL);
-    g_return_if_fail(object != NULL);
+    g_return_if_fail(object != nullptr);
     g_return_if_fail(surface != NULL);
 
     priv = g_slice_new0(GjsCairoSurface);

From c2c1454e003bc61e935a12e3a59c37a93ef94708 Mon Sep 17 00:00:00 2001
From: "luke.nukem.jones@gmail.com" <luke.nukem.jones@gmail.com>
Date: Sun, 30 Jul 2017 14:10:00 -0700
Subject: [PATCH 087/154] Backport of patch required for vectors MOZ_MUST_USE
 returns

https://bugzilla.gnome.org/show_bug.cgi?id=785424
---
 cjs/importer.cpp   |  9 ++++++---
 cjs/jsapi-util.cpp | 10 +++++++---
 cjs/module.cpp     |  4 +++-
 gi/arg.cpp         | 20 ++++++++++++++------
 gi/function.cpp    | 16 ++++++++++++----
 gi/repo.cpp        |  6 ++----
 gi/value.cpp       |  7 +++++--
 7 files changed, 49 insertions(+), 23 deletions(-)

diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index d53b5b07..95e3a9c1 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -377,7 +377,8 @@ load_module_elements(JSContext        *cx,
         return;
 
     for (ix = 0, length = ids.length(); ix < length; ix++)
-        prop_ids.append(ids[ix]);
+        if (!prop_ids.append(ids[ix]))
+            g_error("Unable to append to vector");
 }
 
 /* If error, returns false. If not found, returns true but does not touch
@@ -725,12 +726,14 @@ importer_enumerate(JSContext        *context,
                 continue;
 
             if (g_file_info_get_file_type(info) == G_FILE_TYPE_DIRECTORY) {
-                properties.append(gjs_intern_string_to_id(context, filename));
+                if (!properties.append(gjs_intern_string_to_id(context, filename)))
+                    g_error("Unable to append to vector");
             } else if (g_str_has_suffix(filename, "." G_MODULE_SUFFIX) ||
                        g_str_has_suffix(filename, ".js")) {
                 GjsAutoChar filename_noext =
                     g_strndup(filename, strlen(filename) - 3);
-                properties.append(gjs_intern_string_to_id(context, filename_noext));
+                if (!properties.append(gjs_intern_string_to_id(context, filename_noext)))
+                    g_error("Unable to append to vector");
             }
         }
     }
diff --git a/cjs/jsapi-util.cpp b/cjs/jsapi-util.cpp
index 8627cb7a..57e4cb43 100644
--- a/cjs/jsapi-util.cpp
+++ b/cjs/jsapi-util.cpp
@@ -287,12 +287,14 @@ gjs_build_string_array(JSContext   *context,
         array_length = g_strv_length(array_values);
 
     JS::AutoValueVector elems(context);
-    elems.reserve(array_length);
+    if (!elems.reserve(array_length))
+        g_error("Unable to reserve memory for vector");
 
     for (i = 0; i < array_length; ++i) {
         JS::RootedValue element(context,
             JS::StringValue(JS_NewStringCopyZ(context, array_values[i])));
-        elems.append(element);
+        if (!elems.append(element))
+            g_error("Unable to append to vector");
     }
 
     return JS_NewArrayObject(context, elems);
@@ -839,7 +841,9 @@ gjs_eval_with_scope(JSContext             *context,
         return false;
 
     JS::AutoObjectVector scope_chain(context);
-    scope_chain.append(eval_obj);
+    if (!scope_chain.append(eval_obj))
+        g_error("Unable to append to vector");
+
     if (!JS_ExecuteScript(context, scope_chain, compiled_script, retval))
         return false;
 
diff --git a/cjs/module.cpp b/cjs/module.cpp
index 6b03c967..b476848d 100644
--- a/cjs/module.cpp
+++ b/cjs/module.cpp
@@ -96,7 +96,9 @@ class GjsModule {
             return false;
 
         JS::AutoObjectVector scope_chain(cx);
-        scope_chain.append(module);
+        if (!scope_chain.append(module))
+            g_error("Unable to append to vector");
+
         JS::RootedValue ignored_retval(cx);
         if (!JS_ExecuteScript(cx, scope_chain, compiled_script, &ignored_retval))
             return false;
diff --git a/gi/arg.cpp b/gi/arg.cpp
index ec95e770..b63d97b5 100644
--- a/gi/arg.cpp
+++ b/gi/arg.cpp
@@ -589,7 +589,9 @@ gjs_array_from_strv(JSContext             *context,
      * the case.
      */
     for (i = 0; strv != NULL && strv[i] != NULL; i++) {
-        elems.growBy(1);
+        if (!elems.growBy(1))
+            g_error("Unable to grow vector");
+
         if (!gjs_string_from_utf8(context, strv[i], -1, elems[i]))
             return false;
     }
@@ -974,7 +976,9 @@ gjs_array_from_flat_gvalue_array(JSContext             *context,
     GValue *values = (GValue *)array;
     unsigned int i;
     JS::AutoValueVector elems(context);
-    elems.resize(length);
+    if (!elems.resize(length))
+        g_error("Unable to resize vector");
+
     bool result = true;
 
     for (i = 0; i < length; i ++) {
@@ -2168,7 +2172,8 @@ gjs_array_from_g_list (JSContext             *context,
     if (list_tag == GI_TYPE_TAG_GLIST) {
         for ( ; list != NULL; list = list->next) {
             arg.v_pointer = list->data;
-            elems.growBy(1);
+            if (!elems.growBy(1))
+                g_error("Unable to grow vector");
 
             if (!gjs_value_from_g_argument(context, elems[i], param_info, &arg,
                                            true))
@@ -2178,7 +2183,8 @@ gjs_array_from_g_list (JSContext             *context,
     } else {
         for ( ; slist != NULL; slist = slist->next) {
             arg.v_pointer = slist->data;
-            elems.growBy(1);
+            if (!elems.growBy(1))
+                g_error("Unable to grow vector");
 
             if (!gjs_value_from_g_argument(context, elems[i], param_info, &arg,
                                            true))
@@ -2232,7 +2238,8 @@ gjs_array_from_carray_internal (JSContext             *context,
         return gjs_string_from_ucs4(context, (gunichar *) array, length, value_p);
 
     JS::AutoValueVector elems(context);
-    elems.resize(length);
+    if (!elems.resize(length))
+        g_error("Unable to resize vector");
 
 #define ITERATE(type) \
     for (i = 0; i < length; i++) { \
@@ -2451,7 +2458,8 @@ gjs_array_from_zero_terminated_c_array (JSContext             *context,
         g##type *array = (g##type *) c_array; \
         for (i = 0; array[i]; i++) { \
             arg.v_##type = array[i]; \
-            elems.growBy(1);                                            \
+            if (!elems.growBy(1))                                       \
+                g_error("Unable to grow vector");                       \
             if (!gjs_value_from_g_argument(context, elems[i],           \
                                            param_info, &arg, true))     \
                 return false; \
diff --git a/gi/function.cpp b/gi/function.cpp
index 83213617..38831ab7 100644
--- a/gi/function.cpp
+++ b/gi/function.cpp
@@ -216,7 +216,10 @@ gjs_callback_closure(ffi_cif *cif,
 
     n_outargs = 0;
     JS::AutoValueVector jsargs(context);
-    jsargs.reserve(n_args);
+
+    if (!jsargs.reserve(n_args))
+        g_error("Unable to reserve space for vector");
+
     JS::RootedValue rval(context);
     JS::RootedValue rooted_function(context, trampoline->js_function);
     JS::RootedObject this_object(context);
@@ -259,14 +262,18 @@ gjs_callback_closure(ffi_cif *cif,
                                                (GArgument *) args[array_length_pos], true))
                     goto out;
 
-                jsargs.growBy(1);
+                if (!jsargs.growBy(1))
+                    g_error("Unable to grow vector");
+
                 if (!gjs_value_from_explicit_array(context, jsargs[n_jsargs++],
                                                    &type_info, (GArgument*) args[i], length.toInt32()))
                     goto out;
                 break;
             }
             case PARAM_NORMAL:
-                jsargs.growBy(1);
+                if (!jsargs.growBy(1))
+                    g_error("Unable to grow vector");
+
                 if (!gjs_value_from_g_argument(context, jsargs[n_jsargs++],
                                                &type_info,
                                                (GArgument *) args[i], false))
@@ -1044,7 +1051,8 @@ gjs_invoke_c_function(JSContext                             *context,
     /* Only process return values if the function didn't throw */
     if (function->js_out_argc > 0 && !did_throw_gerror) {
         for (size_t i = 0; i < function->js_out_argc; i++)
-            return_values.append(JS::UndefinedValue());
+            if (!return_values.append(JS::UndefinedValue()))
+                g_error("Unable to append to vector");
 
         if (return_tag != GI_TYPE_TAG_VOID) {
             GITransfer transfer = g_callable_info_get_caller_owns((GICallableInfo*) function->info);
diff --git a/gi/repo.cpp b/gi/repo.cpp
index fac0d625..5e74e556 100644
--- a/gi/repo.cpp
+++ b/gi/repo.cpp
@@ -250,10 +250,8 @@ repo_new(JSContext *context)
 
     JS::RootedObject repo(context,
         JS_NewObjectWithGivenProto(context, &gjs_repo_class, proto));
-    if (repo == NULL) {
-        gjs_throw(context, "No memory to create repo object");
-        return NULL;
-    }
+    if (repo == nullptr)
+        g_error("No memory to create repo object");
 
     priv = g_slice_new0(Repo);
 
diff --git a/gi/value.cpp b/gi/value.cpp
index 30f68e14..af04cf8c 100644
--- a/gi/value.cpp
+++ b/gi/value.cpp
@@ -221,7 +221,9 @@ closure_marshal(GClosure        *closure,
     }
 
     JS::AutoValueVector argv(context);
-    argv.reserve(n_param_values);  /* May end up being less */
+    /* May end up being less */
+    if (!argv.reserve(n_param_values))
+        g_error("Unable to reserve space");
     JS::RootedValue argv_to_append(context);
     for (i = 0; i < n_param_values; ++i) {
         const GValue *gval = &param_values[i];
@@ -262,7 +264,8 @@ closure_marshal(GClosure        *closure,
             return;
         }
 
-        argv.append(argv_to_append);
+        if (!argv.append(argv_to_append))
+            g_error("Unable to append to vector");
     }
 
     for (i = 1; i < n_param_values; i++)

From 61851e123e447dd3f9ff689bf21abde0314316ed Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 22:56:35 -0500
Subject: [PATCH 088/154] Revert "js: Workaround for function with custom
 prototype"

This reverts commit 72c0298c5f9df9036ed67fd504db84cbc028daaa.
The warning that was the reason for this code in the first place was
removed in SpiderMonkey 52. According to
https://bugzilla.mozilla.org/show_bug.cgi?id=1049041 the warning was out
of date, and there are only performance effects "if the object escapes to
somewhere interesting before getting its final __proto__".

In addition, client code should move to ES6 classes which do not have
this performance problem.

Edited to resolve conflicts due to code being moved around in the
meantime, and to use Object.setPrototypeOf() instead of the deprecated
__proto__ property.

https://bugzilla.gnome.org/show_bug.cgi?id=785652

https://github.com/GNOME/gjs/commit/70ac571aadd982077b210dcd805e085cb671e89e
---
 cjs/global.cpp                  |   4 +-
 cjs/jsapi-constructor-proxy.cpp | 190 ----------------------------------------
 cjs/jsapi-constructor-proxy.h   |  38 --------
 cjs/jsapi-wrapper.h             |   2 +-
 cjs/mem.cpp                     |   4 +-
 cjs/mem.h                       |   1 -
 gjs-srcs.mk                     |   2 -
 modules/lang.js                 |  19 ++--
 modules/overrides/GObject.js    |  18 ++--
 util/log.cpp                    |   3 -
 util/log.h                      |   1 -
 11 files changed, 21 insertions(+), 261 deletions(-)
 delete mode 100644 cjs/jsapi-constructor-proxy.cpp
 delete mode 100644 cjs/jsapi-constructor-proxy.h

diff --git a/cjs/global.cpp b/cjs/global.cpp
index 0a65a48d..7d41273a 100644
--- a/cjs/global.cpp
+++ b/cjs/global.cpp
@@ -27,7 +27,6 @@
 
 #include "global.h"
 #include "importer.h"
-#include "jsapi-constructor-proxy.h"
 #include "jsapi-util.h"
 #include "jsapi-wrapper.h"
 
@@ -230,8 +229,7 @@ class GjsGlobal {
     {
         if (!JS_DefineProperty(cx, global, "window", global,
                                JSPROP_READONLY | JSPROP_PERMANENT) ||
-            !JS_DefineFunctions(cx, global, GjsGlobal::static_funcs) ||
-            !gjs_define_constructor_proxy_factory(cx, global))
+            !JS_DefineFunctions(cx, global, GjsGlobal::static_funcs))
             return false;
 
         JS::Value v_importer = gjs_get_global_slot(cx, GJS_GLOBAL_SLOT_IMPORTS);
diff --git a/cjs/jsapi-constructor-proxy.cpp b/cjs/jsapi-constructor-proxy.cpp
deleted file mode 100644
index a7631e43..00000000
--- a/cjs/jsapi-constructor-proxy.cpp
+++ /dev/null
@@ -1,190 +0,0 @@
-/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; -*- */
-/*
- * Copyright (c) 2016 Endless Mobile, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- *
- * Authored by: Philip Chimento <philip@endlessm.com>
- */
-
-#include "jsapi-wrapper.h"
-#include <jswrapper.h>
-
-#include "jsapi-constructor-proxy.h"
-#include "jsapi-util.h"
-#include "mem.h"
-#include "util/log.h"
-
-/* This code exposes a __private_GjsConstructorProxy function to JS, which is
- * approximately equivalent to
- *
- * function __private_GjsConstructorProxy(constructor, prototype) {
- *     let my_prototype = prototype;
- *     return new Proxy(constructor, {
- *         getPrototypeOf: function (target) { return my_prototype; },
- *     });
- * }
- *
- * but with a C++-only flag that routes all property accesses through the
- * getPrototypeOf() trap, which may or may not be turned on in JS proxies,
- * I'm not sure.
- *
- * COMPAT: SpiderMonkey doesn't support the getPrototype() trap in JS
- * proxies yet. That has yet to be released, in the upcoming SpiderMonkey 52.
- * When that is available, then this whole file can be discontinued.
- *
- * That is the reason for the existence of this C++ file, but the reason why it
- * is needed at all is because of Lang.Class and GObject.Class. We must give
- * class objects (e.g. "const MyClass = new Lang.Class({...})") a custom
- * prototype, so that "MyClass instanceof Lang.Class" will be true, and MyClass
- * will have methods from Class.
- *
- * Usually you would give an object a custom prototype using Object.create(),
- * but that's not possible for function or constructor objects, and MyClass of
- * course must be a constructor. Previously we solved this with
- * Object.setPrototypeOf(), but that has performance effects on any code that
- * uses objects whose prototypes have been altered [1], and SpiderMonkey started
- * printing conspicuous warnings about it.
- *
- * [1] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf
- */
-
-static const char constructor_proxy_create_name[] = "__private_GjsConstructorProxy";
-
-enum {
-    SLOT_PROTO,
-};
-
-/* This class is the C++ equivalent of a proxy handler object. In JS, that is
- * the second argument passed to the "new Proxy(target, handler)" constructor.
- */
-class GjsConstructorHandler : public js::Wrapper {
-    static inline JSObject *
-    proto(JS::HandleObject proxy)
-    {
-        return &js::GetProxyExtra(proxy, SLOT_PROTO).toObject();
-    }
-
-public:
-    GjsConstructorHandler()
-    : js::Wrapper(0 /* flags */, true /* hasPrototype */)
-    { }
-
-    bool
-    getPrototype(JSContext              *cx,
-                 JS::HandleObject        proxy,
-                 JS::MutableHandleObject proto_p)
-    const override
-    {
-        proto_p.set(proto(proxy));
-        return true;
-    }
-
-    /* This is called when the associated proxy object is finalized, not the
-     * handler itself */
-    void
-    finalize(JSFreeOp *fop,
-             JSObject *proxy)
-    const override
-    {
-        GJS_DEC_COUNTER(constructor_proxy);
-        gjs_debug_lifecycle(GJS_DEBUG_PROXY,
-                            "constructor proxy %p destroyed", proxy);
-    }
-
-    bool
-    isCallable(JSObject *obj)
-    const override
-    {
-        return true;
-    }
-
-    bool
-    isConstructor(JSObject *obj)
-    const override
-    {
-        return true;
-    }
-
-    static GjsConstructorHandler&
-    singleton(void)
-    {
-        static GjsConstructorHandler the_singleton;
-        return the_singleton;
-    }
-};
-
-/* Visible to JS as __private_GjsConstructorProxy(constructor, prototype) */
-static bool
-create_gjs_constructor_proxy(JSContext *cx,
-                             unsigned   argc,
-                             JS::Value *vp)
-{
-    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
-
-    if (args.length() < 2) {
-        gjs_throw(cx, "Expected 2 arguments to %s, got %d",
-                  constructor_proxy_create_name, args.length());
-        return false;
-    }
-
-    if (!args[0].isObject() || !JS::IsConstructor(&args[0].toObject())) {
-        gjs_throw(cx, "First argument must be a constructor");
-        return false;
-    }
-    if (!args[1].isObject()) {
-        gjs_throw(cx, "Second argument must be a prototype object");
-        return false;
-    }
-
-    JS::RootedObject proxy(cx,
-        js::NewProxyObject(cx, &GjsConstructorHandler::singleton(), args[0],
-                           &args[1].toObject()));
-    /* We stick this extra object into one of the proxy object's "extra slots",
-     * even though it is private data of the proxy handler. This is because
-     * proxy handlers cannot have trace callbacks. The proxy object does have a
-     * built-in trace callback which traces the "extra slots", so this object
-     * will be kept alive. This also means the handler has no private state at
-     * all, so it can be a singleton. */
-    js::SetProxyExtra(proxy, SLOT_PROTO, args[1]);
-
-    args.rval().setObject(*proxy);
-
-    GJS_INC_COUNTER(constructor_proxy);
-    gjs_debug_lifecycle(GJS_DEBUG_PROXY,
-                        "created constructor proxy %p", proxy.get());
-    return true;
-}
-
-bool
-gjs_define_constructor_proxy_factory(JSContext       *cx,
-                                     JS::HandleObject global)
-{
-    bool found;
-    if (!JS_HasProperty(cx, global, constructor_proxy_create_name, &found))
-        return false;
-    if (found)
-        return true;
-    if (!JS_DefineFunction(cx, global, constructor_proxy_create_name,
-        create_gjs_constructor_proxy, 2, JSPROP_READONLY | JSPROP_PERMANENT))
-        return false;
-
-    gjs_debug(GJS_DEBUG_PROXY, "Initialized constructor proxy factory");
-    return true;
-}
diff --git a/cjs/jsapi-constructor-proxy.h b/cjs/jsapi-constructor-proxy.h
deleted file mode 100644
index bc45b072..00000000
--- a/cjs/jsapi-constructor-proxy.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; -*- */
-/*
- * Copyright (c) 2016 Endless Mobile, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef GJS_JSAPI_CONSTRUCTOR_PROXY_H
-#define GJS_JSAPI_CONSTRUCTOR_PROXY_H
-
-#include <glib.h>
-
-#include "jsapi-wrapper.h"
-
-G_BEGIN_DECLS
-
-bool gjs_define_constructor_proxy_factory(JSContext       *cx,
-                                          JS::HandleObject global);
-
-G_END_DECLS
-
-#endif /* GJS_JSAPI_CONSTRUCTOR_PROXY_H */
diff --git a/cjs/jsapi-wrapper.h b/cjs/jsapi-wrapper.h
index 11bdadbd..bdc7245c 100644
--- a/cjs/jsapi-wrapper.h
+++ b/cjs/jsapi-wrapper.h
@@ -40,7 +40,7 @@
 #endif
 #include <mozilla/Maybe.h>
 #include <jsapi.h>
+#include <jsfriendapi.h>
 #include <js/Conversions.h>
-#include <js/Proxy.h>  /* For jsapi-constructor-proxy */
 
 #endif  /* GJS_JSAPI_WRAPPER_H */
diff --git a/cjs/mem.cpp b/cjs/mem.cpp
index 77adeff0..1ed251b9 100644
--- a/cjs/mem.cpp
+++ b/cjs/mem.cpp
@@ -48,7 +48,6 @@ GJS_DEFINE_COUNTER(repo)
 GJS_DEFINE_COUNTER(resultset)
 GJS_DEFINE_COUNTER(weakhash)
 GJS_DEFINE_COUNTER(interface)
-GJS_DEFINE_COUNTER(constructor_proxy)
 
 #define GJS_LIST_COUNTER(name) \
     & gjs_counter_ ## name
@@ -67,8 +66,7 @@ static GjsMemCounter* counters[] = {
     GJS_LIST_COUNTER(repo),
     GJS_LIST_COUNTER(resultset),
     GJS_LIST_COUNTER(weakhash),
-    GJS_LIST_COUNTER(interface),
-    GJS_LIST_COUNTER(constructor_proxy),
+    GJS_LIST_COUNTER(interface)
 };
 
 void
diff --git a/cjs/mem.h b/cjs/mem.h
index 4d484cbb..eac576db 100644
--- a/cjs/mem.h
+++ b/cjs/mem.h
@@ -54,7 +54,6 @@ GJS_DECLARE_COUNTER(repo)
 GJS_DECLARE_COUNTER(resultset)
 GJS_DECLARE_COUNTER(weakhash)
 GJS_DECLARE_COUNTER(interface)
-GJS_DECLARE_COUNTER(constructor_proxy)
 
 #define GJS_INC_COUNTER(name)                \
     do {                                        \
diff --git a/gjs-srcs.mk b/gjs-srcs.mk
index 8c69355a..16916a54 100644
--- a/gjs-srcs.mk
+++ b/gjs-srcs.mk
@@ -61,8 +61,6 @@ gjs_srcs =				\
 	cjs/importer.cpp		\
 	cjs/importer.h			\
 	cjs/jsapi-class.h		\
-	cjs/jsapi-constructor-proxy.cpp	\
-	cjs/jsapi-constructor-proxy.h	\
 	cjs/jsapi-dynamic-class.cpp	\
 	cjs/jsapi-private.cpp		\
 	cjs/jsapi-private.h		\
diff --git a/modules/lang.js b/modules/lang.js
index 0df22dcc..09571589 100644
--- a/modules/lang.js
+++ b/modules/lang.js
@@ -201,28 +201,27 @@ Class.prototype._construct = function(params) {
     if (!parent)
         parent = _Base;
 
-    let newClassConstructor;
+    let newClass;
     if (params.Abstract) {
-        newClassConstructor = function() {
+        newClass = function() {
             throw new TypeError('Cannot instantiate abstract class ' + name);
         };
     } else {
-        newClassConstructor = function() {
+        newClass = function() {
             this.__caller__ = null;
 
             return this._construct.apply(this, arguments);
         };
     }
 
-    // This is our workaround for creating a constructor with a custom
-    // prototype. See jsapi-constructor-proxy.cpp.
-    let newClass = __private_GjsConstructorProxy(newClassConstructor,
-        this.constructor.prototype);
+    // Since it's not possible to create a constructor with
+    // a custom [[Prototype]], we have to do this to make
+    // "newClass instanceof Class" work, and so we can inherit
+    // methods/properties of Class.prototype, like wrapFunction.
+    Object.setPrototypeOf(newClass, this.constructor.prototype);
 
     newClass.__super__ = parent;
-    // Here we have to set this property on newClassConstructor directly because
-    // otherwise the 'prototype' property on the proxy isn't configurable
-    newClassConstructor.prototype = Object.create(parent.prototype);
+    newClass.prototype = Object.create(parent.prototype);
     newClass.prototype.constructor = newClass;
 
     newClass._init.apply(newClass, arguments);
diff --git a/modules/overrides/GObject.js b/modules/overrides/GObject.js
index 303623c3..2206f08d 100644
--- a/modules/overrides/GObject.js
+++ b/modules/overrides/GObject.js
@@ -141,14 +141,13 @@ const GObjectMeta = new Lang.Class({
         let propertiesArray = _propertiesAsArray(params);
         delete params.Properties;
 
-        let newClassConstructor = Gi.register_type(parent.prototype, gtypename,
+        let newClass = Gi.register_type(parent.prototype, gtypename,
             gobjectInterfaces, propertiesArray);
 
-        let newClass = __private_GjsConstructorProxy(newClassConstructor,
-            this.constructor.prototype);
-
+        // See Class.prototype._construct in lang.js for the reasoning
+        // behind this direct prototype set.
+        Object.setPrototypeOf(newClass, this.constructor.prototype);
         newClass.__super__ = parent;
-        newClass.prototype.constructor = newClass;
 
         newClass._init.apply(newClass, arguments);
 
@@ -206,11 +205,12 @@ GObjectInterface.prototype._construct = function (params) {
     let properties = _propertiesAsArray(params);
     delete params.Properties;
 
-    let newInterfaceConstructor = Gi.register_interface(gtypename,
-        gobjectInterfaces, properties);
+    let newInterface = Gi.register_interface(gtypename, gobjectInterfaces,
+        properties);
 
-    let newInterface = __private_GjsConstructorProxy(newInterfaceConstructor,
-       this.constructor.prototype);
+    // See Class.prototype._construct in lang.js for the reasoning
+    // behind this direct prototype set.
+    Object.setPrototypeOf(newInterface, this.constructor.prototype);
     newInterface.__super__ = GObjectInterface;
     newInterface.prototype.constructor = newInterface;
 
diff --git a/util/log.cpp b/util/log.cpp
index 1f59e14e..afd3aa11 100644
--- a/util/log.cpp
+++ b/util/log.cpp
@@ -238,9 +238,6 @@ _Pragma("GCC diagnostic pop")
     case GJS_DEBUG_GERROR:
         prefix = "JS G ERR";
         break;
-    case GJS_DEBUG_PROXY:
-        prefix = "JS CPROXY";
-        break;
     default:
         prefix = "???";
         break;
diff --git a/util/log.h b/util/log.h
index 4eb56e4c..1d5d298d 100644
--- a/util/log.h
+++ b/util/log.h
@@ -58,7 +58,6 @@ typedef enum {
     GJS_DEBUG_BYTE_ARRAY,
     GJS_DEBUG_GERROR,
     GJS_DEBUG_GFUNDAMENTAL,
-    GJS_DEBUG_PROXY,
 } GjsDebugTopic;
 
 /* These defines are because we have some pretty expensive and

From a018dbb349d75bba022f295dd92a5c779d9858b5 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 23 Jul 2017 19:09:22 -0700
Subject: [PATCH 089/154] Revert "build: Allow compiling without RTTI"

This reverts commit eccf3a14b9b0d6aae89baeaa32dd53f07b2b77d7.

We don't need to match SpiderMonkey here anymore, since we don't inherit
from a SpiderMonkey-defined class.

https://bugzilla.gnome.org/show_bug.cgi?id=785652
---
 configure.ac | 10 ----------
 1 file changed, 10 deletions(-)

diff --git a/configure.ac b/configure.ac
index 158fcd8a..154c4814 100644
--- a/configure.ac
+++ b/configure.ac
@@ -216,16 +216,6 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
 ])
 CPPFLAGS="$CPPFLAGS_save"
 
-dnl If SpiderMonkey was compiled with this configure option, then GJS needs to
-dnl be compiled with it as well, because we inherit from a SpiderMonkey class in
-dnl jsapi-constructor-proxy.cpp. See build/autoconf/compiler-opts.m4 in mozjs31.
-AC_ARG_ENABLE([cpp-rtti],
-  [AS_HELP_STRING([--enable-cpp-rtti],
-    [needs to match SpiderMonkey's config option @<:@default=off@:>@])])
-AS_IF([test "x$enable_cpp_rtti" != "xyes"],
-  [AX_APPEND_COMPILE_FLAGS([-fno-rtti])],
-  [AX_APPEND_COMPILE_FLAGS([-GR-])])
-
 AC_ARG_WITH([xvfb-tests],
   [AS_HELP_STRING([--with-xvfb-tests],
     [Run all tests under an XVFB server @<:@default=no@:>@])])

From 242955a49579844a560721b1811fdcafe117219a Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 23:01:57 -0500
Subject: [PATCH 090/154] lang: Move all legacy Lang.Class code

This moves Lang.Class into a separate Legacy module, which is not meant
to be imported directly; instead, Lang imports it and exports the same
members that it always did.

Also moves all tests for the legacy Lang.Class into a separate file. It
is named testLegacyClass in order to indicate that it tests legacy code.

https://bugzilla.gnome.org/show_bug.cgi?id=785652

Based on https://github.com/GNOME/gjs/commit/78a021e95fe114aac0dc168e65462dc8b829d18d
---
 Makefile-test.am                                   |   4 +-
 installed-tests/js/testClass.js                    | 206 -----------
 installed-tests/js/testLang.js                     |   2 +-
 .../js/{testInterface.js => testLegacyClass.js}    | 319 +++++++++++++++-
 installed-tests/js/testMetaClass.js                | 117 ------
 modules/_legacy.js                                 | 399 +++++++++++++++++++++
 modules/lang.js                                    | 394 +-------------------
 modules/modules.gresource.xml                      |   1 +
 modules/overrides/GObject.js                       |   7 +-
 9 files changed, 727 insertions(+), 722 deletions(-)
 delete mode 100644 installed-tests/js/testClass.js
 rename installed-tests/js/{testInterface.js => testLegacyClass.js} (58%)
 delete mode 100644 installed-tests/js/testMetaClass.js
 create mode 100644 modules/_legacy.js

diff --git a/Makefile-test.am b/Makefile-test.am
index 509b5925..410f7cec 100644
--- a/Makefile-test.am
+++ b/Makefile-test.am
@@ -218,7 +218,6 @@ CLEANFILES += $(TEST_INTROSPECTION_GIRS) $(TEST_INTROSPECTION_TYPELIBS)
 common_jstests_files =						\
 	installed-tests/js/testself.js				\
 	installed-tests/js/testByteArray.js			\
-	installed-tests/js/testClass.js				\
 	installed-tests/js/testCoverage.js			\
 	installed-tests/js/testExceptions.js			\
 	installed-tests/js/testEverythingBasic.js		\
@@ -233,11 +232,10 @@ common_jstests_files =						\
 	installed-tests/js/testGTypeClass.js			\
 	installed-tests/js/testGio.js				\
 	installed-tests/js/testImporter.js			\
-	installed-tests/js/testInterface.js			\
 	installed-tests/js/testLang.js				\
+	installed-tests/js/testLegacyClass.js			\
 	installed-tests/js/testLocale.js			\
 	installed-tests/js/testMainloop.js			\
-	installed-tests/js/testMetaClass.js			\
 	installed-tests/js/testNamespace.js			\
 	installed-tests/js/testPackage.js			\
 	installed-tests/js/testParamSpec.js			\
diff --git a/installed-tests/js/testClass.js b/installed-tests/js/testClass.js
deleted file mode 100644
index dfac15c2..00000000
--- a/installed-tests/js/testClass.js
+++ /dev/null
@@ -1,206 +0,0 @@
-// -*- mode: js; indent-tabs-mode: nil -*-
-
-const Lang = imports.lang;
-
-const MagicBase = new Lang.Class({
-    Name: 'MagicBase',
-
-    _init: function(a, buffer) {
-        if (buffer) buffer.push(a);
-        this.a = a;
-    },
-
-    foo: function(a, buffer) {
-        buffer.push(a);
-        return a * 3;
-    },
-
-    bar: function(a) {
-        return a * 5;
-    }
-});
-
-const Magic = new Lang.Class({
-    Name: 'Magic',
-
-    Extends: MagicBase,
-
-    _init: function(a, b, buffer) {
-        this.parent(a, buffer);
-        if (buffer) buffer.push(b);
-        this.b = b;
-    },
-
-    foo: function(a, b, buffer) {
-        let val = this.parent(a, buffer);
-        buffer.push(b);
-        return val * 2;
-    },
-
-    bar: function(a, buffer) {
-        this.foo(a, 2*a, buffer);
-        return this.parent(a);
-    }
-});
-
-const Accessor = new Lang.Class({
-    Name: 'AccessorMagic',
-
-    _init: function(val) {
-        this._val = val;
-    },
-
-    get value() {
-        return this._val;
-    },
-
-    set value(val) {
-        if (val != 42)
-            throw TypeError('Value is not a magic number');
-        this._val = val;
-    }
-});
-
-const AbstractBase = new Lang.Class({
-    Name: 'AbstractBase',
-    Abstract: true,
-
-    _init: function() {
-        this.foo = 42;
-    }
-});
-
-describe('Class framework', function () {
-    it('calls _init constructors', function () {
-        let newMagic = new MagicBase('A');
-        expect(newMagic.a).toEqual('A');
-    });
-
-    it('calls parent constructors', function () {
-        let buffer = [];
-
-        let newMagic = new Magic('a', 'b', buffer);
-        expect(buffer).toEqual(['a', 'b']);
-
-        buffer = [];
-        let val = newMagic.foo(10, 20, buffer);
-        expect(buffer).toEqual([10, 20]);
-        expect(val).toEqual(10 * 6);
-    });
-
-    it('sets the right constructor properties', function () {
-        expect(Magic.prototype.constructor).toBe(Magic);
-
-        let newMagic = new Magic();
-        expect(newMagic.constructor).toBe(Magic);
-    });
-
-    it('sets up instanceof correctly', function () {
-        let newMagic = new Magic();
-
-        expect(newMagic instanceof Magic).toBeTruthy();
-        expect(newMagic instanceof MagicBase).toBeTruthy();
-    });
-
-    it('reports a sensible value for toString()', function () {
-        let newMagic = new MagicBase();
-        expect(newMagic.toString()).toEqual('[object MagicBase]');
-    });
-
-    it('allows overriding toString()', function () {
-        const ToStringOverride = new Lang.Class({
-            Name: 'ToStringOverride',
-
-            toString: function() {
-                let oldToString = this.parent();
-                return oldToString + '; hello';
-            }
-        });
-
-        let override = new ToStringOverride();
-        expect(override.toString()).toEqual('[object ToStringOverride]; hello');
-    });
-
-    it('is not configurable', function () {
-        let newMagic = new MagicBase();
-
-        delete newMagic.foo;
-        expect(newMagic.foo).toBeDefined();
-    });
-
-    it('allows accessors for properties', function () {
-        let newAccessor = new Accessor(11);
-
-        expect(newAccessor.value).toEqual(11);
-        expect(() => newAccessor.value = 12).toThrow();
-
-        newAccessor.value = 42;
-        expect(newAccessor.value).toEqual(42);
-    });
-
-    it('raises an exception when creating an abstract class', function () {
-        expect(() => new AbstractBase()).toThrow();
-    });
-
-    it('inherits properties from abstract base classes', function () {
-        const AbstractImpl = new Lang.Class({
-            Name: 'AbstractImpl',
-            Extends: AbstractBase,
-
-            _init: function() {
-                this.parent();
-                this.bar = 42;
-            }
-        });
-
-        let newAbstract = new AbstractImpl();
-        expect(newAbstract.foo).toEqual(42);
-        expect(newAbstract.bar).toEqual(42);
-    });
-
-    it('inherits constructors from abstract base classes', function () {
-        const AbstractImpl = new Lang.Class({
-            Name: 'AbstractImpl',
-            Extends: AbstractBase,
-        });
-
-        let newAbstract = new AbstractImpl();
-        expect(newAbstract.foo).toEqual(42);
-    });
-
-    it('lets methods call other methods without clobbering __caller__', function () {
-        let newMagic = new Magic();
-        let buffer = [];
-
-        let res = newMagic.bar(10, buffer);
-        expect(buffer).toEqual([10, 20]);
-        expect(res).toEqual(50);
-    });
-
-    it('allows custom return values from constructors', function () {
-        const CustomConstruct = new Lang.Class({
-            Name: 'CustomConstruct',
-
-            _construct: function(one, two) {
-                return [one, two];
-            }
-        });
-
-        let instance = new CustomConstruct(1, 2);
-
-        expect(instance instanceof Array).toBeTruthy();
-        expect(instance instanceof CustomConstruct).toBeFalsy();
-        expect(instance).toEqual([1, 2]);
-    });
-
-    it('allows symbol-named methods', function () {
-        const SymbolClass = new Lang.Class({
-            Name: 'SymbolClass',
-            *[Symbol.iterator]() {
-                yield* [1, 2, 3];
-            },
-        });
-        let instance = new SymbolClass();
-        expect([...instance]).toEqual([1, 2, 3]);
-    });
-});
diff --git a/installed-tests/js/testLang.js b/installed-tests/js/testLang.js
index 51874bdc..1e0d3079 100644
--- a/installed-tests/js/testLang.js
+++ b/installed-tests/js/testLang.js
@@ -1,5 +1,5 @@
 // tests for imports.lang module
-// except for Lang.Class and Lang.Interface, which are tested in separate files
+// except for Lang.Class and Lang.Interface, which are tested in testLegacyClass
 
 const Lang = imports.lang;
 
diff --git a/installed-tests/js/testInterface.js b/installed-tests/js/testLegacyClass.js
similarity index 58%
rename from installed-tests/js/testInterface.js
rename to installed-tests/js/testLegacyClass.js
index 08f3b942..178c2d48 100644
--- a/installed-tests/js/testInterface.js
+++ b/installed-tests/js/testLegacyClass.js
@@ -2,6 +2,323 @@
 
 const Lang = imports.lang;
 
+const NormalClass = new Lang.Class({
+    Name: 'NormalClass',
+
+    _init: function() {
+        this.one = 1;
+    }
+});
+
+let Subclassed = [];
+const MetaClass = new Lang.Class({
+    Name: 'MetaClass',
+    Extends: Lang.Class,
+
+    _init: function(params) {
+        Subclassed.push(params.Name);
+        this.parent(params);
+
+        if (params.Extended) {
+            this.prototype.dynamic_method = this.wrapFunction('dynamic_method', function() {
+                return 73;
+            });
+
+            this.DYNAMIC_CONSTANT = 2;
+        }
+    }
+});
+
+const CustomMetaOne = new MetaClass({
+    Name: 'CustomMetaOne',
+    Extends: NormalClass,
+    Extended: false,
+
+    _init: function() {
+        this.parent();
+
+        this.two = 2;
+    }
+});
+
+const CustomMetaTwo = new MetaClass({
+    Name: 'CustomMetaTwo',
+    Extends: NormalClass,
+    Extended: true,
+
+    _init: function() {
+        this.parent();
+
+        this.two = 2;
+    }
+});
+
+// This should inherit CustomMeta, even though
+// we use Lang.Class
+const CustomMetaSubclass = new Lang.Class({
+    Name: 'CustomMetaSubclass',
+    Extends: CustomMetaOne,
+    Extended: true,
+
+    _init: function() {
+        this.parent();
+
+        this.three = 3;
+    }
+});
+
+describe('A metaclass', function () {
+    it('has its constructor called each time a class is created with it', function () {
+        expect(Subclassed).toEqual(['CustomMetaOne', 'CustomMetaTwo',
+            'CustomMetaSubclass']);
+    });
+
+    it('is an instance of Lang.Class', function () {
+        expect(NormalClass instanceof Lang.Class).toBeTruthy();
+        expect(MetaClass instanceof Lang.Class).toBeTruthy();
+    });
+
+    it('produces instances that are instances of itself and Lang.Class', function () {
+        expect(CustomMetaOne instanceof Lang.Class).toBeTruthy();
+        expect(CustomMetaOne instanceof MetaClass).toBeTruthy();
+    });
+
+    it('can dynamically define properties in its constructor', function () {
+        expect(CustomMetaTwo.DYNAMIC_CONSTANT).toEqual(2);
+        expect(CustomMetaOne.DYNAMIC_CONSTANT).not.toBeDefined();
+    });
+
+    describe('instance', function () {
+        let instanceOne, instanceTwo;
+        beforeEach(function () {
+            instanceOne = new CustomMetaOne();
+            instanceTwo = new CustomMetaTwo();
+        });
+
+        it('gets all the properties from its class and metaclass', function () {
+            expect(instanceOne).toEqual(jasmine.objectContaining({ one: 1, two: 2 }));
+            expect(instanceTwo).toEqual(jasmine.objectContaining({ one: 1, two: 2 }));
+        });
+
+        it('gets dynamically defined properties from metaclass', function () {
+            expect(() => instanceOne.dynamic_method()).toThrow();
+            expect(instanceTwo.dynamic_method()).toEqual(73);
+        });
+    });
+
+    it('can be instantiated with Lang.Class but still get the appropriate metaclass', function () {
+        expect(CustomMetaSubclass instanceof MetaClass).toBeTruthy();
+        expect(CustomMetaSubclass.DYNAMIC_CONSTANT).toEqual(2);
+
+        let instance = new CustomMetaSubclass();
+        expect(instance).toEqual(jasmine.objectContaining({ one: 1, two: 2, three: 3 }));
+        expect(instance.dynamic_method()).toEqual(73);
+    });
+});
+
+const MagicBase = new Lang.Class({
+    Name: 'MagicBase',
+
+    _init: function(a, buffer) {
+        if (buffer) buffer.push(a);
+        this.a = a;
+    },
+
+    foo: function(a, buffer) {
+        buffer.push(a);
+        return a * 3;
+    },
+
+    bar: function(a) {
+        return a * 5;
+    }
+});
+
+const Magic = new Lang.Class({
+    Name: 'Magic',
+
+    Extends: MagicBase,
+
+    _init: function(a, b, buffer) {
+        this.parent(a, buffer);
+        if (buffer) buffer.push(b);
+        this.b = b;
+    },
+
+    foo: function(a, b, buffer) {
+        let val = this.parent(a, buffer);
+        buffer.push(b);
+        return val * 2;
+    },
+
+    bar: function(a, buffer) {
+        this.foo(a, 2*a, buffer);
+        return this.parent(a);
+    }
+});
+
+const Accessor = new Lang.Class({
+    Name: 'AccessorMagic',
+
+    _init: function(val) {
+        this._val = val;
+    },
+
+    get value() {
+        return this._val;
+    },
+
+    set value(val) {
+        if (val != 42)
+            throw TypeError('Value is not a magic number');
+        this._val = val;
+    }
+});
+
+const AbstractBase = new Lang.Class({
+    Name: 'AbstractBase',
+    Abstract: true,
+
+    _init: function() {
+        this.foo = 42;
+    }
+});
+
+describe('Class framework', function () {
+    it('calls _init constructors', function () {
+        let newMagic = new MagicBase('A');
+        expect(newMagic.a).toEqual('A');
+    });
+
+    it('calls parent constructors', function () {
+        let buffer = [];
+
+        let newMagic = new Magic('a', 'b', buffer);
+        expect(buffer).toEqual(['a', 'b']);
+
+        buffer = [];
+        let val = newMagic.foo(10, 20, buffer);
+        expect(buffer).toEqual([10, 20]);
+        expect(val).toEqual(10 * 6);
+    });
+
+    it('sets the right constructor properties', function () {
+        expect(Magic.prototype.constructor).toBe(Magic);
+
+        let newMagic = new Magic();
+        expect(newMagic.constructor).toBe(Magic);
+    });
+
+    it('sets up instanceof correctly', function () {
+        let newMagic = new Magic();
+
+        expect(newMagic instanceof Magic).toBeTruthy();
+        expect(newMagic instanceof MagicBase).toBeTruthy();
+    });
+
+    it('reports a sensible value for toString()', function () {
+        let newMagic = new MagicBase();
+        expect(newMagic.toString()).toEqual('[object MagicBase]');
+    });
+
+    it('allows overriding toString()', function () {
+        const ToStringOverride = new Lang.Class({
+            Name: 'ToStringOverride',
+
+            toString: function() {
+                let oldToString = this.parent();
+                return oldToString + '; hello';
+            }
+        });
+
+        let override = new ToStringOverride();
+        expect(override.toString()).toEqual('[object ToStringOverride]; hello');
+    });
+
+    it('is not configurable', function () {
+        let newMagic = new MagicBase();
+
+        delete newMagic.foo;
+        expect(newMagic.foo).toBeDefined();
+    });
+
+    it('allows accessors for properties', function () {
+        let newAccessor = new Accessor(11);
+
+        expect(newAccessor.value).toEqual(11);
+        expect(() => newAccessor.value = 12).toThrow();
+
+        newAccessor.value = 42;
+        expect(newAccessor.value).toEqual(42);
+    });
+
+    it('raises an exception when creating an abstract class', function () {
+        expect(() => new AbstractBase()).toThrow();
+    });
+
+    it('inherits properties from abstract base classes', function () {
+        const AbstractImpl = new Lang.Class({
+            Name: 'AbstractImpl',
+            Extends: AbstractBase,
+
+            _init: function() {
+                this.parent();
+                this.bar = 42;
+            }
+        });
+
+        let newAbstract = new AbstractImpl();
+        expect(newAbstract.foo).toEqual(42);
+        expect(newAbstract.bar).toEqual(42);
+    });
+
+    it('inherits constructors from abstract base classes', function () {
+        const AbstractImpl = new Lang.Class({
+            Name: 'AbstractImpl',
+            Extends: AbstractBase,
+        });
+
+        let newAbstract = new AbstractImpl();
+        expect(newAbstract.foo).toEqual(42);
+    });
+
+    it('lets methods call other methods without clobbering __caller__', function () {
+        let newMagic = new Magic();
+        let buffer = [];
+
+        let res = newMagic.bar(10, buffer);
+        expect(buffer).toEqual([10, 20]);
+        expect(res).toEqual(50);
+    });
+
+    it('allows custom return values from constructors', function () {
+        const CustomConstruct = new Lang.Class({
+            Name: 'CustomConstruct',
+
+            _construct: function(one, two) {
+                return [one, two];
+            }
+        });
+
+        let instance = new CustomConstruct(1, 2);
+
+        expect(instance instanceof Array).toBeTruthy();
+        expect(instance instanceof CustomConstruct).toBeFalsy();
+        expect(instance).toEqual([1, 2]);
+    });
+
+    it('allows symbol-named methods', function () {
+        const SymbolClass = new Lang.Class({
+            Name: 'SymbolClass',
+            *[Symbol.iterator]() {
+                yield* [1, 2, 3];
+            },
+        });
+        let instance = new SymbolClass();
+        expect([...instance]).toEqual([1, 2, 3]);
+    });
+});
+
 const AnInterface = new Lang.Interface({
     Name: 'AnInterface',
 
@@ -119,7 +436,7 @@ describe('An interface', function () {
 
     it("can be implemented by a class's superclass", function () {
         const ChildWhoseParentImplementsAnInterface = new Lang.Class({
-            Name: "ChildWhoseParentImplementsAnInterface",
+            Name: 'ChildWhoseParentImplementsAnInterface',
             Extends: ObjectImplementingAnInterface
         });
         let obj = new ChildWhoseParentImplementsAnInterface();
diff --git a/installed-tests/js/testMetaClass.js b/installed-tests/js/testMetaClass.js
deleted file mode 100644
index 48c92a74..00000000
--- a/installed-tests/js/testMetaClass.js
+++ /dev/null
@@ -1,117 +0,0 @@
-// -*- mode: js; indent-tabs-mode: nil -*-
-
-const Lang = imports.lang;
-
-const NormalClass = new Lang.Class({
-    Name: 'NormalClass',
-
-    _init: function() {
-        this.one = 1;
-    }
-});
-
-let Subclassed = [];
-const MetaClass = new Lang.Class({
-    Name: 'MetaClass',
-    Extends: Lang.Class,
-
-    _init: function(params) {
-        Subclassed.push(params.Name);
-        this.parent(params);
-
-        if (params.Extended) {
-            this.prototype.dynamic_method = this.wrapFunction('dynamic_method', function() {
-                return 73;
-            });
-
-            this.DYNAMIC_CONSTANT = 2;
-        }
-    }
-});
-
-const CustomMetaOne = new MetaClass({
-    Name: 'CustomMetaOne',
-    Extends: NormalClass,
-    Extended: false,
-
-    _init: function() {
-        this.parent();
-
-        this.two = 2;
-    }
-});
-
-const CustomMetaTwo = new MetaClass({
-    Name: 'CustomMetaTwo',
-    Extends: NormalClass,
-    Extended: true,
-
-    _init: function() {
-        this.parent();
-
-        this.two = 2;
-    }
-});
-
-// This should inherit CustomMeta, even though
-// we use Lang.Class
-const CustomMetaSubclass = new Lang.Class({
-    Name: 'CustomMetaSubclass',
-    Extends: CustomMetaOne,
-    Extended: true,
-
-    _init: function() {
-        this.parent();
-
-        this.three = 3;
-    }
-});
-
-describe('A metaclass', function () {
-    it('has its constructor called each time a class is created with it', function () {
-        expect(Subclassed).toEqual(['CustomMetaOne', 'CustomMetaTwo',
-            'CustomMetaSubclass']);
-    });
-
-    it('is an instance of Lang.Class', function () {
-        expect(NormalClass instanceof Lang.Class).toBeTruthy();
-        expect(MetaClass instanceof Lang.Class).toBeTruthy();
-    });
-
-    it('produces instances that are instances of itself and Lang.Class', function () {
-        expect(CustomMetaOne instanceof Lang.Class).toBeTruthy();
-        expect(CustomMetaOne instanceof MetaClass).toBeTruthy();
-    });
-
-    it('can dynamically define properties in its constructor', function () {
-        expect(CustomMetaTwo.DYNAMIC_CONSTANT).toEqual(2);
-        expect(CustomMetaOne.DYNAMIC_CONSTANT).not.toBeDefined();
-    });
-
-    describe('instance', function () {
-        let instanceOne, instanceTwo;
-        beforeEach(function () {
-            instanceOne = new CustomMetaOne();
-            instanceTwo = new CustomMetaTwo();
-        });
-
-        it('gets all the properties from its class and metaclass', function () {
-            expect(instanceOne).toEqual(jasmine.objectContaining({ one: 1, two: 2 }));
-            expect(instanceTwo).toEqual(jasmine.objectContaining({ one: 1, two: 2 }));
-        });
-
-        it('gets dynamically defined properties from metaclass', function () {
-            expect(() => instanceOne.dynamic_method()).toThrow();
-            expect(instanceTwo.dynamic_method()).toEqual(73);
-        });
-    });
-
-    it('can be instantiated with Lang.Class but still get the appropriate metaclass', function () {
-        expect(CustomMetaSubclass instanceof MetaClass).toBeTruthy();
-        expect(CustomMetaSubclass.DYNAMIC_CONSTANT).toEqual(2);
-
-        let instance = new CustomMetaSubclass();
-        expect(instance).toEqual(jasmine.objectContaining({ one: 1, two: 2, three: 3 }));
-        expect(instance.dynamic_method()).toEqual(73);
-    });
-});
diff --git a/modules/_legacy.js b/modules/_legacy.js
new file mode 100644
index 00000000..83a91361
--- /dev/null
+++ b/modules/_legacy.js
@@ -0,0 +1,399 @@
+/* -*- mode: js; indent-tabs-mode: nil; -*- */
+/* exported Class, Interface */
+// Copyright 2008  litl, LLC
+// Copyright 2011  Jasper St. Pierre
+
+// Class magic
+// Adapted from MooTools, MIT license
+// https://github.com/mootools/mootools-core
+
+function _Base() {
+    throw new TypeError('Cannot instantiate abstract class _Base');
+}
+
+_Base.__super__ = null;
+_Base.prototype._init = function() { };
+_Base.prototype._construct = function() {
+    this._init.apply(this, arguments);
+    return this;
+};
+_Base.prototype.__name__ = '_Base';
+_Base.prototype.toString = function() {
+    return '[object ' + this.__name__ + ']';
+};
+
+function _parent() {
+    if (!this.__caller__)
+        throw new TypeError("The method 'parent' cannot be called");
+
+    let caller = this.__caller__;
+    let name = caller._name;
+    let parent = caller._owner.__super__;
+
+    let previous = parent ? parent.prototype[name] : undefined;
+
+    if (!previous)
+        throw new TypeError("The method '" + name + "' is not on the superclass");
+
+    return previous.apply(this, arguments);
+}
+
+function _interfacePresent(required, proto) {
+    if (!proto.__interfaces__)
+        return false;
+    if (proto.__interfaces__.indexOf(required) !== -1)
+        return true;  // implemented here
+    // Might be implemented on a parent class
+    return _interfacePresent(required, proto.constructor.__super__.prototype);
+}
+
+function getMetaClass(params) {
+    if (params.MetaClass)
+        return params.MetaClass;
+
+    if (params.Extends && params.Extends.prototype.__metaclass__)
+        return params.Extends.prototype.__metaclass__;
+
+    return null;
+}
+
+function Class(params) {
+    let metaClass = getMetaClass(params);
+
+    if (metaClass && metaClass != this.constructor) {
+        return new metaClass(...arguments);
+    } else {
+        return this._construct.apply(this, arguments);
+    }
+}
+
+Class.__super__ = _Base;
+Class.prototype = Object.create(_Base.prototype);
+Class.prototype.constructor = Class;
+Class.prototype.__name__ = 'Class';
+
+Class.prototype.wrapFunction = function(name, meth) {
+    if (meth._origin) meth = meth._origin;
+
+    function wrapper() {
+        let prevCaller = this.__caller__;
+        this.__caller__ = wrapper;
+        let result = meth.apply(this, arguments);
+        this.__caller__ = prevCaller;
+        return result;
+    }
+
+    wrapper._origin = meth;
+    wrapper._name = name;
+    wrapper._owner = this;
+
+    return wrapper;
+};
+
+Class.prototype.toString = function() {
+    return '[object ' + this.__name__ + ' for ' + this.prototype.__name__ + ']';
+};
+
+Class.prototype._construct = function(params) {
+    if (!params.Name) {
+        throw new TypeError("Classes require an explicit 'Name' parameter.");
+    }
+    let name = params.Name;
+
+    let parent = params.Extends;
+    if (!parent)
+        parent = _Base;
+
+    let newClass;
+    if (params.Abstract) {
+        newClass = function() {
+            throw new TypeError('Cannot instantiate abstract class ' + name);
+        };
+    } else {
+        newClass = function() {
+            this.__caller__ = null;
+
+            return this._construct.apply(this, arguments);
+        };
+    }
+
+    // Since it's not possible to create a constructor with
+    // a custom [[Prototype]], we have to do this to make
+    // "newClass instanceof Class" work, and so we can inherit
+    // methods/properties of Class.prototype, like wrapFunction.
+    Object.setPrototypeOf(newClass, this.constructor.prototype);
+
+    newClass.__super__ = parent;
+    newClass.prototype = Object.create(parent.prototype);
+    newClass.prototype.constructor = newClass;
+
+    newClass._init.apply(newClass, arguments);
+
+    let interfaces = params.Implements || [];
+    // If the parent already implements an interface, then we do too
+    if (parent instanceof Class)
+        interfaces = interfaces.filter((iface) => !parent.implements(iface));
+
+    Object.defineProperties(newClass.prototype, {
+        '__metaclass__': {
+            writable: false,
+            configurable: false,
+            enumerable: false,
+            value: this.constructor,
+        },
+        '__interfaces__': {
+            writable: false,
+            configurable: false,
+            enumerable: false,
+            value: interfaces,
+        },
+    });
+
+    interfaces.forEach((iface) => {
+        iface._check(newClass.prototype);
+    });
+
+    return newClass;
+};
+
+/**
+ * Check whether this class conforms to the interface "iface".
+ * @param {object} iface a Lang.Interface
+ * @returns: whether this class implements iface
+ * @type: boolean
+ */
+Class.prototype.implements = function (iface) {
+    if (_interfacePresent(iface, this.prototype))
+        return true;
+    if (this.__super__ instanceof Class)
+        return this.__super__.implements(iface);
+    return false;
+};
+
+// key can be either a string or a symbol
+Class.prototype._copyPropertyDescriptor = function(params, propertyObj, key) {
+    let descriptor = Object.getOwnPropertyDescriptor(params, key);
+
+    if (typeof descriptor.value === 'function')
+        descriptor.value = this.wrapFunction(key, descriptor.value);
+
+    // we inherit writable and enumerable from the property
+    // descriptor of params (they're both true if created from an
+    // object literal)
+    descriptor.configurable = false;
+
+    propertyObj[key] = descriptor;
+};
+
+Class.prototype._init = function(params) {
+    let name = params.Name;
+
+    let propertyObj = { };
+
+    let interfaces = params.Implements || [];
+    interfaces.forEach((iface) => {
+        Object.getOwnPropertyNames(iface.prototype)
+        .filter((name) => !name.startsWith('__') && name !== 'constructor')
+        .filter((name) => !(name in this.prototype))
+        .forEach((name) => {
+            let descriptor = Object.getOwnPropertyDescriptor(iface.prototype,
+                name);
+            // writable and enumerable are inherited, see note above
+            descriptor.configurable = false;
+            propertyObj[name] = descriptor;
+        });
+    });
+
+    Object.getOwnPropertyNames(params)
+    .filter(name =>
+        ['Name', 'Extends', 'Abstract', 'Implements'].indexOf(name) === -1)
+    .concat(Object.getOwnPropertySymbols(params))
+    .forEach(this._copyPropertyDescriptor.bind(this, params, propertyObj));
+
+    Object.defineProperties(this.prototype, propertyObj);
+    Object.defineProperties(this.prototype, {
+        '__name__': {
+            writable: false,
+            configurable: false,
+            enumerable: false,
+            value: name,
+        },
+        'parent': {
+            writable: false,
+            configurable: false,
+            enumerable: false,
+            value: _parent,
+        },
+    });
+};
+
+// This introduces the concept of a "meta-interface" which is given by the
+// MetaInterface property on an object's metaclass. For objects whose metaclass
+// is Lang.Class, the meta-interface is Lang.Interface. Subclasses of Lang.Class
+// such as GObject.Class supply their own meta-interface.
+// This is in order to enable creating GObject interfaces with Lang.Interface,
+// much as you can create GObject classes with Lang.Class.
+function _getMetaInterface(params) {
+    if (!params.Requires || params.Requires.length === 0)
+        return null;
+
+    let metaInterface = params.Requires.map((req) => {
+        if (req instanceof Interface)
+            return req.__super__;
+        for (let metaclass = req.prototype.__metaclass__; metaclass;
+            metaclass = metaclass.__super__) {
+            if (metaclass.hasOwnProperty('MetaInterface'))
+                return metaclass.MetaInterface;
+        }
+        return null;
+    })
+    .reduce((best, candidate) => {
+        // This function reduces to the "most derived" meta interface in the list.
+        if (best === null)
+            return candidate;
+        if (candidate === null)
+            return best;
+        for (let sup = candidate; sup; sup = sup.__super__) {
+            if (sup === best)
+                return candidate;
+        }
+        return best;
+    }, null);
+
+    // If we reach this point and we don't know the meta-interface, then it's
+    // most likely because there were only pure-C interfaces listed in Requires
+    // (and those don't have our magic properties.) However, all pure-C
+    // interfaces should require GObject.Object anyway.
+    if (metaInterface === null)
+        throw new Error('Did you forget to include GObject.Object in Requires?');
+
+    return metaInterface;
+}
+
+function Interface(params) {
+    let metaInterface = _getMetaInterface(params);
+    if (metaInterface && metaInterface !== this.constructor)
+        return new metaInterface(...arguments);
+    return this._construct.apply(this, arguments);
+}
+
+Class.MetaInterface = Interface;
+
+/**
+ * Use this to signify a function that must be overridden in an implementation
+ * of the interface. Creating a class that doesn't override the function will
+ * throw an error.
+ */
+Interface.UNIMPLEMENTED = function UNIMPLEMENTED () {
+    throw new Error('Not implemented');
+};
+
+Interface.__super__ = _Base;
+Interface.prototype = Object.create(_Base.prototype);
+Interface.prototype.constructor = Interface;
+Interface.prototype.__name__ = 'Interface';
+
+Interface.prototype._construct = function (params) {
+    if (!params.Name)
+        throw new TypeError("Interfaces require an explicit 'Name' parameter.");
+
+    let newInterface = Object.create(this.constructor.prototype);
+
+    newInterface.__super__ = Interface;
+    newInterface.prototype = Object.create(Interface.prototype);
+    newInterface.prototype.constructor = newInterface;
+    newInterface.prototype.__name__ = params.Name;
+
+    newInterface._init.apply(newInterface, arguments);
+
+    Object.defineProperty(newInterface.prototype, '__metaclass__', {
+        writable: false,
+        configurable: false,
+        enumerable: false,
+        value: this.constructor,
+    });
+
+    return newInterface;
+};
+
+Interface.prototype._check = function (proto) {
+    // Check that proto implements all of this interface's required interfaces.
+    // "proto" refers to the object's prototype (which implements the interface)
+    // whereas "this.prototype" is the interface's prototype (which may still
+    // contain unimplemented methods.)
+
+    let unfulfilledReqs = this.prototype.__requires__.filter((required) => {
+        // Either the interface is not present or it is not listed before the
+        // interface that requires it or the class does not inherit it. This is
+        // so that required interfaces don't copy over properties from other
+        // interfaces that require them.
+        let interfaces = proto.__interfaces__;
+        return ((!_interfacePresent(required, proto) ||
+            interfaces.indexOf(required) > interfaces.indexOf(this)) &&
+            !(proto instanceof required));
+    }).map((required) =>
+        // __name__ is only present on GJS-created classes and will be the most
+        // accurate name. required.name will be present on introspected GObjects
+        // but is not preferred because it will be the C name. The last option
+        // is just so that we print something if there is garbage in Requires.
+        required.prototype.__name__ || required.name || required);
+    if (unfulfilledReqs.length > 0) {
+        throw new Error('The following interfaces must be implemented before ' +
+            this.prototype.__name__ + ': ' + unfulfilledReqs.join(', '));
+    }
+
+    // Check that this interface's required methods are implemented
+    let unimplementedFns = Object.getOwnPropertyNames(this.prototype)
+    .filter((p) => this.prototype[p] === Interface.UNIMPLEMENTED)
+    .filter((p) => !(p in proto) || proto[p] === Interface.UNIMPLEMENTED);
+    if (unimplementedFns.length > 0)
+        throw new Error('The following members of ' + this.prototype.__name__ +
+            ' are not implemented yet: ' + unimplementedFns.join(', '));
+};
+
+Interface.prototype.toString = function () {
+    return '[interface ' + this.__name__ + ' for ' + this.prototype.__name__ + ']';
+};
+
+Interface.prototype._init = function (params) {
+    let name = params.Name;
+
+    let propertyObj = {};
+    Object.getOwnPropertyNames(params)
+    .filter((name) => ['Name', 'Requires'].indexOf(name) === -1)
+    .forEach((name) => {
+        let descriptor = Object.getOwnPropertyDescriptor(params, name);
+
+        // Create wrappers on the interface object so that generics work (e.g.
+        // SomeInterface.some_function(this, blah) instead of
+        // SomeInterface.prototype.some_function.call(this, blah)
+        if (typeof descriptor.value === 'function') {
+            let interfaceProto = this.prototype;  // capture in closure
+            this[name] = function () {
+                return interfaceProto[name].call.apply(interfaceProto[name],
+                    arguments);
+            };
+        }
+
+        // writable and enumerable are inherited, see note in Class._init()
+        descriptor.configurable = false;
+
+        propertyObj[name] = descriptor;
+    });
+
+    Object.defineProperties(this.prototype, propertyObj);
+    Object.defineProperties(this.prototype, {
+        '__name__': {
+            writable: false,
+            configurable: false,
+            enumerable: false,
+            value: name,
+        },
+        '__requires__': {
+            writable: false,
+            configurable: false,
+            enumerable: false,
+            value: params.Requires || [],
+        },
+    });
+};
diff --git a/modules/lang.js b/modules/lang.js
index 09571589..da6d0dcd 100644
--- a/modules/lang.js
+++ b/modules/lang.js
@@ -1,4 +1,6 @@
 /* -*- mode: js; indent-tabs-mode: nil; -*- */
+/* exported Class, Interface, bind, copyProperties, copyPublicProperties,
+countProperties */
 // Copyright (c) 2008  litl, LLC
 //
 // Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -21,7 +23,7 @@
 
 // Utilities that are "meta-language" things like manipulating object props
 
-const Gi = imports._gi;
+var {Class, Interface} = imports._legacy;
 
 function countProperties(obj) {
     let count = 0;
@@ -95,393 +97,3 @@ function bind(obj, callback) {
         return callback.apply(me, args);
     };
 }
-
-// Class magic
-// Adapted from MooTools, MIT license
-// https://github.com/mootools/mootools-core
-
-function _Base() {
-    throw new TypeError('Cannot instantiate abstract class _Base');
-}
-
-_Base.__super__ = null;
-_Base.prototype._init = function() { };
-_Base.prototype._construct = function() {
-    this._init.apply(this, arguments);
-    return this;
-};
-_Base.prototype.__name__ = '_Base';
-_Base.prototype.toString = function() {
-    return '[object ' + this.__name__ + ']';
-};
-
-function _parent() {
-    if (!this.__caller__)
-        throw new TypeError("The method 'parent' cannot be called");
-
-    let caller = this.__caller__;
-    let name = caller._name;
-    let parent = caller._owner.__super__;
-
-    let previous = parent ? parent.prototype[name] : undefined;
-
-    if (!previous)
-        throw new TypeError("The method '" + name + "' is not on the superclass");
-
-    return previous.apply(this, arguments);
-}
-
-function _interfacePresent(required, proto) {
-    if (!proto.__interfaces__)
-        return false;
-    if (proto.__interfaces__.indexOf(required) !== -1)
-        return true;  // implemented here
-    // Might be implemented on a parent class
-    return _interfacePresent(required, proto.constructor.__super__.prototype);
-}
-
-function getMetaClass(params) {
-    if (params.MetaClass)
-        return params.MetaClass;
-
-    if (params.Extends && params.Extends.prototype.__metaclass__)
-        return params.Extends.prototype.__metaclass__;
-
-    return null;
-}
-
-function Class(params) {
-    let metaClass = getMetaClass(params);
-
-    if (metaClass && metaClass != this.constructor) {
-        // Trick to apply variadic arguments to constructors --
-        // bind the arguments into the constructor function.
-        let args = Array.prototype.slice.call(arguments);
-        let curried = Function.prototype.bind.apply(metaClass, [,].concat(args));
-        return new curried();
-    } else {
-        return this._construct.apply(this, arguments);
-    }
-}
-
-Class.__super__ = _Base;
-Class.prototype = Object.create(_Base.prototype);
-Class.prototype.constructor = Class;
-Class.prototype.__name__ = 'Class';
-
-Class.prototype.wrapFunction = function(name, meth) {
-    if (meth._origin) meth = meth._origin;
-
-    function wrapper() {
-        let prevCaller = this.__caller__;
-        this.__caller__ = wrapper;
-        let result = meth.apply(this, arguments);
-        this.__caller__ = prevCaller;
-        return result;
-    }
-
-    wrapper._origin = meth;
-    wrapper._name = name;
-    wrapper._owner = this;
-
-    return wrapper;
-}
-
-Class.prototype.toString = function() {
-    return '[object ' + this.__name__ + ' for ' + this.prototype.__name__ + ']';
-};
-
-Class.prototype._construct = function(params) {
-    if (!params.Name) {
-        throw new TypeError("Classes require an explicit 'Name' parameter.");
-    }
-    let name = params.Name;
-
-    let parent = params.Extends;
-    if (!parent)
-        parent = _Base;
-
-    let newClass;
-    if (params.Abstract) {
-        newClass = function() {
-            throw new TypeError('Cannot instantiate abstract class ' + name);
-        };
-    } else {
-        newClass = function() {
-            this.__caller__ = null;
-
-            return this._construct.apply(this, arguments);
-        };
-    }
-
-    // Since it's not possible to create a constructor with
-    // a custom [[Prototype]], we have to do this to make
-    // "newClass instanceof Class" work, and so we can inherit
-    // methods/properties of Class.prototype, like wrapFunction.
-    Object.setPrototypeOf(newClass, this.constructor.prototype);
-
-    newClass.__super__ = parent;
-    newClass.prototype = Object.create(parent.prototype);
-    newClass.prototype.constructor = newClass;
-
-    newClass._init.apply(newClass, arguments);
-
-    let interfaces = params.Implements || [];
-    // If the parent already implements an interface, then we do too
-    if (parent instanceof Class)
-        interfaces = interfaces.filter((iface) => !parent.implements(iface));
-
-    Object.defineProperties(newClass.prototype, {
-        '__metaclass__': { writable: false,
-                           configurable: false,
-                           enumerable: false,
-                           value: this.constructor },
-        '__interfaces__': { writable: false,
-                            configurable: false,
-                            enumerable: false,
-                            value: interfaces }
-    });
-
-    interfaces.forEach((iface) => {
-        iface._check(newClass.prototype);
-    });
-
-    return newClass;
-};
-
-/**
- * Check whether this class conforms to the interface "iface".
- * @param {object} iface a Lang.Interface
- * @returns: whether this class implements iface
- * @type: boolean
- */
-Class.prototype.implements = function (iface) {
-    if (_interfacePresent(iface, this.prototype))
-        return true;
-    if (this.__super__ instanceof Class)
-        return this.__super__.implements(iface);
-    return false;
-};
-
-// key can be either a string or a symbol
-Class.prototype._copyPropertyDescriptor = function(params, propertyObj, key) {
-    let descriptor = Object.getOwnPropertyDescriptor(params, key);
-
-    if (typeof descriptor.value === 'function')
-        descriptor.value = this.wrapFunction(key, descriptor.value);
-
-    // we inherit writable and enumerable from the property
-    // descriptor of params (they're both true if created from an
-    // object literal)
-    descriptor.configurable = false;
-
-    propertyObj[key] = descriptor;
-};
-
-Class.prototype._init = function(params) {
-    let name = params.Name;
-
-    let propertyObj = { };
-
-    let interfaces = params.Implements || [];
-    interfaces.forEach((iface) => {
-        Object.getOwnPropertyNames(iface.prototype)
-        .filter((name) => !name.startsWith('__') && name !== 'constructor')
-        .filter((name) => !(name in this.prototype))
-        .forEach((name) => {
-            let descriptor = Object.getOwnPropertyDescriptor(iface.prototype,
-                name);
-            // writable and enumerable are inherited, see note above
-            descriptor.configurable = false;
-            propertyObj[name] = descriptor;
-        });
-    });
-
-    Object.getOwnPropertyNames(params)
-        .filter(name =>
-            ['Name', 'Extends', 'Abstract', 'Implements'].indexOf(name) === -1)
-        .concat(Object.getOwnPropertySymbols(params))
-        .forEach(this._copyPropertyDescriptor.bind(this, params, propertyObj));
-
-    Object.defineProperties(this.prototype, propertyObj);
-    Object.defineProperties(this.prototype, {
-        '__name__': { writable: false,
-                      configurable: false,
-                      enumerable: false,
-                      value: name },
-        'parent': { writable: false,
-                    configurable: false,
-                    enumerable: false,
-                    value: _parent }});
-};
-
-// This introduces the concept of a "meta-interface" which is given by the
-// MetaInterface property on an object's metaclass. For objects whose metaclass
-// is Lang.Class, the meta-interface is Lang.Interface. Subclasses of Lang.Class
-// such as GObject.Class supply their own meta-interface.
-// This is in order to enable creating GObject interfaces with Lang.Interface,
-// much as you can create GObject classes with Lang.Class.
-function _getMetaInterface(params) {
-    if (!params.Requires || params.Requires.length === 0)
-        return null;
-
-    let metaInterface = params.Requires.map((req) => {
-        if (req instanceof Interface)
-            return req.__super__;
-        for (let metaclass = req.prototype.__metaclass__; metaclass;
-            metaclass = metaclass.__super__) {
-            if (metaclass.hasOwnProperty('MetaInterface'))
-                return metaclass.MetaInterface;
-        }
-        return null;
-    })
-    .reduce((best, candidate) => {
-        // This function reduces to the "most derived" meta interface in the list.
-        if (best === null)
-            return candidate;
-        if (candidate === null)
-            return best;
-        for (let sup = candidate; sup; sup = sup.__super__) {
-            if (sup === best)
-                return candidate;
-        }
-        return best;
-    }, null);
-
-    // If we reach this point and we don't know the meta-interface, then it's
-    // most likely because there were only pure-C interfaces listed in Requires
-    // (and those don't have our magic properties.) However, all pure-C
-    // interfaces should require GObject.Object anyway.
-    if (metaInterface === null)
-        throw new Error('Did you forget to include GObject.Object in Requires?');
-
-    return metaInterface;
-}
-
-function Interface(params) {
-    let metaInterface = _getMetaInterface(params);
-    if (metaInterface && metaInterface !== this.constructor) {
-        // Trick to apply variadic arguments to constructors --
-        // bind the arguments into the constructor function.
-        let args = Array.prototype.slice.call(arguments);
-        let curried = Function.prototype.bind.apply(metaInterface, [,].concat(args));
-        return new curried();
-    }
-    return this._construct.apply(this, arguments);
-}
-
-Class.MetaInterface = Interface;
-
-/**
- * Use this to signify a function that must be overridden in an implementation
- * of the interface. Creating a class that doesn't override the function will
- * throw an error.
- */
-Interface.UNIMPLEMENTED = function UNIMPLEMENTED () {
-    throw new Error('Not implemented');
-};
-
-Interface.__super__ = _Base;
-Interface.prototype = Object.create(_Base.prototype);
-Interface.prototype.constructor = Interface;
-Interface.prototype.__name__ = 'Interface';
-
-Interface.prototype._construct = function (params) {
-    if (!params.Name)
-        throw new TypeError("Interfaces require an explicit 'Name' parameter.");
-
-    let newInterface = Object.create(this.constructor.prototype);
-
-    newInterface.__super__ = Interface;
-    newInterface.prototype = Object.create(Interface.prototype);
-    newInterface.prototype.constructor = newInterface;
-    newInterface.prototype.__name__ = params.Name;
-
-    newInterface._init.apply(newInterface, arguments);
-
-    Object.defineProperty(newInterface.prototype, '__metaclass__',
-                          { writable: false,
-                            configurable: false,
-                            enumerable: false,
-                            value: this.constructor });
-
-    return newInterface;
-};
-
-Interface.prototype._check = function (proto) {
-    // Check that proto implements all of this interface's required interfaces.
-    // "proto" refers to the object's prototype (which implements the interface)
-    // whereas "this.prototype" is the interface's prototype (which may still
-    // contain unimplemented methods.)
-
-    let unfulfilledReqs = this.prototype.__requires__.filter((required) => {
-        // Either the interface is not present or it is not listed before the
-        // interface that requires it or the class does not inherit it. This is
-        // so that required interfaces don't copy over properties from other
-        // interfaces that require them.
-        let interfaces = proto.__interfaces__;
-        return ((!_interfacePresent(required, proto) ||
-            interfaces.indexOf(required) > interfaces.indexOf(this)) &&
-            !(proto instanceof required));
-    }).map((required) =>
-        // __name__ is only present on GJS-created classes and will be the most
-        // accurate name. required.name will be present on introspected GObjects
-        // but is not preferred because it will be the C name. The last option
-        // is just so that we print something if there is garbage in Requires.
-        required.prototype.__name__ || required.name || required);
-    if (unfulfilledReqs.length > 0) {
-        throw new Error('The following interfaces must be implemented before ' +
-            this.prototype.__name__ + ': ' + unfulfilledReqs.join(', '));
-    }
-
-    // Check that this interface's required methods are implemented
-    let unimplementedFns = Object.getOwnPropertyNames(this.prototype)
-    .filter((p) => this.prototype[p] === Interface.UNIMPLEMENTED)
-    .filter((p) => !(p in proto) || proto[p] === Interface.UNIMPLEMENTED);
-    if (unimplementedFns.length > 0)
-        throw new Error('The following members of ' + this.prototype.__name__ +
-            ' are not implemented yet: ' + unimplementedFns.join(', '));
-};
-
-Interface.prototype.toString = function () {
-    return '[interface ' + this.__name__ + ' for ' + this.prototype.__name__ + ']';
-};
-
-Interface.prototype._init = function (params) {
-    let name = params.Name;
-
-    let propertyObj = {};
-    Object.getOwnPropertyNames(params)
-    .filter((name) => ['Name', 'Requires'].indexOf(name) === -1)
-    .forEach((name) => {
-        let descriptor = Object.getOwnPropertyDescriptor(params, name);
-
-        // Create wrappers on the interface object so that generics work (e.g.
-        // SomeInterface.some_function(this, blah) instead of
-        // SomeInterface.prototype.some_function.call(this, blah)
-        if (typeof descriptor.value === 'function') {
-            let interfaceProto = this.prototype;  // capture in closure
-            this[name] = function () {
-                return interfaceProto[name].call.apply(interfaceProto[name],
-                    arguments);
-            };
-        }
-
-        // writable and enumerable are inherited, see note in Class._init()
-        descriptor.configurable = false;
-
-        propertyObj[name] = descriptor;
-    });
-
-    Object.defineProperties(this.prototype, propertyObj);
-    Object.defineProperties(this.prototype, {
-        '__name__': { writable: false,
-                      configurable: false,
-                      enumerable: false,
-                      value: name },
-        '__requires__': { writable: false,
-                          configurable: false,
-                          enumerable: false,
-                          value: params.Requires || [] }
-    });
-};
diff --git a/modules/modules.gresource.xml b/modules/modules.gresource.xml
index 47319355..05b02041 100644
--- a/modules/modules.gresource.xml
+++ b/modules/modules.gresource.xml
@@ -14,6 +14,7 @@
     <file>modules/coverage.js</file>
     <file>modules/gettext.js</file>
     <file>modules/lang.js</file>
+    <file>modules/_legacy.js</file>
     <file>modules/mainloop.js</file>
     <file>modules/jsUnit.js</file>
     <file>modules/signals.js</file>
diff --git a/modules/overrides/GObject.js b/modules/overrides/GObject.js
index 2206f08d..ed1db051 100644
--- a/modules/overrides/GObject.js
+++ b/modules/overrides/GObject.js
@@ -18,9 +18,10 @@
 // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 // IN THE SOFTWARE.
 
-const Lang = imports.lang;
 const Gi = imports._gi;
 const CjsPrivate = imports.gi.CjsPrivate;
+const Lang = imports.lang;
+const Legacy = imports._legacy;
 
 let GObject;
 
@@ -144,7 +145,7 @@ const GObjectMeta = new Lang.Class({
         let newClass = Gi.register_type(parent.prototype, gtypename,
             gobjectInterfaces, propertiesArray);
 
-        // See Class.prototype._construct in lang.js for the reasoning
+        // See Class.prototype._construct in _legacy.js for the reasoning
         // behind this direct prototype set.
         Object.setPrototypeOf(newClass, this.constructor.prototype);
         newClass.__super__ = parent;
@@ -208,7 +209,7 @@ GObjectInterface.prototype._construct = function (params) {
     let newInterface = Gi.register_interface(gtypename, gobjectInterfaces,
         properties);
 
-    // See Class.prototype._construct in lang.js for the reasoning
+    // See Class.prototype._construct in _legacy.js for the reasoning
     // behind this direct prototype set.
     Object.setPrototypeOf(newInterface, this.constructor.prototype);
     newInterface.__super__ = GObjectInterface;

From 9e755bfaa6aa06bb47afd4a9773fc4d7eb3a0681 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 23 Jul 2017 21:10:38 -0700
Subject: [PATCH 091/154] class: Move to ES6 classes in internal code

Where possible, move usage of Lang.Class within GJS to use ES6 classes.
That is currently possible for any classes which don't inherit from
GObject classes and don't implement Lang.Interfaces.

Remove the documentation for the Lang.Class class framework, as it's now
become outdated.

https://bugzilla.gnome.org/show_bug.cgi?id=785652
---
 doc/Class_Framework.md            | 98 ---------------------------------------
 installed-tests/js/minijasmine.js | 30 ++++++------
 installed-tests/js/testGDBus.js   | 92 ++++++++++++++++++------------------
 installed-tests/js/testLang.js    | 12 ++---
 installed-tests/js/testSignals.js |  7 +--
 5 files changed, 65 insertions(+), 174 deletions(-)
 delete mode 100644 doc/Class_Framework.md

diff --git a/doc/Class_Framework.md b/doc/Class_Framework.md
deleted file mode 100644
index 53db2397..00000000
--- a/doc/Class_Framework.md
+++ /dev/null
@@ -1,98 +0,0 @@
-# Class framework #
-
-Keep in mind that JavaScript does not "really" have classes in the sense of C++ or Java; you can't create new types beyond the built-in ones (Object, Array, RegExp, String). However, you can create object instances that share common properties, including methods, using the prototype mechanism.
-
-Every JavaScript implementation invents its own syntactic sugar for doing this, and so did we, but the basics are always the same.
-In ES6, JavaScript finally went ahead and standardized some particular syntactic sugar, which GJS will support in the future.
-
-Each JavaScript object has a property `__proto__`; if you write `obj.foo` and `foo` is not in `obj`, JavaScript will look for `foo` in `__proto__`. If several objects have the same `__proto__`, then they can share methods or other state.
-
-You can create objects with a constructor, which is a special function. Say you have:
-```js
-function Foo() {}
-let f = new Foo();
-```
-
-For `new Foo()` JavaScript will create a new, empty object; and execute `Foo()` with the new, empty object as `this`. So the function `Foo()` sets up the new object.
-
-`new Foo()` will also set `__proto__` on the new object to `Foo.prototype`. The property `prototype` on a constructor is used to initialize `__proto__` for objects the constructor creates. To get the right `__proto__` on objects, we need the right prototype property on the constructor.
-
-You could think of `f = new Foo()` as:
-```js
-let f = {}; // create new object
-f.__proto__ = Foo.prototype; // doing this by hand isn't actually allowed
-Foo.call(f); // invoke Foo() with new object as "this"
-```
-
-Our syntactic sugar is `Lang.Class` which works like this:
-```js
-const Lang = imports.lang;
-
-const Foo = new Lang.Class({
-  Name: 'Foo',
-  _init: function(arg1, arg2) {
-    this._myPrivateInstanceVariable = arg1;
-  },
-  myMethod: function() {
-
-  },
-  myClassVariable: 42,
-  myOtherClassVariable: "Hello"
-}
-```
-
-This pattern means that when you do `let f = new Foo()`, `f` will be a new object, `f.__proto__` will point to `Foo.prototype` which will be the object that you passed to `new Lang.Class()`, and `Foo.prototype._init` will be called to set up the object.
-
-> **NOTE:** Again, on the JavaScript language level, Foo is not a class in the sense of Java or C++; it's just a constructor function, which means it's intended for use with the `new Foo()` syntax to create an object. Once the object is created, from a JavaScript language perspective its type is the built-in type `Object` - though we're using it and thinking of it as if it had type `Foo`, JavaScript doesn't have a clue about that and will never do any type-checking based on which constructor was used to create something. All typing is "duck typing." The built-in types, such as `Object`, `String`, `Error`, `RegExp`, and `Array`, _are_ real types, however, and do get type-checked.
-
-> **NOTE:** If a constructor function has a return value, it is used as the value of `new Foo()` - replacing the automatically-created `this` object passed in to the constructor. If a constructor function returns nothing (undefined), then the passed-in `this` is used. In general, avoid this feature - constructors should have no return value. But this feature may be necessary if you need the new instance to have a built-in type other than Object. If you return a value from the constructor, `this` is simply discarded, so referring to `this` while in the constructor won't make sense.
-
-## JavaScript "inheritance" ##
-
-There are lots of ways to simulate "inheritance" in JavaScript. In general, it's a good idea to avoid class hierarchies in JavaScript. But sometimes it's the best solution.
-
-Our preferred approach is to use our syntactic sugar `Lang.Class` which includes an `Extends` property which sets the prototype of the subclass to the base class. Looking up a property in the subclass starts with the properties of the instance. If the property isn't there, then the prototype chain is followed first to the subclass's prototype and then to the base class's prototype.
-```js
-const Lang = imports.lang;
-
-const Base = new Lang.Class({
-  Name: 'Base',
-  _init : function(foo) {
-    this._foo = foo;
-  },
-  frobate : function() {
-  }
-});
-
-const Sub = new Lang.Class({
-  Name: 'Sub',
-  Extends: Base,
-  _init: function(foo, bar) {
-    // here is an example of how to "chain up"
-    this.parent(foo);
-    this._bar = bar;
-  }
-
-  // add a newMethod property in Sub.prototype
-  newMethod : function() {
-  }
-});
-```
-
-> **NOTE:** You cannot use this mechanism to inherit from a built-in type, such as String or Error, because the methods on those objects expect them to have primitive type String or Error, while your constructor will create an Object instead.
-
-In portable JavaScript code you'll often see a different technique used to get this prototype chain:
-```js
-function Base(foo) ...
-
-Base.prototype = ...
-
-function Sub(foo, bar) ...
-
-// Do NOT do this - do not use an instance of Base as the Sub prototype
-Sub.prototype = new Base();
-```
-
-The problem with this pattern is that you might want to have side effects in the `Base()` constructor. Say `Base()` in its constructor creates a window on the screen, because `Base()` is a dialog class or something. If you use the pattern that some instances of `Base()` are just prototypes for subclasses, you'll get extra windows on the screen.
-
-The other problem with this pattern is that it's just confusing and weird.
diff --git a/installed-tests/js/minijasmine.js b/installed-tests/js/minijasmine.js
index b03c2059..6af74e34 100644
--- a/installed-tests/js/minijasmine.js
+++ b/installed-tests/js/minijasmine.js
@@ -48,19 +48,17 @@ Lang.copyProperties(jasmineInterface, window);
 
 // Reporter that outputs according to the Test Anything Protocol
 // See http://testanything.org/tap-specification.html
-const TapReporter = new Lang.Class({
-    Name: 'TapReporter',
-
-    _init: function () {
+class TapReporter {
+    constructor() {
         this._failedSuites = [];
         this._specCount = 0;
-    },
+    }
 
-    jasmineStarted: function (info) {
+    jasmineStarted(info) {
         print('1..' + info.totalSpecsDefined);
-    },
+    }
 
-    jasmineDone: function () {
+    jasmineDone() {
         this._failedSuites.forEach(failure => {
             failure.failedExpectations.forEach(result => {
                 print('not ok - An error was thrown outside a test');
@@ -69,9 +67,9 @@ const TapReporter = new Lang.Class({
         });
 
         window._jasmineMain.quit();
-    },
+    }
 
-    suiteDone: function (result) {
+    suiteDone(result) {
         if (result.failedExpectations && result.failedExpectations.length > 0) {
             window._jasmineRetval = 1;
             this._failedSuites.push(result);
@@ -80,13 +78,13 @@ const TapReporter = new Lang.Class({
         if (result.status === 'disabled') {
             print('# Suite was disabled:', result.fullName);
         }
-    },
+    }
 
-    specStarted: function () {
+    specStarted() {
         this._specCount++;
-    },
+    }
 
-    specDone: function (result) {
+    specDone(result) {
         let tap_report;
         if (result.status === 'failed') {
             window._jasmineRetval = 1;
@@ -110,7 +108,7 @@ const TapReporter = new Lang.Class({
                 print(stackTrace.split('\n').map((str) => '#   ' + str).join('\n'));
             });
         }
-    },
-});
+    }
+}
 
 window._jasmineEnv.addReporter(new TapReporter());
diff --git a/installed-tests/js/testGDBus.js b/installed-tests/js/testGDBus.js
index cf24c132..11cd7394 100644
--- a/installed-tests/js/testGDBus.js
+++ b/installed-tests/js/testGDBus.js
@@ -81,131 +81,127 @@ var TestIface = '<node> \
 </interface> \
 </node>';
 
-/* Test is the actual object exporting the dbus methods */
-function Test() {
-    this._init();
-}
-
 const PROP_READ_WRITE_INITIAL_VALUE = 58;
 const PROP_WRITE_ONLY_INITIAL_VALUE = "Initial value";
 
-Test.prototype = {
-    _init: function(){
+/* Test is the actual object exporting the dbus methods */
+class Test {
+    constructor() {
         this._propWriteOnly = PROP_WRITE_ONLY_INITIAL_VALUE;
         this._propReadWrite = PROP_READ_WRITE_INITIAL_VALUE;
 
         this._impl = Gio.DBusExportedObject.wrapJSObject(TestIface, this);
         this._impl.export(Gio.DBus.session, '/org/gnome/gjs/Test');
-    },
+    }
 
-    frobateStuff: function(args) {
+    frobateStuff(args) {
         return { hello: new GLib.Variant('s', 'world') };
-    },
+    }
 
-    nonJsonFrobateStuff: function(i) {
+    nonJsonFrobateStuff(i) {
         if (i == 42) {
             return "42 it is!";
         } else {
             return "Oops";
         }
-    },
+    }
 
-    alwaysThrowException: function() {
+    alwaysThrowException() {
         throw Error("Exception!");
-    },
+    }
 
-    thisDoesNotExist: function () {
+    thisDoesNotExist() {
         /* We'll remove this later! */
-    },
+    }
 
-    noInParameter: function() {
+    noInParameter() {
         return "Yes!";
-    },
+    }
 
-    multipleInArgs: function(a, b, c, d, e) {
+    multipleInArgs(a, b, c, d, e) {
         return a + " " + b + " " + c + " " + d + " " + e;
-    },
+    }
 
-    emitSignal: function() {
+    emitSignal() {
         this._impl.emit_signal('signalFoo', GLib.Variant.new('(s)', [ "foobar" ]));
-    },
+    }
 
-    noReturnValue: function() {
+    noReturnValue() {
         /* Empty! */
-    },
+    }
 
     /* The following two functions have identical return values
      * in JS, but the bus message will be different.
      * multipleOutValues is "sss", while oneArrayOut is "as"
      */
-    multipleOutValues: function() {
+    multipleOutValues() {
         return [ "Hello", "World", "!" ];
-    },
+    }
 
-    oneArrayOut: function() {
+    oneArrayOut() {
         return [ "Hello", "World", "!" ];
-    },
+    }
 
     /* Same thing again. In this case multipleArrayOut is "asas",
      * while arrayOfArrayOut is "aas".
      */
-    multipleArrayOut: function() {
+    multipleArrayOut() {
         return [[ "Hello", "World" ], [ "World", "Hello" ]];
-    },
+    }
 
-    arrayOfArrayOut: function() {
+    arrayOfArrayOut() {
         return [[ "Hello", "World" ], [ "World", "Hello" ]];
-    },
+    }
 
-    arrayOutBadSig: function() {
+    arrayOutBadSig() {
         return Symbol('Hello World!');
-    },
+    }
 
-    byteArrayEcho: function(binaryString) {
+    byteArrayEcho(binaryString) {
         return binaryString;
-    },
+    }
 
-    byteEcho: function(aByte) {
+    byteEcho(aByte) {
         return aByte;
-    },
+    }
 
-    dictEcho: function(dict) {
+    dictEcho(dict) {
         return dict;
-    },
+    }
 
     /* This one is implemented asynchronously. Returns
      * the input arguments */
-    echoAsync: function(parameters, invocation) {
+    echoAsync(parameters, invocation) {
         var [someString, someInt] = parameters;
         GLib.idle_add(GLib.PRIORITY_DEFAULT, function() {
             invocation.return_value(new GLib.Variant('(si)', [someString, someInt]));
             return false;
         });
-    },
+    }
 
     // boolean
     get PropReadOnly() {
         return true;
-    },
+    }
 
     // string
     set PropWriteOnly(value) {
         this._propWriteOnly = value;
-    },
+    }
 
     // variant
     get PropReadWrite() {
         return new GLib.Variant('s', this._propReadWrite.toString());
-    },
+    }
 
     set PropReadWrite(value) {
         this._propReadWrite = value.deep_unpack();
-    },
+    }
 
-    structArray: function () {
+    structArray() {
         return [[128, 123456], [42, 654321]];
     }
-};
+}
 
 const ProxyClass = Gio.DBusProxy.makeProxyWrapper(TestIface);
 
diff --git a/installed-tests/js/testLang.js b/installed-tests/js/testLang.js
index 1e0d3079..13735e65 100644
--- a/installed-tests/js/testLang.js
+++ b/installed-tests/js/testLang.js
@@ -53,16 +53,14 @@ describe('Lang module', function () {
 
 
     describe('bind()', function () {
-        const Obj = new Lang.Class({
-            Name: 'Obj',
-            callback: function () {
-                return true;
-            },
-        });
         let o;
 
         beforeEach(function () {
-            o = new Obj();
+            o = {
+                callback() {
+                    return true;
+                }
+            };
             spyOn(o, 'callback').and.callThrough();
         });
 
diff --git a/installed-tests/js/testSignals.js b/installed-tests/js/testSignals.js
index 5944b29f..58d35309 100644
--- a/installed-tests/js/testSignals.js
+++ b/installed-tests/js/testSignals.js
@@ -8,14 +8,11 @@ const Foo = new Lang.Class({
     _init: function () {},
 });
 
-describe('Object with signals', function () {
+describe('Legacy object with signals', function () {
     testSignals(Foo);
 });
 
-const FooWithoutSignals = new Lang.Class({
-    Name: 'FooWithoutSignals',
-    _init: function () {},
-});
+class FooWithoutSignals {}
 Signals.addSignalMethods(FooWithoutSignals.prototype);
 
 describe('Object with signals added', function () {

From aecc8fb1c17465ae29f143ecb5e849b690792474 Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 23:05:43 -0500
Subject: [PATCH 092/154] GObject: Move all legacy GObject class code

This moves the GObject.Class and GObject.Interface code into the Legacy
module along with Lang.Class and Lang.Interface.

Also moves all tests for the legacy GObject code into a separate file.
It is named testLegacyGObject in order to indicate that it tests legacy
code.

https://bugzilla.gnome.org/show_bug.cgi?id=785652

Based on https://github.com/GNOME/gjs/commit/bdb66678e0b09802747767e40f66208c2a02e359
---
 Makefile-test.am                           |   3 +-
 installed-tests/js/testGObjectClass.js     | 358 ------------
 installed-tests/js/testGObjectInterface.js | 389 -------------
 installed-tests/js/testLegacyGObject.js    | 845 +++++++++++++++++++++++++++++
 modules/_legacy.js                         | 294 +++++++++-
 modules/overrides/GObject.js               | 214 +-------
 modules/overrides/Gtk.js                   |  69 +--
 7 files changed, 1142 insertions(+), 1030 deletions(-)
 delete mode 100644 installed-tests/js/testGObjectClass.js
 delete mode 100644 installed-tests/js/testGObjectInterface.js
 create mode 100644 installed-tests/js/testLegacyGObject.js

diff --git a/Makefile-test.am b/Makefile-test.am
index 410f7cec..c1503494 100644
--- a/Makefile-test.am
+++ b/Makefile-test.am
@@ -227,13 +227,12 @@ common_jstests_files =						\
 	installed-tests/js/testGettext.js			\
 	installed-tests/js/testGIMarshalling.js			\
 	installed-tests/js/testGLib.js				\
-	installed-tests/js/testGObjectClass.js			\
-	installed-tests/js/testGObjectInterface.js		\
 	installed-tests/js/testGTypeClass.js			\
 	installed-tests/js/testGio.js				\
 	installed-tests/js/testImporter.js			\
 	installed-tests/js/testLang.js				\
 	installed-tests/js/testLegacyClass.js			\
+	installed-tests/js/testLegacyGObject.js			\
 	installed-tests/js/testLocale.js			\
 	installed-tests/js/testMainloop.js			\
 	installed-tests/js/testNamespace.js			\
diff --git a/installed-tests/js/testGObjectClass.js b/installed-tests/js/testGObjectClass.js
deleted file mode 100644
index 0d81b96e..00000000
--- a/installed-tests/js/testGObjectClass.js
+++ /dev/null
@@ -1,358 +0,0 @@
-// -*- mode: js; indent-tabs-mode: nil -*-
-imports.gi.versions.Gtk = '3.0';
-
-const Lang = imports.lang;
-const GObject = imports.gi.GObject;
-const Gio = imports.gi.Gio;
-const Gtk = imports.gi.Gtk;
-
-const MyObject = new GObject.Class({
-    Name: 'MyObject',
-    Properties: {
-        'readwrite': GObject.ParamSpec.string('readwrite', 'ParamReadwrite',
-                                              'A read write parameter',
-                                              GObject.ParamFlags.READWRITE,
-                                              ''),
-        'readonly': GObject.ParamSpec.string('readonly', 'ParamReadonly',
-                                             'A readonly parameter',
-                                             GObject.ParamFlags.READABLE,
-                                             ''),
-
-        'construct': GObject.ParamSpec.string('construct', 'ParamConstructOnly',
-                                              'A readwrite construct-only parameter',
-                                              GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,
-                                              'default')
-    },
-    Signals: {
-        'empty': { },
-        'minimal': { param_types: [ GObject.TYPE_INT, GObject.TYPE_INT ] },
-        'full': { flags: GObject.SignalFlags.RUN_LAST, accumulator: GObject.AccumulatorType.FIRST_WINS,
-                  return_type: GObject.TYPE_INT, param_types: [ ] },
-        'run-last': { flags: GObject.SignalFlags.RUN_LAST },
-        'detailed': { flags: GObject.SignalFlags.RUN_FIRST | GObject.SignalFlags.DETAILED, param_types: [ GObject.TYPE_STRING ] }
-    },
-
-    _init: function(props) {
-        // check that it's safe to set properties before
-        // chaining up (priv is NULL at this point, remember)
-        this._readwrite = 'foo';
-        this._readonly = 'bar';
-        this._constructProp = null;
-        this._constructCalled = false;
-
-        this.parent(props);
-    },
-
-    get readwrite() {
-        return this._readwrite;
-    },
-
-    set readwrite(val) {
-        if (val == 'ignore')
-            return;
-
-        this._readwrite = val;
-    },
-
-    get readonly() {
-        return this._readonly;
-    },
-
-    set readonly(val) {
-        // this should never be called
-        this._readonly = 'bogus';
-    },
-
-    get construct() {
-        return this._constructProp;
-    },
-
-    set construct(val) {
-        // this should be called at most once
-        if (this._constructCalled)
-            throw Error('Construct-Only property set more than once');
-
-        this._constructProp = val;
-        this._constructCalled = true;
-    },
-
-    notify_prop: function() {
-        this._readonly = 'changed';
-
-        this.notify('readonly');
-    },
-
-    emit_empty: function() {
-        this.emit('empty');
-    },
-
-    emit_minimal: function(one, two) {
-        this.emit('minimal', one, two);
-    },
-
-    emit_full: function() {
-        return this.emit('full');
-    },
-
-    emit_detailed: function() {
-        this.emit('detailed::one');
-        this.emit('detailed::two');
-    },
-
-    emit_run_last: function(callback) {
-        this._run_last_callback = callback;
-        this.emit('run-last');
-    },
-
-    on_run_last: function() {
-        this._run_last_callback();
-    },
-
-    on_empty: function() {
-        this.empty_called = true;
-    },
-
-    on_full: function() {
-        this.full_default_handler_called = true;
-        return 79;
-    }
-});
-
-const MyApplication = new Lang.Class({
-    Name: 'MyApplication',
-    Extends: Gio.Application,
-    Signals: { 'custom': { param_types: [ GObject.TYPE_INT ] } },
-
-    _init: function(params) {
-        this.parent(params);
-    },
-
-    emit_custom: function(n) {
-        this.emit('custom', n);
-    }
-});
-
-const MyInitable = new Lang.Class({
-    Name: 'MyInitable',
-    Extends: GObject.Object,
-    Implements: [ Gio.Initable ],
-
-    _init: function(params) {
-        this.parent(params);
-
-        this.inited = false;
-    },
-
-    vfunc_init: function(cancellable) { // error?
-        if (!(cancellable instanceof Gio.Cancellable))
-            throw 'Bad argument';
-
-        this.inited = true;
-    }
-});
-
-const Derived = new Lang.Class({
-    Name: 'Derived',
-    Extends: MyObject,
-
-    _init: function() {
-        this.parent({ readwrite: 'yes' });
-    }
-});
-
-const MyCustomInit = new Lang.Class({
-    Name: 'MyCustomInit',
-    Extends: GObject.Object,
-
-    _init: function() {
-        this.foo = false;
-
-        this.parent();
-    },
-
-    _instance_init: function() {
-        this.foo = true;
-    }
-});
-
-describe('GObject class', function () {
-    let myInstance;
-    beforeEach(function () {
-        myInstance = new MyObject();
-    });
-
-    it('constructs with default values for properties', function () {
-        expect(myInstance.readwrite).toEqual('foo');
-        expect(myInstance.readonly).toEqual('bar');
-        expect(myInstance.construct).toEqual('default');
-    });
-
-    it('constructs with a hash of property values', function () {
-        let myInstance2 = new MyObject({ readwrite: 'baz', construct: 'asdf' });
-        expect(myInstance2.readwrite).toEqual('baz');
-        expect(myInstance2.readonly).toEqual('bar');
-        expect(myInstance2.construct).toEqual('asdf');
-    });
-
-    const ui = '<interface> \
-                <object class="Gjs_MyObject" id="MyObject"> \
-                  <property name="readwrite">baz</property> \
-                  <property name="construct">quz</property> \
-                </object> \
-              </interface>';
-
-    it('constructs with property values from Gtk.Builder', function () {
-        let builder = Gtk.Builder.new_from_string(ui, -1);
-        let myInstance3 = builder.get_object('MyObject');
-        expect(myInstance3.readwrite).toEqual('baz');
-        expect(myInstance3.readonly).toEqual('bar');
-        expect(myInstance3.construct).toEqual('quz');
-    });
-
-    // the following would (should) cause a CRITICAL:
-    // myInstance.readonly = 'val';
-    // myInstance.construct = 'val';
-
-    it('has a notify signal', function () {
-        let notifySpy = jasmine.createSpy('notifySpy');
-        myInstance.connect('notify::readonly', notifySpy);
-
-        myInstance.notify_prop();
-        myInstance.notify_prop();
-
-        expect(notifySpy).toHaveBeenCalledTimes(2);
-    });
-
-    it('can define its own signals', function () {
-        let emptySpy = jasmine.createSpy('emptySpy');
-        myInstance.connect('empty', emptySpy);
-        myInstance.emit_empty();
-
-        expect(emptySpy).toHaveBeenCalled();
-        expect(myInstance.empty_called).toBeTruthy();
-    });
-
-    it('passes emitted arguments to signal handlers', function () {
-        let minimalSpy = jasmine.createSpy('minimalSpy');
-        myInstance.connect('minimal', minimalSpy);
-        myInstance.emit_minimal(7, 5);
-
-        expect(minimalSpy).toHaveBeenCalledWith(myInstance, 7, 5);
-    });
-
-    it('can return values from signals', function () {
-        let fullSpy = jasmine.createSpy('fullSpy').and.returnValue(42);
-        myInstance.connect('full', fullSpy);
-        let result = myInstance.emit_full();
-
-        expect(fullSpy).toHaveBeenCalled();
-        expect(result).toEqual(42);
-    });
-
-    it('does not call first-wins signal handlers after one returns a value', function () {
-        let neverCalledSpy = jasmine.createSpy('neverCalledSpy');
-        myInstance.connect('full', () => 42);
-        myInstance.connect('full', neverCalledSpy);
-        myInstance.emit_full();
-
-        expect(neverCalledSpy).not.toHaveBeenCalled();
-        expect(myInstance.full_default_handler_called).toBeFalsy();
-    });
-
-    it('gets the return value of the default handler', function () {
-        let result = myInstance.emit_full();
-
-        expect(myInstance.full_default_handler_called).toBeTruthy();
-        expect(result).toEqual(79);
-    });
-
-    it('calls run-last default handler last', function () {
-        let stack = [ ];
-        let runLastSpy = jasmine.createSpy('runLastSpy')
-            .and.callFake(() => { stack.push(1); });
-        myInstance.connect('run-last', runLastSpy);
-        myInstance.emit_run_last(() => { stack.push(2); });
-
-        expect(stack).toEqual([1, 2]);
-    });
-
-    it("can inherit from something that's not GObject.Object", function () {
-        // ...and still get all the goodies of GObject.Class
-        let instance = new MyApplication({ application_id: 'org.gjs.Application' });
-        let customSpy = jasmine.createSpy('customSpy');
-        instance.connect('custom', customSpy);
-
-        instance.emit_custom(73);
-        expect(customSpy).toHaveBeenCalledWith(instance, 73);
-    });
-
-    it('can implement an interface', function () {
-        let instance = new MyInitable();
-        expect(instance.constructor.implements(Gio.Initable)).toBeTruthy();
-    });
-
-    it('can implement interface vfuncs', function () {
-        let instance = new MyInitable();
-        expect(instance.inited).toBeFalsy();
-
-        instance.init(new Gio.Cancellable());
-        expect(instance.inited).toBeTruthy();
-    });
-
-    it('can be a subclass', function () {
-        let derived = new Derived();
-
-        expect(derived instanceof Derived).toBeTruthy();
-        expect(derived instanceof MyObject).toBeTruthy();
-
-        expect(derived.readwrite).toEqual('yes');
-    });
-
-    it('calls its _instance_init() function while chaining up in constructor', function () {
-        let instance = new MyCustomInit();
-        expect(instance.foo).toBeTruthy();
-    });
-
-    it('can have an interface-valued property', function () {
-        const InterfacePropObject = new Lang.Class({
-            Name: 'InterfacePropObject',
-            Extends: GObject.Object,
-            Properties: {
-                'file': GObject.ParamSpec.object('file', 'File', 'File',
-                    GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,
-                    Gio.File.$gtype)
-            },
-        });
-        let file = Gio.File.new_for_path('dummy');
-        expect(() => new InterfacePropObject({ file: file })).not.toThrow();
-    });
-
-    it('can override a property from the parent class', function () {
-        const OverrideObject = new Lang.Class({
-            Name: 'OverrideObject',
-            Extends: MyObject,
-            Properties: {
-                'readwrite': GObject.ParamSpec.override('readwrite', MyObject),
-            },
-            get readwrite() {
-                return this._subclass_readwrite;
-            },
-            set readwrite(val) {
-                this._subclass_readwrite = 'subclass' + val;
-            },
-        });
-        let obj = new OverrideObject();
-        obj.readwrite = 'foo';
-        expect(obj.readwrite).toEqual('subclassfoo');
-    });
-
-    it('cannot override a non-existent property', function () {
-        expect(() => new Lang.Class({
-            Name: 'BadOverride',
-            Extends: GObject.Object,
-            Properties: {
-                'nonexistent': GObject.ParamSpec.override('nonexistent', GObject.Object),
-            },
-        })).toThrow();
-    });
-});
diff --git a/installed-tests/js/testGObjectInterface.js b/installed-tests/js/testGObjectInterface.js
deleted file mode 100644
index 792b6114..00000000
--- a/installed-tests/js/testGObjectInterface.js
+++ /dev/null
@@ -1,389 +0,0 @@
-// -*- mode: js; indent-tabs-mode: nil -*-
-
-const Gio = imports.gi.Gio;
-const GLib = imports.gi.GLib;
-const GObject = imports.gi.GObject;
-const Lang = imports.lang;
-const Mainloop = imports.mainloop;
-
-const AnInterface = new Lang.Interface({
-    Name: 'AnInterface',
-});
-
-const GObjectImplementingLangInterface = new Lang.Class({
-    Name: 'GObjectImplementingLangInterface',
-    Extends: GObject.Object,
-    Implements: [ AnInterface ],
-
-    _init: function (props={}) {
-        this.parent(props);
-    }
-});
-
-const AGObjectInterface = new Lang.Interface({
-    Name: 'AGObjectInterface',
-    GTypeName: 'ArbitraryGTypeName',
-    Requires: [ GObject.Object ],
-    Properties: {
-        'interface-prop': GObject.ParamSpec.string('interface-prop',
-            'Interface property', 'Must be overridden in implementation',
-            GObject.ParamFlags.READABLE,
-            'foobar')
-    },
-    Signals: {
-        'interface-signal': {}
-    },
-
-    requiredG: Lang.Interface.UNIMPLEMENTED,
-    optionalG: function () {
-        return 'AGObjectInterface.optionalG()';
-    }
-});
-
-const InterfaceRequiringGObjectInterface = new Lang.Interface({
-    Name: 'InterfaceRequiringGObjectInterface',
-    Requires: [ AGObjectInterface ],
-
-    optionalG: function () {
-        return 'InterfaceRequiringGObjectInterface.optionalG()\n' +
-            AGObjectInterface.optionalG(this);
-    }
-});
-
-const GObjectImplementingGObjectInterface = new Lang.Class({
-    Name: 'GObjectImplementingGObjectInterface',
-    Extends: GObject.Object,
-    Implements: [ AGObjectInterface ],
-    Properties: {
-        'interface-prop': GObject.ParamSpec.override('interface-prop',
-            AGObjectInterface),
-        'class-prop': GObject.ParamSpec.string('class-prop', 'Class property',
-            'A property that is not on the interface',
-            GObject.ParamFlags.READABLE, 'meh')
-    },
-    Signals: {
-        'class-signal': {},
-    },
-
-    get interface_prop() {
-        return 'foobar';
-    },
-
-    get class_prop() {
-        return 'meh';
-    },
-
-    _init: function (props={}) {
-        this.parent(props);
-    },
-    requiredG: function () {},
-    optionalG: function () {
-        return AGObjectInterface.optionalG(this);
-    }
-});
-
-const MinimalImplementationOfAGObjectInterface = new Lang.Class({
-    Name: 'MinimalImplementationOfAGObjectInterface',
-    Extends: GObject.Object,
-    Implements: [ AGObjectInterface ],
-    Properties: {
-        'interface-prop': GObject.ParamSpec.override('interface-prop',
-            AGObjectInterface)
-    },
-
-    _init: function (props={}) {
-        this.parent(props);
-    },
-    requiredG: function () {}
-});
-
-const ImplementationOfTwoInterfaces = new Lang.Class({
-    Name: 'ImplementationOfTwoInterfaces',
-    Extends: GObject.Object,
-    Implements: [ AGObjectInterface, InterfaceRequiringGObjectInterface ],
-    Properties: {
-        'interface-prop': GObject.ParamSpec.override('interface-prop',
-            AGObjectInterface)
-    },
-
-    _init: function (props={}) {
-        this.parent(props);
-    },
-    requiredG: function () {},
-    optionalG: function () {
-        return InterfaceRequiringGObjectInterface.optionalG(this);
-    }
-});
-
-describe('GObject interface', function () {
-    it('class can implement a Lang.Interface', function () {
-        let obj;
-        expect(() => { obj = new GObjectImplementingLangInterface(); })
-            .not.toThrow();
-        expect(obj.constructor.implements(AnInterface)).toBeTruthy();
-    });
-
-    it('throws when an interface requires a GObject interface but not GObject.Object', function () {
-        expect(() => new Lang.Interface({
-            Name: 'GObjectInterfaceNotRequiringGObject',
-            GTypeName: 'GTypeNameNotRequiringGObject',
-            Requires: [ Gio.Initable ]
-        })).toThrow();
-    });
-
-    it('can be implemented by a GObject class along with a JS interface', function () {
-        const ObjectImplementingLangInterfaceAndCInterface = new Lang.Class({
-            Name: 'ObjectImplementingLangInterfaceAndCInterface',
-            Extends: GObject.Object,
-            Implements: [ AnInterface, Gio.Initable ],
-
-            _init: function (props={}) {
-                this.parent(props);
-            }
-        });
-        let obj;
-        expect(() => { obj = new ObjectImplementingLangInterfaceAndCInterface(); })
-            .not.toThrow();
-        expect(obj.constructor.implements(AnInterface)).toBeTruthy();
-        expect(obj.constructor.implements(Gio.Initable)).toBeTruthy();
-    });
-
-    it('is an instance of the interface classes', function () {
-        expect(AGObjectInterface instanceof Lang.Interface).toBeTruthy();
-        expect(AGObjectInterface instanceof GObject.Interface).toBeTruthy();
-    });
-
-    it('cannot be instantiated', function () {
-        expect(() => new AGObjectInterface()).toThrow();
-    });
-
-    it('reports its type name', function () {
-        expect(AGObjectInterface.$gtype.name).toEqual('ArbitraryGTypeName');
-    });
-
-    it('can be implemented by a GObject class', function () {
-        let obj;
-        expect(() => { obj = new GObjectImplementingGObjectInterface(); })
-            .not.toThrow();
-        expect(obj.constructor.implements(AGObjectInterface)).toBeTruthy();
-    });
-
-    it('is implemented by a GObject class with the correct class object', function () {
-        expect(GObjectImplementingGObjectInterface.toString())
-            .toEqual('[object GObjectClass for GObjectImplementingGObjectInterface]');
-        let obj = new GObjectImplementingGObjectInterface();
-        expect(obj.constructor).toEqual(GObjectImplementingGObjectInterface);
-        expect(obj.constructor.toString())
-            .toEqual('[object GObjectClass for GObjectImplementingGObjectInterface]');
-    });
-
-    it('can be implemented by a class also implementing a Lang.Interface', function () {
-        const GObjectImplementingBothKindsOfInterface = new Lang.Class({
-            Name: 'GObjectImplementingBothKindsOfInterface',
-            Extends: GObject.Object,
-            Implements: [ AnInterface, AGObjectInterface ],
-            Properties: {
-                'interface-prop': GObject.ParamSpec.override('interface-prop',
-                    AGObjectInterface)
-            },
-
-            _init: function (props={}) {
-                this.parent(props);
-            },
-            required: function () {},
-            requiredG: function () {}
-        });
-        let obj;
-        expect(() => { obj = new GObjectImplementingBothKindsOfInterface(); })
-            .not.toThrow();
-        expect(obj.constructor.implements(AnInterface)).toBeTruthy();
-        expect(obj.constructor.implements(AGObjectInterface)).toBeTruthy();
-    });
-
-    it('can have its required function implemented', function () {
-        expect(() => {
-            let obj = new GObjectImplementingGObjectInterface();
-            obj.requiredG();
-        }).not.toThrow();
-    });
-
-    it('must have its required function implemented', function () {
-        expect(() => new Lang.Class({
-            Name: 'BadObject',
-            Extends: GObject.Object,
-            Implements: [ AGObjectInterface ],
-            Properties: {
-                'interface-prop': GObject.ParamSpec.override('interface-prop',
-                    AGObjectInterface)
-            }
-        })).toThrow();
-    });
-
-    it("doesn't have to have its optional function implemented", function () {
-        let obj;
-        expect(() => { obj = new MinimalImplementationOfAGObjectInterface(); })
-            .not.toThrow();
-        expect(obj.constructor.implements(AGObjectInterface)).toBeTruthy();
-    });
-
-    it('can have its optional function deferred to by the implementation', function () {
-        let obj = new MinimalImplementationOfAGObjectInterface();
-        expect(obj.optionalG()).toEqual('AGObjectInterface.optionalG()');
-    });
-
-    it('can have its function chained up to', function () {
-        let obj = new GObjectImplementingGObjectInterface();
-        expect(obj.optionalG()).toEqual('AGObjectInterface.optionalG()');
-    });
-
-    it('can require another interface', function () {
-        let obj;
-        expect(() => { obj = new ImplementationOfTwoInterfaces(); }).not.toThrow();
-        expect(obj.constructor.implements(AGObjectInterface)).toBeTruthy();
-        expect(obj.constructor.implements(InterfaceRequiringGObjectInterface))
-            .toBeTruthy();
-    });
-
-    it('can chain up to another interface', function () {
-        let obj = new ImplementationOfTwoInterfaces();
-        expect(obj.optionalG())
-            .toEqual('InterfaceRequiringGObjectInterface.optionalG()\nAGObjectInterface.optionalG()');
-    });
-
-    it("defers to the last interface's optional function", function () {
-        const MinimalImplementationOfTwoInterfaces = new Lang.Class({
-            Name: 'MinimalImplementationOfTwoInterfaces',
-            Extends: GObject.Object,
-            Implements: [ AGObjectInterface, InterfaceRequiringGObjectInterface ],
-            Properties: {
-                'interface-prop': GObject.ParamSpec.override('interface-prop',
-                    AGObjectInterface)
-            },
-
-            _init: function (props={}) {
-                this.parent(props);
-            },
-            requiredG: function () {}
-        });
-        let obj = new MinimalImplementationOfTwoInterfaces();
-        expect(obj.optionalG())
-            .toEqual('InterfaceRequiringGObjectInterface.optionalG()\nAGObjectInterface.optionalG()');
-    });
-
-    it('must be implemented by a class that implements all required interfaces', function () {
-        expect(() => new Lang.Class({
-            Name: 'BadObject',
-            Implements: [ InterfaceRequiringGObjectInterface ],
-            required: function () {}
-        })).toThrow();
-    });
-
-    it('must be implemented by a class that implements required interfaces in correct order', function () {
-        expect(() => new Lang.Class({
-            Name: 'BadObject',
-            Implements: [ InterfaceRequiringGObjectInterface, AGObjectInterface ],
-            required: function () {}
-        })).toThrow();
-    });
-
-    it('can require an interface from C', function () {
-        const InitableInterface = new Lang.Interface({
-            Name: 'InitableInterface',
-            Requires: [ GObject.Object, Gio.Initable ]
-        });
-        expect(() => new Lang.Class({
-            Name: 'BadObject',
-            Implements: [ InitableInterface ]
-        })).toThrow();
-    });
-
-    it('can define signals on the implementing class', function () {
-        function quitLoop() {
-            Mainloop.quit('signal');
-        }
-        let obj = new GObjectImplementingGObjectInterface();
-        let interfaceSignalSpy = jasmine.createSpy('interfaceSignalSpy')
-            .and.callFake(quitLoop);
-        let classSignalSpy = jasmine.createSpy('classSignalSpy')
-            .and.callFake(quitLoop);
-        obj.connect('interface-signal', interfaceSignalSpy);
-        obj.connect('class-signal', classSignalSpy);
-        GLib.idle_add(GLib.PRIORITY_DEFAULT, () => {
-            obj.emit('interface-signal');
-            return GLib.SOURCE_REMOVE;
-        });
-        Mainloop.run('signal');
-        GLib.idle_add(GLib.PRIORITY_DEFAULT, () => {
-            obj.emit('class-signal');
-            return GLib.SOURCE_REMOVE;
-        });
-        Mainloop.run('signal');
-        expect(interfaceSignalSpy).toHaveBeenCalled();
-        expect(classSignalSpy).toHaveBeenCalled();
-    });
-
-    it('can define properties on the implementing class', function () {
-        let obj = new GObjectImplementingGObjectInterface();
-        expect(obj.interface_prop).toEqual('foobar');
-        expect(obj.class_prop).toEqual('meh');
-    });
-
-    it('must have its properties overridden', function () {
-        // Failing to override an interface property doesn't raise an error but
-        // instead logs a critical warning.
-        GLib.test_expect_message('GLib-GObject', GLib.LogLevelFlags.LEVEL_CRITICAL,
-            "Object class * doesn't implement property 'interface-prop' from " +
-            "interface 'ArbitraryGTypeName'");
-        new Lang.Class({
-            Name: 'MyNaughtyObject',
-            Extends: GObject.Object,
-            Implements: [ AGObjectInterface ],
-            _init: function (props={}) {
-                this.parent(props);
-            },
-            requiredG: function () {}
-        });
-        // g_test_assert_expected_messages() is a macro, not introspectable
-        GLib.test_assert_expected_messages_internal('Gjs', 'testGObjectInterface.js',
-            416, 'testGObjectMustOverrideInterfaceProperties');
-    });
-
-    // This makes sure that we catch the case where the metaclass (e.g.
-    // GtkWidgetClass) doesn't specify a meta-interface. In that case we get the
-    // meta-interface from the metaclass's parent.
-    it('gets the correct type for its metaclass', function () {
-        const MyMeta = new Lang.Class({
-            Name: 'MyMeta',
-            Extends: GObject.Class
-        });
-        const MyMetaObject = new MyMeta({
-            Name: 'MyMetaObject'
-        });
-        const MyMetaInterface = new Lang.Interface({
-            Name: 'MyMetaInterface',
-            Requires: [ MyMetaObject ]
-        });
-        expect(MyMetaInterface instanceof GObject.Interface).toBeTruthy();
-    });
-
-    it('can be implemented by a class as well as its parent class', function () {
-        const SubObject = new Lang.Class({
-            Name: 'SubObject',
-            Extends: GObjectImplementingGObjectInterface
-        });
-        let obj = new SubObject();
-        expect(obj.constructor.implements(AGObjectInterface)).toBeTruthy();
-        expect(obj.interface_prop).toEqual('foobar');  // override not needed
-    });
-
-    it('can be reimplemented by a subclass of a class that already implements it', function () {
-        const SubImplementer = new Lang.Class({
-            Name: 'SubImplementer',
-            Extends: GObjectImplementingGObjectInterface,
-            Implements: [ AGObjectInterface ]
-        });
-        let obj = new SubImplementer();
-        expect(obj.constructor.implements(AGObjectInterface)).toBeTruthy();
-        expect(obj.interface_prop).toEqual('foobar');  // override not needed
-    });
-});
diff --git a/installed-tests/js/testLegacyGObject.js b/installed-tests/js/testLegacyGObject.js
new file mode 100644
index 00000000..56ba1b78
--- /dev/null
+++ b/installed-tests/js/testLegacyGObject.js
@@ -0,0 +1,845 @@
+// -*- mode: js; indent-tabs-mode: nil -*-
+imports.gi.versions.Gtk = '3.0';
+
+const ByteArray = imports.byteArray;
+const Gio = imports.gi.Gio;
+const GLib = imports.gi.GLib;
+const GObject = imports.gi.GObject;
+const Gtk = imports.gi.Gtk;
+const Lang = imports.lang;
+const Mainloop = imports.mainloop;
+
+const MyObject = new GObject.Class({
+    Name: 'MyObject',
+    Properties: {
+        'readwrite': GObject.ParamSpec.string('readwrite', 'ParamReadwrite',
+            'A read write parameter', GObject.ParamFlags.READWRITE, ''),
+        'readonly': GObject.ParamSpec.string('readonly', 'ParamReadonly',
+            'A readonly parameter', GObject.ParamFlags.READABLE, ''),
+        'construct': GObject.ParamSpec.string('construct', 'ParamConstructOnly',
+            'A readwrite construct-only parameter',
+            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,
+            'default'),
+    },
+    Signals: {
+        'empty': { },
+        'minimal': { param_types: [ GObject.TYPE_INT, GObject.TYPE_INT ] },
+        'full': {
+            flags: GObject.SignalFlags.RUN_LAST,
+            accumulator: GObject.AccumulatorType.FIRST_WINS,
+            return_type: GObject.TYPE_INT,
+            param_types: [],
+        },
+        'run-last': { flags: GObject.SignalFlags.RUN_LAST },
+        'detailed': {
+            flags: GObject.SignalFlags.RUN_FIRST | GObject.SignalFlags.DETAILED,
+            param_types: [ GObject.TYPE_STRING ],
+        },
+    },
+
+    _init: function(props) {
+        // check that it's safe to set properties before
+        // chaining up (priv is NULL at this point, remember)
+        this._readwrite = 'foo';
+        this._readonly = 'bar';
+        this._constructProp = null;
+        this._constructCalled = false;
+
+        this.parent(props);
+    },
+
+    get readwrite() {
+        return this._readwrite;
+    },
+
+    set readwrite(val) {
+        if (val == 'ignore')
+            return;
+
+        this._readwrite = val;
+    },
+
+    get readonly() {
+        return this._readonly;
+    },
+
+    set readonly(val) {
+        // this should never be called
+        this._readonly = 'bogus';
+    },
+
+    get construct() {
+        return this._constructProp;
+    },
+
+    set construct(val) {
+        // this should be called at most once
+        if (this._constructCalled)
+            throw Error('Construct-Only property set more than once');
+
+        this._constructProp = val;
+        this._constructCalled = true;
+    },
+
+    notify_prop: function() {
+        this._readonly = 'changed';
+
+        this.notify('readonly');
+    },
+
+    emit_empty: function() {
+        this.emit('empty');
+    },
+
+    emit_minimal: function(one, two) {
+        this.emit('minimal', one, two);
+    },
+
+    emit_full: function() {
+        return this.emit('full');
+    },
+
+    emit_detailed: function() {
+        this.emit('detailed::one');
+        this.emit('detailed::two');
+    },
+
+    emit_run_last: function(callback) {
+        this._run_last_callback = callback;
+        this.emit('run-last');
+    },
+
+    on_run_last: function() {
+        this._run_last_callback();
+    },
+
+    on_empty: function() {
+        this.empty_called = true;
+    },
+
+    on_full: function() {
+        this.full_default_handler_called = true;
+        return 79;
+    }
+});
+
+const MyApplication = new Lang.Class({
+    Name: 'MyApplication',
+    Extends: Gio.Application,
+    Signals: { 'custom': { param_types: [ GObject.TYPE_INT ] } },
+
+    _init: function(params) {
+        this.parent(params);
+    },
+
+    emit_custom: function(n) {
+        this.emit('custom', n);
+    }
+});
+
+const MyInitable = new Lang.Class({
+    Name: 'MyInitable',
+    Extends: GObject.Object,
+    Implements: [ Gio.Initable ],
+
+    _init: function(params) {
+        this.parent(params);
+
+        this.inited = false;
+    },
+
+    vfunc_init: function(cancellable) { // error?
+        if (!(cancellable instanceof Gio.Cancellable))
+            throw 'Bad argument';
+
+        this.inited = true;
+    }
+});
+
+const Derived = new Lang.Class({
+    Name: 'Derived',
+    Extends: MyObject,
+
+    _init: function() {
+        this.parent({ readwrite: 'yes' });
+    }
+});
+
+const MyCustomInit = new Lang.Class({
+    Name: 'MyCustomInit',
+    Extends: GObject.Object,
+
+    _init: function() {
+        this.foo = false;
+
+        this.parent();
+    },
+
+    _instance_init: function() {
+        this.foo = true;
+    }
+});
+
+describe('GObject class', function () {
+    let myInstance;
+    beforeEach(function () {
+        myInstance = new MyObject();
+    });
+
+    it('constructs with default values for properties', function () {
+        expect(myInstance.readwrite).toEqual('foo');
+        expect(myInstance.readonly).toEqual('bar');
+        expect(myInstance.construct).toEqual('default');
+    });
+
+    it('constructs with a hash of property values', function () {
+        let myInstance2 = new MyObject({ readwrite: 'baz', construct: 'asdf' });
+        expect(myInstance2.readwrite).toEqual('baz');
+        expect(myInstance2.readonly).toEqual('bar');
+        expect(myInstance2.construct).toEqual('asdf');
+    });
+
+    const ui = `<interface>
+                <object class="Gjs_MyObject" id="MyObject">
+                  <property name="readwrite">baz</property>
+                  <property name="construct">quz</property>
+                </object>
+              </interface>`;
+
+    it('constructs with property values from Gtk.Builder', function () {
+        let builder = Gtk.Builder.new_from_string(ui, -1);
+        let myInstance3 = builder.get_object('MyObject');
+        expect(myInstance3.readwrite).toEqual('baz');
+        expect(myInstance3.readonly).toEqual('bar');
+        expect(myInstance3.construct).toEqual('quz');
+    });
+
+    // the following would (should) cause a CRITICAL:
+    // myInstance.readonly = 'val';
+    // myInstance.construct = 'val';
+
+    it('has a notify signal', function () {
+        let notifySpy = jasmine.createSpy('notifySpy');
+        myInstance.connect('notify::readonly', notifySpy);
+
+        myInstance.notify_prop();
+        myInstance.notify_prop();
+
+        expect(notifySpy).toHaveBeenCalledTimes(2);
+    });
+
+    it('can define its own signals', function () {
+        let emptySpy = jasmine.createSpy('emptySpy');
+        myInstance.connect('empty', emptySpy);
+        myInstance.emit_empty();
+
+        expect(emptySpy).toHaveBeenCalled();
+        expect(myInstance.empty_called).toBeTruthy();
+    });
+
+    it('passes emitted arguments to signal handlers', function () {
+        let minimalSpy = jasmine.createSpy('minimalSpy');
+        myInstance.connect('minimal', minimalSpy);
+        myInstance.emit_minimal(7, 5);
+
+        expect(minimalSpy).toHaveBeenCalledWith(myInstance, 7, 5);
+    });
+
+    it('can return values from signals', function () {
+        let fullSpy = jasmine.createSpy('fullSpy').and.returnValue(42);
+        myInstance.connect('full', fullSpy);
+        let result = myInstance.emit_full();
+
+        expect(fullSpy).toHaveBeenCalled();
+        expect(result).toEqual(42);
+    });
+
+    it('does not call first-wins signal handlers after one returns a value', function () {
+        let neverCalledSpy = jasmine.createSpy('neverCalledSpy');
+        myInstance.connect('full', () => 42);
+        myInstance.connect('full', neverCalledSpy);
+        myInstance.emit_full();
+
+        expect(neverCalledSpy).not.toHaveBeenCalled();
+        expect(myInstance.full_default_handler_called).toBeFalsy();
+    });
+
+    it('gets the return value of the default handler', function () {
+        let result = myInstance.emit_full();
+
+        expect(myInstance.full_default_handler_called).toBeTruthy();
+        expect(result).toEqual(79);
+    });
+
+    it('calls run-last default handler last', function () {
+        let stack = [ ];
+        let runLastSpy = jasmine.createSpy('runLastSpy')
+            .and.callFake(() => { stack.push(1); });
+        myInstance.connect('run-last', runLastSpy);
+        myInstance.emit_run_last(() => { stack.push(2); });
+
+        expect(stack).toEqual([1, 2]);
+    });
+
+    it("can inherit from something that's not GObject.Object", function () {
+        // ...and still get all the goodies of GObject.Class
+        let instance = new MyApplication({ application_id: 'org.gjs.Application' });
+        let customSpy = jasmine.createSpy('customSpy');
+        instance.connect('custom', customSpy);
+
+        instance.emit_custom(73);
+        expect(customSpy).toHaveBeenCalledWith(instance, 73);
+    });
+
+    it('can implement an interface', function () {
+        let instance = new MyInitable();
+        expect(instance.constructor.implements(Gio.Initable)).toBeTruthy();
+    });
+
+    it('can implement interface vfuncs', function () {
+        let instance = new MyInitable();
+        expect(instance.inited).toBeFalsy();
+
+        instance.init(new Gio.Cancellable());
+        expect(instance.inited).toBeTruthy();
+    });
+
+    it('can be a subclass', function () {
+        let derived = new Derived();
+
+        expect(derived instanceof Derived).toBeTruthy();
+        expect(derived instanceof MyObject).toBeTruthy();
+
+        expect(derived.readwrite).toEqual('yes');
+    });
+
+    it('calls its _instance_init() function while chaining up in constructor', function () {
+        let instance = new MyCustomInit();
+        expect(instance.foo).toBeTruthy();
+    });
+
+    it('can have an interface-valued property', function () {
+        const InterfacePropObject = new Lang.Class({
+            Name: 'InterfacePropObject',
+            Extends: GObject.Object,
+            Properties: {
+                'file': GObject.ParamSpec.object('file', 'File', 'File',
+                    GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,
+                    Gio.File.$gtype)
+            },
+        });
+        let file = Gio.File.new_for_path('dummy');
+        expect(() => new InterfacePropObject({ file: file })).not.toThrow();
+    });
+
+    it('can override a property from the parent class', function () {
+        const OverrideObject = new Lang.Class({
+            Name: 'OverrideObject',
+            Extends: MyObject,
+            Properties: {
+                'readwrite': GObject.ParamSpec.override('readwrite', MyObject),
+            },
+            get readwrite() {
+                return this._subclass_readwrite;
+            },
+            set readwrite(val) {
+                this._subclass_readwrite = 'subclass' + val;
+            },
+        });
+        let obj = new OverrideObject();
+        obj.readwrite = 'foo';
+        expect(obj.readwrite).toEqual('subclassfoo');
+    });
+
+    it('cannot override a non-existent property', function () {
+        expect(() => new Lang.Class({
+            Name: 'BadOverride',
+            Extends: GObject.Object,
+            Properties: {
+                'nonexistent': GObject.ParamSpec.override('nonexistent', GObject.Object),
+            },
+        })).toThrow();
+    });
+});
+
+const AnInterface = new Lang.Interface({
+    Name: 'AnInterface',
+});
+
+const GObjectImplementingLangInterface = new Lang.Class({
+    Name: 'GObjectImplementingLangInterface',
+    Extends: GObject.Object,
+    Implements: [ AnInterface ],
+
+    _init: function (props={}) {
+        this.parent(props);
+    }
+});
+
+const AGObjectInterface = new Lang.Interface({
+    Name: 'AGObjectInterface',
+    GTypeName: 'ArbitraryGTypeName',
+    Requires: [ GObject.Object ],
+    Properties: {
+        'interface-prop': GObject.ParamSpec.string('interface-prop',
+            'Interface property', 'Must be overridden in implementation',
+            GObject.ParamFlags.READABLE,
+            'foobar')
+    },
+    Signals: {
+        'interface-signal': {}
+    },
+
+    requiredG: Lang.Interface.UNIMPLEMENTED,
+    optionalG: function () {
+        return 'AGObjectInterface.optionalG()';
+    }
+});
+
+const InterfaceRequiringGObjectInterface = new Lang.Interface({
+    Name: 'InterfaceRequiringGObjectInterface',
+    Requires: [ AGObjectInterface ],
+
+    optionalG: function () {
+        return 'InterfaceRequiringGObjectInterface.optionalG()\n' +
+            AGObjectInterface.optionalG(this);
+    }
+});
+
+const GObjectImplementingGObjectInterface = new Lang.Class({
+    Name: 'GObjectImplementingGObjectInterface',
+    Extends: GObject.Object,
+    Implements: [ AGObjectInterface ],
+    Properties: {
+        'interface-prop': GObject.ParamSpec.override('interface-prop',
+            AGObjectInterface),
+        'class-prop': GObject.ParamSpec.string('class-prop', 'Class property',
+            'A property that is not on the interface',
+            GObject.ParamFlags.READABLE, 'meh')
+    },
+    Signals: {
+        'class-signal': {},
+    },
+
+    get interface_prop() {
+        return 'foobar';
+    },
+
+    get class_prop() {
+        return 'meh';
+    },
+
+    _init: function (props={}) {
+        this.parent(props);
+    },
+    requiredG: function () {},
+    optionalG: function () {
+        return AGObjectInterface.optionalG(this);
+    }
+});
+
+const MinimalImplementationOfAGObjectInterface = new Lang.Class({
+    Name: 'MinimalImplementationOfAGObjectInterface',
+    Extends: GObject.Object,
+    Implements: [ AGObjectInterface ],
+    Properties: {
+        'interface-prop': GObject.ParamSpec.override('interface-prop',
+            AGObjectInterface)
+    },
+
+    _init: function (props={}) {
+        this.parent(props);
+    },
+    requiredG: function () {}
+});
+
+const ImplementationOfTwoInterfaces = new Lang.Class({
+    Name: 'ImplementationOfTwoInterfaces',
+    Extends: GObject.Object,
+    Implements: [ AGObjectInterface, InterfaceRequiringGObjectInterface ],
+    Properties: {
+        'interface-prop': GObject.ParamSpec.override('interface-prop',
+            AGObjectInterface)
+    },
+
+    _init: function (props={}) {
+        this.parent(props);
+    },
+    requiredG: function () {},
+    optionalG: function () {
+        return InterfaceRequiringGObjectInterface.optionalG(this);
+    }
+});
+
+describe('GObject interface', function () {
+    it('class can implement a Lang.Interface', function () {
+        let obj;
+        expect(() => { obj = new GObjectImplementingLangInterface(); })
+            .not.toThrow();
+        expect(obj.constructor.implements(AnInterface)).toBeTruthy();
+    });
+
+    it('throws when an interface requires a GObject interface but not GObject.Object', function () {
+        expect(() => new Lang.Interface({
+            Name: 'GObjectInterfaceNotRequiringGObject',
+            GTypeName: 'GTypeNameNotRequiringGObject',
+            Requires: [ Gio.Initable ]
+        })).toThrow();
+    });
+
+    it('can be implemented by a GObject class along with a JS interface', function () {
+        const ObjectImplementingLangInterfaceAndCInterface = new Lang.Class({
+            Name: 'ObjectImplementingLangInterfaceAndCInterface',
+            Extends: GObject.Object,
+            Implements: [ AnInterface, Gio.Initable ],
+
+            _init: function (props={}) {
+                this.parent(props);
+            }
+        });
+        let obj;
+        expect(() => { obj = new ObjectImplementingLangInterfaceAndCInterface(); })
+            .not.toThrow();
+        expect(obj.constructor.implements(AnInterface)).toBeTruthy();
+        expect(obj.constructor.implements(Gio.Initable)).toBeTruthy();
+    });
+
+    it('is an instance of the interface classes', function () {
+        expect(AGObjectInterface instanceof Lang.Interface).toBeTruthy();
+        expect(AGObjectInterface instanceof GObject.Interface).toBeTruthy();
+    });
+
+    it('cannot be instantiated', function () {
+        expect(() => new AGObjectInterface()).toThrow();
+    });
+
+    it('reports its type name', function () {
+        expect(AGObjectInterface.$gtype.name).toEqual('ArbitraryGTypeName');
+    });
+
+    it('can be implemented by a GObject class', function () {
+        let obj;
+        expect(() => { obj = new GObjectImplementingGObjectInterface(); })
+            .not.toThrow();
+        expect(obj.constructor.implements(AGObjectInterface)).toBeTruthy();
+    });
+
+    it('is implemented by a GObject class with the correct class object', function () {
+        let obj = new GObjectImplementingGObjectInterface();
+        expect(obj.constructor).toEqual(GObjectImplementingGObjectInterface);
+        expect(obj.constructor.toString())
+            .toEqual('[object GObjectClass for GObjectImplementingGObjectInterface]');
+    });
+
+    it('can be implemented by a class also implementing a Lang.Interface', function () {
+        const GObjectImplementingBothKindsOfInterface = new Lang.Class({
+            Name: 'GObjectImplementingBothKindsOfInterface',
+            Extends: GObject.Object,
+            Implements: [ AnInterface, AGObjectInterface ],
+            Properties: {
+                'interface-prop': GObject.ParamSpec.override('interface-prop',
+                    AGObjectInterface)
+            },
+
+            _init: function (props={}) {
+                this.parent(props);
+            },
+            required: function () {},
+            requiredG: function () {}
+        });
+        let obj;
+        expect(() => { obj = new GObjectImplementingBothKindsOfInterface(); })
+            .not.toThrow();
+        expect(obj.constructor.implements(AnInterface)).toBeTruthy();
+        expect(obj.constructor.implements(AGObjectInterface)).toBeTruthy();
+    });
+
+    it('can have its required function implemented', function () {
+        expect(() => {
+            let obj = new GObjectImplementingGObjectInterface();
+            obj.requiredG();
+        }).not.toThrow();
+    });
+
+    it('must have its required function implemented', function () {
+        expect(() => new Lang.Class({
+            Name: 'BadObject',
+            Extends: GObject.Object,
+            Implements: [ AGObjectInterface ],
+            Properties: {
+                'interface-prop': GObject.ParamSpec.override('interface-prop',
+                    AGObjectInterface)
+            }
+        })).toThrow();
+    });
+
+    it("doesn't have to have its optional function implemented", function () {
+        let obj;
+        expect(() => { obj = new MinimalImplementationOfAGObjectInterface(); })
+            .not.toThrow();
+        expect(obj.constructor.implements(AGObjectInterface)).toBeTruthy();
+    });
+
+    it('can have its optional function deferred to by the implementation', function () {
+        let obj = new MinimalImplementationOfAGObjectInterface();
+        expect(obj.optionalG()).toEqual('AGObjectInterface.optionalG()');
+    });
+
+    it('can have its function chained up to', function () {
+        let obj = new GObjectImplementingGObjectInterface();
+        expect(obj.optionalG()).toEqual('AGObjectInterface.optionalG()');
+    });
+
+    it('can require another interface', function () {
+        let obj;
+        expect(() => { obj = new ImplementationOfTwoInterfaces(); }).not.toThrow();
+        expect(obj.constructor.implements(AGObjectInterface)).toBeTruthy();
+        expect(obj.constructor.implements(InterfaceRequiringGObjectInterface))
+            .toBeTruthy();
+    });
+
+    it('can chain up to another interface', function () {
+        let obj = new ImplementationOfTwoInterfaces();
+        expect(obj.optionalG())
+            .toEqual('InterfaceRequiringGObjectInterface.optionalG()\nAGObjectInterface.optionalG()');
+    });
+
+    it("defers to the last interface's optional function", function () {
+        const MinimalImplementationOfTwoInterfaces = new Lang.Class({
+            Name: 'MinimalImplementationOfTwoInterfaces',
+            Extends: GObject.Object,
+            Implements: [ AGObjectInterface, InterfaceRequiringGObjectInterface ],
+            Properties: {
+                'interface-prop': GObject.ParamSpec.override('interface-prop',
+                    AGObjectInterface)
+            },
+
+            _init: function (props={}) {
+                this.parent(props);
+            },
+            requiredG: function () {}
+        });
+        let obj = new MinimalImplementationOfTwoInterfaces();
+        expect(obj.optionalG())
+            .toEqual('InterfaceRequiringGObjectInterface.optionalG()\nAGObjectInterface.optionalG()');
+    });
+
+    it('must be implemented by a class that implements all required interfaces', function () {
+        expect(() => new Lang.Class({
+            Name: 'BadObject',
+            Implements: [ InterfaceRequiringGObjectInterface ],
+            required: function () {}
+        })).toThrow();
+    });
+
+    it('must be implemented by a class that implements required interfaces in correct order', function () {
+        expect(() => new Lang.Class({
+            Name: 'BadObject',
+            Implements: [ InterfaceRequiringGObjectInterface, AGObjectInterface ],
+            required: function () {}
+        })).toThrow();
+    });
+
+    it('can require an interface from C', function () {
+        const InitableInterface = new Lang.Interface({
+            Name: 'InitableInterface',
+            Requires: [ GObject.Object, Gio.Initable ]
+        });
+        expect(() => new Lang.Class({
+            Name: 'BadObject',
+            Implements: [ InitableInterface ]
+        })).toThrow();
+    });
+
+    it('can define signals on the implementing class', function () {
+        function quitLoop() {
+            Mainloop.quit('signal');
+        }
+        let obj = new GObjectImplementingGObjectInterface();
+        let interfaceSignalSpy = jasmine.createSpy('interfaceSignalSpy')
+            .and.callFake(quitLoop);
+        let classSignalSpy = jasmine.createSpy('classSignalSpy')
+            .and.callFake(quitLoop);
+        obj.connect('interface-signal', interfaceSignalSpy);
+        obj.connect('class-signal', classSignalSpy);
+        GLib.idle_add(GLib.PRIORITY_DEFAULT, () => {
+            obj.emit('interface-signal');
+            return GLib.SOURCE_REMOVE;
+        });
+        Mainloop.run('signal');
+        GLib.idle_add(GLib.PRIORITY_DEFAULT, () => {
+            obj.emit('class-signal');
+            return GLib.SOURCE_REMOVE;
+        });
+        Mainloop.run('signal');
+        expect(interfaceSignalSpy).toHaveBeenCalled();
+        expect(classSignalSpy).toHaveBeenCalled();
+    });
+
+    it('can define properties on the implementing class', function () {
+        let obj = new GObjectImplementingGObjectInterface();
+        expect(obj.interface_prop).toEqual('foobar');
+        expect(obj.class_prop).toEqual('meh');
+    });
+
+    it('must have its properties overridden', function () {
+        // Failing to override an interface property doesn't raise an error but
+        // instead logs a critical warning.
+        GLib.test_expect_message('GLib-GObject', GLib.LogLevelFlags.LEVEL_CRITICAL,
+            "Object class * doesn't implement property 'interface-prop' from " +
+            "interface 'ArbitraryGTypeName'");
+        new Lang.Class({
+            Name: 'MyNaughtyObject',
+            Extends: GObject.Object,
+            Implements: [ AGObjectInterface ],
+            _init: function (props={}) {
+                this.parent(props);
+            },
+            requiredG: function () {}
+        });
+        // g_test_assert_expected_messages() is a macro, not introspectable
+        GLib.test_assert_expected_messages_internal('Gjs', 'testGObjectInterface.js',
+            416, 'testGObjectMustOverrideInterfaceProperties');
+    });
+
+    // This makes sure that we catch the case where the metaclass (e.g.
+    // GtkWidgetClass) doesn't specify a meta-interface. In that case we get the
+    // meta-interface from the metaclass's parent.
+    it('gets the correct type for its metaclass', function () {
+        const MyMeta = new Lang.Class({
+            Name: 'MyMeta',
+            Extends: GObject.Class
+        });
+        const MyMetaObject = new MyMeta({
+            Name: 'MyMetaObject'
+        });
+        const MyMetaInterface = new Lang.Interface({
+            Name: 'MyMetaInterface',
+            Requires: [ MyMetaObject ]
+        });
+        expect(MyMetaInterface instanceof GObject.Interface).toBeTruthy();
+    });
+
+    it('can be implemented by a class as well as its parent class', function () {
+        const SubObject = new Lang.Class({
+            Name: 'SubObject',
+            Extends: GObjectImplementingGObjectInterface
+        });
+        let obj = new SubObject();
+        expect(obj.constructor.implements(AGObjectInterface)).toBeTruthy();
+        expect(obj.interface_prop).toEqual('foobar');  // override not needed
+    });
+
+    it('can be reimplemented by a subclass of a class that already implements it', function () {
+        const SubImplementer = new Lang.Class({
+            Name: 'SubImplementer',
+            Extends: GObjectImplementingGObjectInterface,
+            Implements: [ AGObjectInterface ]
+        });
+        let obj = new SubImplementer();
+        expect(obj.constructor.implements(AGObjectInterface)).toBeTruthy();
+        expect(obj.interface_prop).toEqual('foobar');  // override not needed
+    });
+});
+
+const template = ' \
+<interface> \
+  <template class="Gjs_MyComplexGtkSubclass" parent="GtkGrid"> \
+    <property name="margin_top">10</property> \
+    <property name="margin_bottom">10</property> \
+    <property name="margin_start">10</property> \
+    <property name="margin_end">10</property> \
+    <property name="visible">True</property> \
+    <child> \
+      <object class="GtkLabel" id="label-child"> \
+        <property name="label">Complex!</property> \
+        <property name="visible">True</property> \
+      </object> \
+    </child> \
+    <child> \
+      <object class="GtkLabel" id="label-child2"> \
+        <property name="label">Complex as well!</property> \
+        <property name="visible">True</property> \
+      </object> \
+    </child> \
+    <child> \
+      <object class="GtkLabel" id="internal-label-child"> \
+        <property name="label">Complex and internal!</property> \
+        <property name="visible">True</property> \
+      </object> \
+    </child> \
+  </template> \
+</interface>';
+
+const MyComplexGtkSubclass = new Lang.Class({
+    Name: 'MyComplexGtkSubclass',
+    Extends: Gtk.Grid,
+    Template: ByteArray.fromString(template),
+    Children: ['label-child', 'label-child2'],
+    InternalChildren: ['internal-label-child'],
+    CssName: 'complex-subclass',
+
+    testChildrenExist: function () {
+        this._internalLabel = this.get_template_child(MyComplexGtkSubclass, 'label-child');
+        expect(this._internalLabel).toEqual(jasmine.anything());
+
+        expect(this.label_child2).toEqual(jasmine.anything());
+        expect(this._internal_label_child).toEqual(jasmine.anything());
+    }
+});
+
+const MyComplexGtkSubclassFromResource = new Lang.Class({
+    Name: 'MyComplexGtkSubclassFromResource',
+    Extends: Gtk.Grid,
+    Template: 'resource:///org/gjs/jsunit/complex.ui',
+    Children: ['label-child', 'label-child2'],
+    InternalChildren: ['internal-label-child'],
+
+    testChildrenExist: function () {
+        expect(this.label_child).toEqual(jasmine.anything());
+        expect(this.label_child2).toEqual(jasmine.anything());
+        expect(this._internal_label_child).toEqual(jasmine.anything());
+    }
+});
+
+function validateTemplate(description, ClassName) {
+    describe(description, function () {
+        let win, content;
+        beforeEach(function () {
+            win = new Gtk.Window({ type: Gtk.WindowType.TOPLEVEL });
+            content = new ClassName();
+            win.add(content);
+        });
+
+        it('sets up internal and public template children', function () {
+            content.testChildrenExist();
+        });
+
+        it('sets up public template children with the correct widgets', function () {
+            expect(content.label_child.get_label()).toEqual('Complex!');
+            expect(content.label_child2.get_label()).toEqual('Complex as well!');
+        });
+
+        it('sets up internal template children with the correct widgets', function () {
+            expect(content._internal_label_child.get_label())
+                .toEqual('Complex and internal!');
+        });
+
+        afterEach(function () {
+            win.destroy();
+        });
+    });
+}
+
+describe('Legacy Gtk overrides', function () {
+    beforeAll(function () {
+        Gtk.init(null);
+    });
+
+    validateTemplate('UI template', MyComplexGtkSubclass);
+    validateTemplate('UI template from resource', MyComplexGtkSubclassFromResource);
+
+    it('sets CSS names on classes', function () {
+        expect(Gtk.Widget.get_css_name.call(MyComplexGtkSubclass)).toEqual('complex-subclass');
+    });
+});
diff --git a/modules/_legacy.js b/modules/_legacy.js
index 83a91361..92fe4b3b 100644
--- a/modules/_legacy.js
+++ b/modules/_legacy.js
@@ -1,5 +1,5 @@
 /* -*- mode: js; indent-tabs-mode: nil; -*- */
-/* exported Class, Interface */
+/* exported Class, Interface, defineGObjectLegacyObjects */
 // Copyright 2008  litl, LLC
 // Copyright 2011  Jasper St. Pierre
 
@@ -397,3 +397,295 @@ Interface.prototype._init = function (params) {
         },
     });
 };
+
+// GObject Lang.Class magic
+
+function defineGObjectLegacyObjects(GObject) {
+    const Gi = imports._gi;
+
+    // Some common functions between GObject.Class and GObject.Interface
+
+    function _createSignals(gtype, signals) {
+        for (let signalName in signals) {
+            let obj = signals[signalName];
+            let flags = (obj.flags !== undefined) ? obj.flags : GObject.SignalFlags.RUN_FIRST;
+            let accumulator = (obj.accumulator !== undefined) ? obj.accumulator : GObject.AccumulatorType.NONE;
+            let rtype = (obj.return_type !== undefined) ? obj.return_type : GObject.TYPE_NONE;
+            let paramtypes = (obj.param_types !== undefined) ? obj.param_types : [];
+
+            try {
+                obj.signal_id = Gi.signal_new(gtype, signalName, flags, accumulator, rtype, paramtypes);
+            } catch (e) {
+                throw new TypeError('Invalid signal ' + signalName + ': ' + e.message);
+            }
+        }
+    }
+
+    function _createGTypeName(params) {
+        if (params.GTypeName)
+            return params.GTypeName;
+        else
+            return 'Gjs_' + params.Name;
+    }
+
+    function _getGObjectInterfaces(interfaces) {
+        return interfaces.filter((iface) => iface.hasOwnProperty('$gtype'));
+    }
+
+    function _propertiesAsArray(params) {
+        let propertiesArray = [];
+        if (params.Properties) {
+            for (let prop in params.Properties) {
+                propertiesArray.push(params.Properties[prop]);
+            }
+        }
+        return propertiesArray;
+    }
+
+    const GObjectMeta = new Class({
+        Name: 'GObjectClass',
+        Extends: Class,
+
+        _init: function (params) {
+            // retrieve signals and remove them from params before chaining
+            let signals = params.Signals;
+            delete params.Signals;
+
+            this.parent(params);
+
+            if (signals)
+                _createSignals(this.$gtype, signals);
+
+            Object.getOwnPropertyNames(params).forEach(function(name) {
+                if (name == 'Name' || name == 'Extends' || name == 'Abstract')
+                    return;
+
+                let descriptor = Object.getOwnPropertyDescriptor(params, name);
+
+                if (typeof descriptor.value === 'function') {
+                    let wrapped = this.prototype[name];
+
+                    if (name.slice(0, 6) == 'vfunc_') {
+                        Gi.hook_up_vfunc(this.prototype, name.slice(6), wrapped);
+                    } else if (name.slice(0, 3) == 'on_') {
+                        let id = GObject.signal_lookup(name.slice(3).replace('_', '-'), this.$gtype);
+                        if (id !== 0) {
+                            GObject.signal_override_class_closure(id, this.$gtype, function() {
+                                let argArray = Array.prototype.slice.call(arguments);
+                                let emitter = argArray.shift();
+
+                                return wrapped.apply(emitter, argArray);
+                            });
+                        }
+                    }
+                }
+            }.bind(this));
+        },
+
+        _isValidClass: function(klass) {
+            let proto = klass.prototype;
+
+            if (!proto)
+                return false;
+
+            // If proto == GObject.Object.prototype, then
+            // proto.__proto__ is Object, so "proto instanceof GObject.Object"
+            // will return false.
+            return proto == GObject.Object.prototype ||
+                proto instanceof GObject.Object;
+        },
+
+        // If we want an object with a custom JSClass, we can't just
+        // use a function. We have to use a custom constructor here.
+        _construct: function(params) {
+            if (!params.Name)
+                throw new TypeError("Classes require an explicit 'Name' parameter.");
+            let name = params.Name;
+
+            let gtypename = _createGTypeName(params);
+
+            if (!params.Extends)
+                params.Extends = GObject.Object;
+            let parent = params.Extends;
+
+            if (!this._isValidClass(parent))
+                throw new TypeError('GObject.Class used with invalid base class (is ' + parent + ')');
+
+            let interfaces = params.Implements || [];
+            if (parent instanceof Class)
+                interfaces = interfaces.filter(iface => !parent.implements(iface));
+            let gobjectInterfaces = _getGObjectInterfaces(interfaces);
+
+            let propertiesArray = _propertiesAsArray(params);
+            delete params.Properties;
+
+            let newClass = Gi.register_type(parent.prototype, gtypename,
+                gobjectInterfaces, propertiesArray);
+
+            // See Class.prototype._construct for the reasoning
+            // behind this direct prototype set.
+            Object.setPrototypeOf(newClass, this.constructor.prototype);
+            newClass.__super__ = parent;
+
+            newClass._init.apply(newClass, arguments);
+
+            Object.defineProperties(newClass.prototype, {
+                '__metaclass__': {
+                    writable: false,
+                    configurable: false,
+                    enumerable: false,
+                    value: this.constructor,
+                },
+                '__interfaces__': {
+                    writable: false,
+                    configurable: false,
+                    enumerable: false,
+                    value: interfaces,
+                },
+            });
+
+            interfaces.forEach((iface) => {
+                if (iface instanceof Interface)
+                    iface._check(newClass.prototype);
+            });
+
+            return newClass;
+        },
+
+        // Overrides Lang.Class.implements()
+        implements: function (iface) {
+            if (iface instanceof GObject.Interface) {
+                return GObject.type_is_a(this.$gtype, iface.$gtype);
+            } else {
+                return this.parent(iface);
+            }
+        }
+    });
+
+    function GObjectInterface() {
+        return this._construct.apply(this, arguments);
+    }
+
+    GObjectMeta.MetaInterface = GObjectInterface;
+
+    GObjectInterface.__super__ = Interface;
+    GObjectInterface.prototype = Object.create(Interface.prototype);
+    GObjectInterface.prototype.constructor = GObjectInterface;
+    GObjectInterface.prototype.__name__ = 'GObjectInterface';
+
+    GObjectInterface.prototype._construct = function (params) {
+        if (!params.Name) {
+            throw new TypeError("Interfaces require an explicit 'Name' parameter.");
+        }
+
+        let gtypename = _createGTypeName(params);
+        delete params.GTypeName;
+
+        let interfaces = params.Requires || [];
+        let gobjectInterfaces = _getGObjectInterfaces(interfaces);
+
+        let properties = _propertiesAsArray(params);
+        delete params.Properties;
+
+        let newInterface = Gi.register_interface(gtypename, gobjectInterfaces,
+            properties);
+
+        // See Class.prototype._construct for the reasoning
+        // behind this direct prototype set.
+        Object.setPrototypeOf(newInterface, this.constructor.prototype);
+        newInterface.__super__ = GObjectInterface;
+        newInterface.prototype.constructor = newInterface;
+
+        newInterface._init.apply(newInterface, arguments);
+
+        Object.defineProperty(newInterface.prototype, '__metaclass__', {
+            writable: false,
+            configurable: false,
+            enumerable: false,
+            value: this.constructor,
+        });
+
+        return newInterface;
+    };
+
+    GObjectInterface.prototype._init = function (params) {
+        let signals = params.Signals;
+        delete params.Signals;
+
+        Interface.prototype._init.call(this, params);
+
+        _createSignals(this.$gtype, signals);
+    };
+
+    return {GObjectMeta, GObjectInterface};
+}
+
+function defineGtkLegacyObjects(GObject, Gtk) {
+    const GtkWidgetClass = new Class({
+        Name: 'GtkWidgetClass',
+        Extends: GObject.Class,
+
+        _init: function(params) {
+            let template = params.Template;
+            delete params.Template;
+
+            let children = params.Children;
+            delete params.Children;
+
+            let internalChildren = params.InternalChildren;
+            delete params.InternalChildren;
+
+            let cssName = params.CssName;
+            delete params.CssName;
+
+            if (template) {
+                params._instance_init = function() {
+                    this.init_template();
+                };
+            }
+
+            this.parent(params);
+
+            if (cssName)
+                Gtk.Widget.set_css_name.call(this, cssName);
+
+            if (template) {
+                if (typeof template == 'string' &&
+                    template.startsWith('resource:///'))
+                    Gtk.Widget.set_template_from_resource.call(this, template.slice(11));
+                else
+                    Gtk.Widget.set_template.call(this, template);
+            }
+
+            this.Template = template;
+            this.Children = children;
+            this.InternalChildren = internalChildren;
+
+            if (children) {
+                for (let i = 0; i < children.length; i++)
+                    Gtk.Widget.bind_template_child_full.call(this, children[i], false, 0);
+            }
+
+            if (internalChildren) {
+                for (let i = 0; i < internalChildren.length; i++)
+                    Gtk.Widget.bind_template_child_full.call(this, internalChildren[i], true, 0);
+            }
+        },
+
+        _isValidClass: function(klass) {
+            let proto = klass.prototype;
+
+            if (!proto)
+                return false;
+
+            // If proto == Gtk.Widget.prototype, then
+            // proto.__proto__ is GObject.InitiallyUnowned, so
+            // "proto instanceof Gtk.Widget"
+            // will return false.
+            return proto == Gtk.Widget.prototype ||
+                proto instanceof Gtk.Widget;
+        },
+    });
+
+    return {GtkWidgetClass};
+}
\ No newline at end of file
diff --git a/modules/overrides/GObject.js b/modules/overrides/GObject.js
index ed1db051..a99b3f2c 100644
--- a/modules/overrides/GObject.js
+++ b/modules/overrides/GObject.js
@@ -20,222 +20,10 @@
 
 const Gi = imports._gi;
 const CjsPrivate = imports.gi.CjsPrivate;
-const Lang = imports.lang;
 const Legacy = imports._legacy;
 
 let GObject;
 
-// Some common functions between GObject.Class and GObject.Interface
-
-function _createSignals(gtype, signals) {
-    for (let signalName in signals) {
-        let obj = signals[signalName];
-        let flags = (obj.flags !== undefined) ? obj.flags : GObject.SignalFlags.RUN_FIRST;
-        let accumulator = (obj.accumulator !== undefined) ? obj.accumulator : GObject.AccumulatorType.NONE;
-        let rtype = (obj.return_type !== undefined) ? obj.return_type : GObject.TYPE_NONE;
-        let paramtypes = (obj.param_types !== undefined) ? obj.param_types : [];
-
-        try {
-            obj.signal_id = Gi.signal_new(gtype, signalName, flags, accumulator, rtype, paramtypes);
-        } catch (e) {
-            throw new TypeError('Invalid signal ' + signalName + ': ' + e.message);
-        }
-    }
-}
-
-function _createGTypeName(params) {
-    if (params.GTypeName)
-        return params.GTypeName;
-    else
-        return 'Gjs_' + params.Name;
-}
-
-function _getGObjectInterfaces(interfaces) {
-    return interfaces.filter((iface) => iface.hasOwnProperty('$gtype'));
-}
-
-function _propertiesAsArray(params) {
-    let propertiesArray = [];
-    if (params.Properties) {
-        for (let prop in params.Properties) {
-            propertiesArray.push(params.Properties[prop]);
-        }
-    }
-    return propertiesArray;
-}
-
-const GObjectMeta = new Lang.Class({
-    Name: 'GObjectClass',
-    Extends: Lang.Class,
-
-    _init: function (params) {
-        // retrieve signals and remove them from params before chaining
-	let signals = params.Signals;
-        delete params.Signals;
-
-        this.parent(params);
-
-        if (signals)
-            _createSignals(this.$gtype, signals);
-
-	let propertyObj = { };
-	Object.getOwnPropertyNames(params).forEach(function(name) {
-            if (name == 'Name' || name == 'Extends' || name == 'Abstract')
-		return;
-
-            let descriptor = Object.getOwnPropertyDescriptor(params, name);
-
-            if (typeof descriptor.value === 'function') {
-		let wrapped = this.prototype[name];
-
-                if (name.slice(0, 6) == 'vfunc_') {
-                    Gi.hook_up_vfunc(this.prototype, name.slice(6), wrapped);
-                } else if (name.slice(0, 3) == 'on_') {
-                    let id = GObject.signal_lookup(name.slice(3).replace('_', '-'), this.$gtype);
-                    if (id != 0) {
-                        GObject.signal_override_class_closure(id, this.$gtype, function() {
-                            let argArray = Array.prototype.slice.call(arguments);
-                            let emitter = argArray.shift();
-
-                            return wrapped.apply(emitter, argArray);
-                        });
-                    }
-                }
-	    }
-	}.bind(this));
-    },
-
-    _isValidClass: function(klass) {
-        let proto = klass.prototype;
-
-        if (!proto)
-            return false;
-
-        // If proto == GObject.Object.prototype, then
-        // proto.__proto__ is Object, so "proto instanceof GObject.Object"
-        // will return false.
-        return proto == GObject.Object.prototype ||
-            proto instanceof GObject.Object;
-    },
-
-    // If we want an object with a custom JSClass, we can't just
-    // use a function. We have to use a custom constructor here.
-    _construct: function(params) {
-        if (!params.Name)
-            throw new TypeError("Classes require an explicit 'Name' parameter.");
-        let name = params.Name;
-
-        let gtypename = _createGTypeName(params);
-
-        if (!params.Extends)
-            params.Extends = GObject.Object;
-        let parent = params.Extends;
-
-        if (!this._isValidClass(parent))
-            throw new TypeError('GObject.Class used with invalid base class (is ' + parent + ')');
-
-        let interfaces = params.Implements || [];
-        if (parent instanceof Lang.Class)
-            interfaces = interfaces.filter((iface) => !parent.implements(iface));
-        let gobjectInterfaces = _getGObjectInterfaces(interfaces);
-
-        let propertiesArray = _propertiesAsArray(params);
-        delete params.Properties;
-
-        let newClass = Gi.register_type(parent.prototype, gtypename,
-            gobjectInterfaces, propertiesArray);
-
-        // See Class.prototype._construct in _legacy.js for the reasoning
-        // behind this direct prototype set.
-        Object.setPrototypeOf(newClass, this.constructor.prototype);
-        newClass.__super__ = parent;
-
-        newClass._init.apply(newClass, arguments);
-
-        Object.defineProperties(newClass.prototype, {
-            '__metaclass__': { writable: false,
-                               configurable: false,
-                               enumerable: false,
-                               value: this.constructor },
-            '__interfaces__': { writable: false,
-                                configurable: false,
-                                enumerable: false,
-                                value: interfaces }
-        });
-
-        interfaces.forEach((iface) => {
-            if (iface instanceof Lang.Interface)
-                iface._check(newClass.prototype);
-        });
-
-        return newClass;
-    },
-
-    // Overrides Lang.Class.implements()
-    implements: function (iface) {
-        if (iface instanceof GObject.Interface) {
-            return GObject.type_is_a(this.$gtype, iface.$gtype);
-        } else {
-            return this.parent(iface);
-        }
-    }
-});
-
-function GObjectInterface(params) {
-    return this._construct.apply(this, arguments);
-}
-
-GObjectMeta.MetaInterface = GObjectInterface;
-
-GObjectInterface.__super__ = Lang.Interface;
-GObjectInterface.prototype = Object.create(Lang.Interface.prototype);
-GObjectInterface.prototype.constructor = GObjectInterface;
-GObjectInterface.prototype.__name__ = 'GObjectInterface';
-
-GObjectInterface.prototype._construct = function (params) {
-    if (!params.Name) {
-        throw new TypeError("Interfaces require an explicit 'Name' parameter.");
-    }
-
-    let gtypename = _createGTypeName(params);
-    delete params.GTypeName;
-
-    let interfaces = params.Requires || [];
-    let gobjectInterfaces = _getGObjectInterfaces(interfaces);
-
-    let properties = _propertiesAsArray(params);
-    delete params.Properties;
-
-    let newInterface = Gi.register_interface(gtypename, gobjectInterfaces,
-        properties);
-
-    // See Class.prototype._construct in _legacy.js for the reasoning
-    // behind this direct prototype set.
-    Object.setPrototypeOf(newInterface, this.constructor.prototype);
-    newInterface.__super__ = GObjectInterface;
-    newInterface.prototype.constructor = newInterface;
-
-    newInterface._init.apply(newInterface, arguments);
-
-    Object.defineProperty(newInterface.prototype, '__metaclass__', {
-        writable: false,
-        configurable: false,
-        enumerable: false,
-        value: this.constructor
-    });
-
-    return newInterface;
-};
-
-GObjectInterface.prototype._init = function (params) {
-    let signals = params.Signals;
-    delete params.Signals;
-
-    Lang.Interface.prototype._init.call(this, params);
-
-    _createSignals(this.$gtype, signals);
-};
-
 function _init() {
 
     GObject = this;
@@ -384,7 +172,7 @@ function _init() {
                          get: function() { return CjsPrivate.param_spec_get_owner_type(this) } },
     });
 
-
+    let {GObjectMeta, GObjectInterface} = Legacy.defineGObjectLegacyObjects(GObject);
     this.Class = GObjectMeta;
     this.Interface = GObjectInterface;
     this.Object.prototype.__metaclass__ = this.Class;
diff --git a/modules/overrides/Gtk.js b/modules/overrides/Gtk.js
index 78365398..5e98a58c 100644
--- a/modules/overrides/Gtk.js
+++ b/modules/overrides/Gtk.js
@@ -19,83 +19,18 @@
 // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 // IN THE SOFTWARE.
 
-const Lang = imports.lang;
+const Legacy = imports._legacy;
 const GObject = imports.gi.GObject;
 
 var CjsPrivate = imports.gi.CjsPrivate;
 
 let Gtk;
 
-const GtkWidgetClass = new Lang.Class({
-    Name: 'GtkWidgetClass',
-    Extends: GObject.Class,
-
-    _init: function(params) {
-        let template = params.Template;
-        delete params.Template;
-
-        let children = params.Children;
-        delete params.Children;
-
-        let internalChildren = params.InternalChildren;
-        delete params.InternalChildren;
-
-        let cssName = params.CssName;
-        delete params.CssName;
-
-        if (template) {
-            params._instance_init = function() {
-                this.init_template();
-            };
-        }
-
-        this.parent(params);
-
-        if (cssName)
-            Gtk.Widget.set_css_name.call(this, cssName);
-
-        if (template) {
-            if (typeof template == 'string' &&
-                template.startsWith('resource:///'))
-                Gtk.Widget.set_template_from_resource.call(this, template.slice(11));
-            else
-                Gtk.Widget.set_template.call(this, template);
-        }
-
-        this.Template = template;
-        this.Children = children;
-        this.InternalChildren = internalChildren;
-
-        if (children) {
-            for (let i = 0; i < children.length; i++)
-                Gtk.Widget.bind_template_child_full.call(this, children[i], false, 0);
-        }
-
-        if (internalChildren) {
-            for (let i = 0; i < internalChildren.length; i++)
-                Gtk.Widget.bind_template_child_full.call(this, internalChildren[i], true, 0);
-        }
-    },
-
-    _isValidClass: function(klass) {
-        let proto = klass.prototype;
-
-        if (!proto)
-            return false;
-
-        // If proto == Gtk.Widget.prototype, then
-        // proto.__proto__ is GObject.InitiallyUnowned, so
-        // "proto instanceof Gtk.Widget"
-        // will return false.
-        return proto == Gtk.Widget.prototype ||
-            proto instanceof Gtk.Widget;
-    },
-});
-
 function _init() {
 
     Gtk = this;
 
+    let {GtkWidgetClass} = Legacy.defineGtkLegacyObjects(GObject, Gtk);
     Gtk.Widget.prototype.__metaclass__ = GtkWidgetClass;
     if (CjsPrivate.gtk_container_child_set_property) {
         Gtk.Container.prototype.child_set_property = function(child, property, value) {

From ba98e2cc4090bbb563b0e75717928db579c5276d Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Thu, 3 Aug 2017 02:20:32 +0100
Subject: [PATCH 093/154] GObject: Adapt GObject class framework to ES6

This moves our GObject class framework to use ES6 classes. GObject.Object
and GObject.Interface gain static _classInit() methods which register
GTypes and perform other such magic that used to be performed in the
metaclasses. When defining the class you must call
GObject.registerClass() on the class object, with an optional metadata
object as the first argument. (The metadata object works exactly like the
meta properties from Lang.Class, except that Name and Extends are not
present.)

Old:

    var MyClass = new Lang.Class({
        Name: 'MyClass',
        Extends: GObject.Object,
        Signals: { 'event': {} },
        _init(props={}) {
            this._private = [];
            this.parent(props);
        },
    });

New:

    var MyClass = GObject.registerClass({
        Signals: { 'event': {} },
    }, class MyClass extends GObject.Object {
        _init(props={}) {
            this._private = [];
            super._init(props);
        }
    });

It is forward compatible with the following syntax requiring decorators
and class fields, which are not in the JS standard yet:

    @GObject.registerClass
    class MyClass extends GObject.Object {
        static [GObject.signals] = { 'event': {} }
        _init(props={}) {
            this._private = [];
            super._init(props);
        }
    }

We also now add a [Symbol.hasInstance]() method to interfaces so that
instanceof will finally work for interfaces.

One limitation is that GObject ES6 classes can't have constructor()
methods, they must do any setup in an _init() method.

https://bugzilla.gnome.org/show_bug.cgi?id=785652
---
 Makefile-test.am                           |   2 +
 gi/interface.cpp                           |  36 ++-
 installed-tests/js/testGObjectClass.js     | 337 +++++++++++++++++++++++++++++
 installed-tests/js/testGObjectInterface.js | 266 +++++++++++++++++++++++
 modules/overrides/GObject.js               | 238 ++++++++++++++++++++
 5 files changed, 878 insertions(+), 1 deletion(-)
 create mode 100644 installed-tests/js/testGObjectClass.js
 create mode 100644 installed-tests/js/testGObjectInterface.js

diff --git a/Makefile-test.am b/Makefile-test.am
index c1503494..cf6d3eb3 100644
--- a/Makefile-test.am
+++ b/Makefile-test.am
@@ -227,6 +227,8 @@ common_jstests_files =						\
 	installed-tests/js/testGettext.js			\
 	installed-tests/js/testGIMarshalling.js			\
 	installed-tests/js/testGLib.js				\
+	installed-tests/js/testGObjectClass.js			\
+	installed-tests/js/testGObjectInterface.js		\
 	installed-tests/js/testGTypeClass.js			\
 	installed-tests/js/testGio.js				\
 	installed-tests/js/testImporter.js			\
diff --git a/gi/interface.cpp b/gi/interface.cpp
index d7e36543..62769e8b 100644
--- a/gi/interface.cpp
+++ b/gi/interface.cpp
@@ -27,6 +27,7 @@
 #include "function.h"
 #include "gtype.h"
 #include "interface.h"
+#include "object.h"
 #include "repo.h"
 #include "cjs/jsapi-class.h"
 #include "cjs/jsapi-wrapper.h"
@@ -157,6 +158,34 @@ interface_resolve(JSContext       *context,
     return true;
 }
 
+static bool
+interface_has_instance_func(JSContext *cx,
+                            unsigned   argc,
+                            JS::Value *vp)
+{
+    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
+    /* This method is not called directly, so no need for error messages */
+
+    JS::RootedValue interface(cx, args.computeThis(cx));
+    g_assert(interface.isObject());
+    JS::RootedObject interface_constructor(cx, &interface.toObject());
+    JS::RootedObject interface_proto(cx);
+    gjs_object_require_property(cx, interface_constructor,
+                                "interface constructor",
+                                GJS_STRING_PROTOTYPE, &interface_proto);
+
+    Interface *priv;
+    if (!priv_from_js_with_typecheck(cx, interface_proto, &priv))
+        return false;
+
+    g_assert(args.length() == 1);
+    g_assert(args[0].isObject());
+    JS::RootedObject instance(cx, &args[0].toObject());
+    bool isinstance = gjs_typecheck_object(cx, instance, priv->gtype, false);
+    args.rval().setBoolean(isinstance);
+    return true;
+}
+
 static const struct JSClassOps gjs_interface_class_ops = {
     NULL,  /* addProperty */
     NULL,  /* deleteProperty */
@@ -182,6 +211,11 @@ JSFunctionSpec gjs_interface_proto_funcs[] = {
     JS_FS_END
 };
 
+JSFunctionSpec gjs_interface_static_funcs[] = {
+    JS_SYM_FN(hasInstance, interface_has_instance_func, 1, 0),
+    JS_FS_END
+};
+
 bool
 gjs_define_interface_class(JSContext              *context,
                            JS::HandleObject        in_object,
@@ -208,7 +242,7 @@ gjs_define_interface_class(JSContext              *context,
                                 /* props of constructor, MyConstructor.myprop */
                                 NULL,
                                 /* funcs of constructor, MyConstructor.myfunc() */
-                                NULL,
+                                gjs_interface_static_funcs,
                                 &prototype,
                                 constructor)) {
         g_error("Can't init class %s", constructor_name);
diff --git a/installed-tests/js/testGObjectClass.js b/installed-tests/js/testGObjectClass.js
new file mode 100644
index 00000000..44f2bd3f
--- /dev/null
+++ b/installed-tests/js/testGObjectClass.js
@@ -0,0 +1,337 @@
+// -*- mode: js; indent-tabs-mode: nil -*-
+imports.gi.versions.Gtk = '3.0';
+
+const Gio = imports.gi.Gio;
+const GObject = imports.gi.GObject;
+const Gtk = imports.gi.Gtk;
+
+const MyObject = GObject.registerClass({
+    Properties: {
+        'readwrite': GObject.ParamSpec.string('readwrite', 'ParamReadwrite',
+            'A read write parameter', GObject.ParamFlags.READWRITE, ''),
+        'readonly': GObject.ParamSpec.string('readonly', 'ParamReadonly',
+            'A readonly parameter', GObject.ParamFlags.READABLE, ''),
+        'construct': GObject.ParamSpec.string('construct', 'ParamConstructOnly',
+            'A readwrite construct-only parameter',
+            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,
+            'default'),
+    },
+    Signals: {
+        'empty': {},
+        'minimal': { param_types: [ GObject.TYPE_INT, GObject.TYPE_INT ] },
+        'full': {
+            flags: GObject.SignalFlags.RUN_LAST,
+            accumulator: GObject.AccumulatorType.FIRST_WINS,
+            return_type: GObject.TYPE_INT,
+            param_types: [],
+        },
+        'run-last': { flags: GObject.SignalFlags.RUN_LAST },
+        'detailed': {
+            flags: GObject.SignalFlags.RUN_FIRST | GObject.SignalFlags.DETAILED,
+            param_types: [ GObject.TYPE_STRING ],
+        },
+    },
+}, class MyObject extends GObject.Object {
+    get readwrite() {
+        if (typeof this._readwrite === 'undefined')
+            return 'foo';
+        return this._readwrite;
+    }
+
+    set readwrite(val) {
+        if (val == 'ignore')
+            return;
+
+        this._readwrite = val;
+    }
+
+    get readonly() {
+        if (typeof this._readonly === 'undefined')
+            return 'bar';
+        return this._readonly;
+    }
+
+    set readonly(val) {
+        // this should never be called
+        void val;
+        this._readonly = 'bogus';
+    }
+
+    get construct() {
+        if (typeof this._constructProp === 'undefined')
+            return null;
+        return this._constructProp;
+    }
+
+    set construct(val) {
+        // this should be called at most once
+        if (this._constructCalled)
+            throw Error('Construct-Only property set more than once');
+
+        this._constructProp = val;
+        this._constructCalled = true;
+    }
+
+    notify_prop() {
+        this._readonly = 'changed';
+
+        this.notify('readonly');
+    }
+
+    emit_empty() {
+        this.emit('empty');
+    }
+
+    emit_minimal(one, two) {
+        this.emit('minimal', one, two);
+    }
+
+    emit_full() {
+        return this.emit('full');
+    }
+
+    emit_detailed() {
+        this.emit('detailed::one');
+        this.emit('detailed::two');
+    }
+
+    emit_run_last(callback) {
+        this._run_last_callback = callback;
+        this.emit('run-last');
+    }
+
+    on_run_last() {
+        this._run_last_callback();
+    }
+
+    on_empty() {
+        this.empty_called = true;
+    }
+
+    on_full() {
+        this.full_default_handler_called = true;
+        return 79;
+    }
+});
+
+const MyApplication = GObject.registerClass({
+    Signals: { 'custom': { param_types: [ GObject.TYPE_INT ] } },
+}, class MyApplication extends Gio.Application {
+    emit_custom(n) {
+        this.emit('custom', n);
+    }
+});
+
+const MyInitable = GObject.registerClass({
+    Implements: [ Gio.Initable ],
+}, class MyInitable extends GObject.Object {
+    vfunc_init(cancellable) {
+        if (!(cancellable instanceof Gio.Cancellable))
+            throw 'Bad argument';
+
+        this.inited = true;
+    }
+});
+
+const Derived = GObject.registerClass(class Derived extends MyObject {
+    _init() {
+        super._init({ readwrite: 'yes' });
+    }
+});
+
+const MyCustomInit = GObject.registerClass(class MyCustomInit extends GObject.Object {
+    _instance_init() {
+        this.foo = true;
+    }
+});
+
+describe('GObject class with decorator', function () {
+    let myInstance;
+    beforeEach(function () {
+        myInstance = new MyObject();
+    });
+
+    it('throws an error when not used with a GObject-derived class', function () {
+        class Foo {}
+        expect (() => GObject.registerClass(class Bar extends Foo {})).toThrow();
+    });
+
+    it('constructs with default values for properties', function () {
+        expect(myInstance.readwrite).toEqual('foo');
+        expect(myInstance.readonly).toEqual('bar');
+        expect(myInstance.construct).toEqual('default');
+    });
+
+    it('constructs with a hash of property values', function () {
+        let myInstance2 = new MyObject({ readwrite: 'baz', construct: 'asdf' });
+        expect(myInstance2.readwrite).toEqual('baz');
+        expect(myInstance2.readonly).toEqual('bar');
+        expect(myInstance2.construct).toEqual('asdf');
+    });
+
+    const ui = `<interface>
+                  <object class="Gjs_MyObject" id="MyObject">
+                    <property name="readwrite">baz</property>
+                    <property name="construct">quz</property>
+                  </object>
+                </interface>`;
+
+    it('constructs with property values from Gtk.Builder', function () {
+        let builder = Gtk.Builder.new_from_string(ui, -1);
+        let myInstance3 = builder.get_object('MyObject');
+        expect(myInstance3.readwrite).toEqual('baz');
+        expect(myInstance3.readonly).toEqual('bar');
+        expect(myInstance3.construct).toEqual('quz');
+    });
+
+    it('has a name', function () {
+        expect(MyObject.name).toEqual('MyObject');
+    });
+
+    // the following would (should) cause a CRITICAL:
+    // myInstance.readonly = 'val';
+    // myInstance.construct = 'val';
+
+    it('has a notify signal', function () {
+        let notifySpy = jasmine.createSpy('notifySpy');
+        myInstance.connect('notify::readonly', notifySpy);
+
+        myInstance.notify_prop();
+        myInstance.notify_prop();
+
+        expect(notifySpy).toHaveBeenCalledTimes(2);
+    });
+
+    it('can define its own signals', function () {
+        let emptySpy = jasmine.createSpy('emptySpy');
+        myInstance.connect('empty', emptySpy);
+        myInstance.emit_empty();
+
+        expect(emptySpy).toHaveBeenCalled();
+        expect(myInstance.empty_called).toBeTruthy();
+    });
+
+    it('passes emitted arguments to signal handlers', function () {
+        let minimalSpy = jasmine.createSpy('minimalSpy');
+        myInstance.connect('minimal', minimalSpy);
+        myInstance.emit_minimal(7, 5);
+
+        expect(minimalSpy).toHaveBeenCalledWith(myInstance, 7, 5);
+    });
+
+    it('can return values from signals', function () {
+        let fullSpy = jasmine.createSpy('fullSpy').and.returnValue(42);
+        myInstance.connect('full', fullSpy);
+        let result = myInstance.emit_full();
+
+        expect(fullSpy).toHaveBeenCalled();
+        expect(result).toEqual(42);
+    });
+
+    it('does not call first-wins signal handlers after one returns a value', function () {
+        let neverCalledSpy = jasmine.createSpy('neverCalledSpy');
+        myInstance.connect('full', () => 42);
+        myInstance.connect('full', neverCalledSpy);
+        myInstance.emit_full();
+
+        expect(neverCalledSpy).not.toHaveBeenCalled();
+        expect(myInstance.full_default_handler_called).toBeFalsy();
+    });
+
+    it('gets the return value of the default handler', function () {
+        let result = myInstance.emit_full();
+
+        expect(myInstance.full_default_handler_called).toBeTruthy();
+        expect(result).toEqual(79);
+    });
+
+    it('calls run-last default handler last', function () {
+        let stack = [ ];
+        let runLastSpy = jasmine.createSpy('runLastSpy')
+            .and.callFake(() => { stack.push(1); });
+        myInstance.connect('run-last', runLastSpy);
+        myInstance.emit_run_last(() => { stack.push(2); });
+
+        expect(stack).toEqual([1, 2]);
+    });
+
+    it("can inherit from something that's not GObject.Object", function () {
+        // ...and still get all the goodies of GObject.Class
+        let instance = new MyApplication({ application_id: 'org.gjs.Application' });
+        let customSpy = jasmine.createSpy('customSpy');
+        instance.connect('custom', customSpy);
+
+        instance.emit_custom(73);
+        expect(customSpy).toHaveBeenCalledWith(instance, 73);
+    });
+
+    it('can implement an interface', function () {
+        let instance = new MyInitable();
+        expect(instance instanceof Gio.Initable).toBeTruthy();
+        expect(instance instanceof Gio.AsyncInitable).toBeFalsy();
+
+        // Old syntax, backwards compatible
+        expect(instance.constructor.implements(Gio.Initable)).toBeTruthy();
+        expect(instance.constructor.implements(Gio.AsyncInitable)).toBeFalsy();
+    });
+
+    it('can implement interface vfuncs', function () {
+        let instance = new MyInitable();
+        expect(instance.inited).toBeFalsy();
+
+        instance.init(new Gio.Cancellable());
+        expect(instance.inited).toBeTruthy();
+    });
+
+    it('can be a subclass', function () {
+        let derived = new Derived();
+
+        expect(derived instanceof Derived).toBeTruthy();
+        expect(derived instanceof MyObject).toBeTruthy();
+
+        expect(derived.readwrite).toEqual('yes');
+    });
+
+    it('calls its _instance_init() function while chaining up in constructor', function () {
+        let instance = new MyCustomInit();
+        expect(instance.foo).toBeTruthy();
+    });
+
+    it('can have an interface-valued property', function () {
+        const InterfacePropObject = GObject.registerClass({
+            Properties: {
+                'file': GObject.ParamSpec.object('file', 'File', 'File',
+                    GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,
+                    Gio.File.$gtype)
+            },
+        }, class InterfacePropObject extends GObject.Object {});
+        let file = Gio.File.new_for_path('dummy');
+        expect(() => new InterfacePropObject({ file: file })).not.toThrow();
+    });
+
+    it('can override a property from the parent class', function () {
+        const OverrideObject = GObject.registerClass({
+            Properties: {
+                'readwrite': GObject.ParamSpec.override('readwrite', MyObject),
+            },
+        }, class OverrideObject extends MyObject {
+            get readwrite() {
+                return this._subclass_readwrite;
+            }
+            set readwrite(val) {
+                this._subclass_readwrite = 'subclass' + val;
+            }
+        });
+        let obj = new OverrideObject();
+        obj.readwrite = 'foo';
+        expect(obj.readwrite).toEqual('subclassfoo');
+    });
+
+    it('cannot override a non-existent property', function () {
+        expect(() => GObject.registerClass({
+            Properties: {
+                'nonexistent': GObject.ParamSpec.override('nonexistent', GObject.Object),
+            },
+        }, class BadOverride extends GObject.Object {})).toThrow();
+    });
+});
diff --git a/installed-tests/js/testGObjectInterface.js b/installed-tests/js/testGObjectInterface.js
new file mode 100644
index 00000000..9eab9746
--- /dev/null
+++ b/installed-tests/js/testGObjectInterface.js
@@ -0,0 +1,266 @@
+const Gio = imports.gi.Gio;
+const GLib = imports.gi.GLib;
+const GObject = imports.gi.GObject;
+const Mainloop = imports.mainloop;
+
+const AGObjectInterface = GObject.registerClass({
+    GTypeName: 'ArbitraryGTypeName',
+    Requires: [ GObject.Object ],
+    Properties: {
+        'interface-prop': GObject.ParamSpec.string('interface-prop',
+            'Interface property', 'Must be overridden in implementation',
+            GObject.ParamFlags.READABLE,
+            'foobar')
+    },
+    Signals: {
+        'interface-signal': {}
+    },
+}, class AGObjectInterface extends GObject.Interface {
+    requiredG() {
+        throw new GObject.NotImplementedError();
+    }
+
+    optionalG() {
+        return 'AGObjectInterface.optionalG()';
+    }
+});
+
+const InterfaceRequiringGObjectInterface = GObject.registerClass({
+    Requires: [ AGObjectInterface ],
+}, class InterfaceRequiringGObjectInterface extends GObject.Interface {
+    optionalG() {
+        return 'InterfaceRequiringGObjectInterface.optionalG()\n' +
+            AGObjectInterface.optionalG(this);
+    }
+});
+
+const GObjectImplementingGObjectInterface = GObject.registerClass({
+    Implements: [ AGObjectInterface ],
+    Properties: {
+        'interface-prop': GObject.ParamSpec.override('interface-prop',
+            AGObjectInterface),
+        'class-prop': GObject.ParamSpec.string('class-prop', 'Class property',
+            'A property that is not on the interface',
+            GObject.ParamFlags.READABLE, 'meh')
+    },
+    Signals: {
+        'class-signal': {},
+    },
+}, class GObjectImplementingGObjectInterface extends GObject.Object {
+    get interface_prop() {
+        return 'foobar';
+    }
+
+    get class_prop() {
+        return 'meh';
+    }
+
+    requiredG() {}
+    optionalG() {
+        return AGObjectInterface.optionalG(this);
+    }
+});
+
+const MinimalImplementationOfAGObjectInterface = GObject.registerClass({
+    Implements: [ AGObjectInterface ],
+    Properties: {
+        'interface-prop': GObject.ParamSpec.override('interface-prop',
+            AGObjectInterface)
+    },
+}, class MinimalImplementationOfAGObjectInterface extends GObject.Object {
+    requiredG() {}
+});
+
+const ImplementationOfTwoInterfaces = GObject.registerClass({
+    Implements: [ AGObjectInterface, InterfaceRequiringGObjectInterface ],
+    Properties: {
+        'interface-prop': GObject.ParamSpec.override('interface-prop',
+            AGObjectInterface)
+    },
+}, class ImplementationOfTwoInterfaces extends GObject.Object {
+    requiredG() {}
+    optionalG() {
+        return InterfaceRequiringGObjectInterface.optionalG(this);
+    }
+});
+
+describe('GObject interface', function () {
+    it('cannot be instantiated', function () {
+        expect(() => new AGObjectInterface()).toThrow();
+    });
+
+    it('has a name', function () {
+        expect(AGObjectInterface.name).toEqual('AGObjectInterface');
+    });
+
+    it('reports its type name', function () {
+        expect(AGObjectInterface.$gtype.name).toEqual('ArbitraryGTypeName');
+    });
+
+    it('can be implemented by a GObject class', function () {
+        let obj;
+        expect(() => { obj = new GObjectImplementingGObjectInterface(); })
+            .not.toThrow();
+        expect(obj instanceof AGObjectInterface).toBeTruthy();
+    });
+
+    it('is implemented by a GObject class with the correct class object', function () {
+        let obj = new GObjectImplementingGObjectInterface();
+        expect(obj.constructor).toBe(GObjectImplementingGObjectInterface);
+        expect(obj.constructor.name)
+            .toEqual('GObjectImplementingGObjectInterface');
+    });
+
+    it('can have its required function implemented', function () {
+        expect(() => {
+            let obj = new GObjectImplementingGObjectInterface();
+            obj.requiredG();
+        }).not.toThrow();
+    });
+
+    it('must have its required function implemented', function () {
+        const BadObject = GObject.registerClass({
+            Implements: [ AGObjectInterface ],
+            Properties: {
+                'interface-prop': GObject.ParamSpec.override('interface-prop',
+                    AGObjectInterface)
+            }
+        }, class BadObject extends GObject.Object {});
+        expect(() => new BadObject().requiredG())
+           .toThrowError(GObject.NotImplementedError);
+    });
+
+    it("doesn't have to have its optional function implemented", function () {
+        let obj;
+        expect(() => { obj = new MinimalImplementationOfAGObjectInterface(); })
+            .not.toThrow();
+        expect(obj instanceof AGObjectInterface).toBeTruthy();
+    });
+
+    it('can have its optional function deferred to by the implementation', function () {
+        let obj = new MinimalImplementationOfAGObjectInterface();
+        expect(obj.optionalG()).toEqual('AGObjectInterface.optionalG()');
+    });
+
+    it('can have its function chained up to', function () {
+        let obj = new GObjectImplementingGObjectInterface();
+        expect(obj.optionalG()).toEqual('AGObjectInterface.optionalG()');
+    });
+
+    it('can require another interface', function () {
+        let obj;
+        expect(() => { obj = new ImplementationOfTwoInterfaces(); }).not.toThrow();
+        expect(obj instanceof AGObjectInterface).toBeTruthy();
+        expect(obj instanceof InterfaceRequiringGObjectInterface).toBeTruthy();
+    });
+
+    it('can chain up to another interface', function () {
+        let obj = new ImplementationOfTwoInterfaces();
+        expect(obj.optionalG())
+            .toEqual('InterfaceRequiringGObjectInterface.optionalG()\nAGObjectInterface.optionalG()');
+    });
+
+    it("defers to the last interface's optional function", function () {
+        const MinimalImplementationOfTwoInterfaces = GObject.registerClass({
+            Implements: [ AGObjectInterface, InterfaceRequiringGObjectInterface ],
+            Properties: {
+                'interface-prop': GObject.ParamSpec.override('interface-prop',
+                    AGObjectInterface)
+            },
+        }, class MinimalImplementationOfTwoInterfaces extends GObject.Object {
+            requiredG() {}
+        });
+        let obj = new MinimalImplementationOfTwoInterfaces();
+        expect(obj.optionalG())
+            .toEqual('InterfaceRequiringGObjectInterface.optionalG()\nAGObjectInterface.optionalG()');
+    });
+
+    it('must be implemented by a class that implements all required interfaces', function () {
+        expect(() => GObject.registerClass({
+            Implements: [ InterfaceRequiringGObjectInterface ],
+        }, class BadObject {
+            required() {}
+        })).toThrow();
+    });
+
+    it('must be implemented by a class that implements required interfaces in correct order', function () {
+        expect(() => GObject.registerClass({
+            Implements: [ InterfaceRequiringGObjectInterface, AGObjectInterface ],
+        }, class BadObject {
+            required() {}
+        })).toThrow();
+    });
+
+    it('can require an interface from C', function () {
+        const InitableInterface = GObject.registerClass({
+            Requires: [ GObject.Object, Gio.Initable ]
+        }, class InitableInterface extends GObject.Interface {});
+        expect(() => GObject.registerClass({
+            Implements: [ InitableInterface ],
+        }, class BadObject {})).toThrow();
+    });
+
+    it('can define signals on the implementing class', function () {
+        function quitLoop() {
+            Mainloop.quit('signal');
+        }
+        let obj = new GObjectImplementingGObjectInterface();
+        let interfaceSignalSpy = jasmine.createSpy('interfaceSignalSpy')
+            .and.callFake(quitLoop);
+        let classSignalSpy = jasmine.createSpy('classSignalSpy')
+            .and.callFake(quitLoop);
+        obj.connect('interface-signal', interfaceSignalSpy);
+        obj.connect('class-signal', classSignalSpy);
+        GLib.idle_add(GLib.PRIORITY_DEFAULT, () => {
+            obj.emit('interface-signal');
+            return GLib.SOURCE_REMOVE;
+        });
+        Mainloop.run('signal');
+        GLib.idle_add(GLib.PRIORITY_DEFAULT, () => {
+            obj.emit('class-signal');
+            return GLib.SOURCE_REMOVE;
+        });
+        Mainloop.run('signal');
+        expect(interfaceSignalSpy).toHaveBeenCalled();
+        expect(classSignalSpy).toHaveBeenCalled();
+    });
+
+    it('can define properties on the implementing class', function () {
+        let obj = new GObjectImplementingGObjectInterface();
+        expect(obj.interface_prop).toEqual('foobar');
+        expect(obj.class_prop).toEqual('meh');
+    });
+
+    it('must have its properties overridden', function () {
+        // Failing to override an interface property doesn't raise an error but
+        // instead logs a critical warning.
+        GLib.test_expect_message('GLib-GObject', GLib.LogLevelFlags.LEVEL_CRITICAL,
+            "Object class * doesn't implement property 'interface-prop' from " +
+            "interface 'ArbitraryGTypeName'");
+        GObject.registerClass({
+            Implements: [ AGObjectInterface ],
+        }, class MyNaughtyObject extends GObject.Object {
+            requiredG() {}
+        });
+        // g_test_assert_expected_messages() is a macro, not introspectable
+        GLib.test_assert_expected_messages_internal('Gjs', 'testGObjectInterface.js',
+            253, 'testGObjectMustOverrideInterfaceProperties');
+    });
+
+    it('can be implemented by a class as well as its parent class', function () {
+        const SubObject = GObject.registerClass(
+            class SubObject extends GObjectImplementingGObjectInterface {});
+        let obj = new SubObject();
+        expect(obj instanceof AGObjectInterface).toBeTruthy();
+        expect(obj.interface_prop).toEqual('foobar');  // override not needed
+    });
+
+    it('can be reimplemented by a subclass of a class that already implements it', function () {
+        const SubImplementer = GObject.registerClass({
+            Implements: [ AGObjectInterface ],
+        }, class SubImplementer extends GObjectImplementingGObjectInterface {});
+        let obj = new SubImplementer();
+        expect(obj instanceof AGObjectInterface).toBeTruthy();
+        expect(obj.interface_prop).toEqual('foobar');  // override not needed
+    });
+});
diff --git a/modules/overrides/GObject.js b/modules/overrides/GObject.js
index a99b3f2c..7643fc34 100644
--- a/modules/overrides/GObject.js
+++ b/modules/overrides/GObject.js
@@ -1,4 +1,6 @@
+/* exported _init, interfaces, properties, registerClass, requires, signals */
 // Copyright 2011 Jasper St. Pierre
+// Copyright 2017 Philip Chimento <philip.chimento@gmail.com>, <philip@endlessm.com>
 //
 // Permission is hereby granted, free of charge, to any person obtaining a copy
 // of this software and associated documentation files (the "Software"), to
@@ -24,6 +26,136 @@ const Legacy = imports._legacy;
 
 let GObject;
 
+var GTypeName = Symbol('GType name');
+var interfaces = Symbol('GObject interfaces');
+var properties = Symbol('GObject properties');
+var requires = Symbol('GObject interface requires');
+var signals = Symbol('GObject signals');
+
+function registerClass(klass) {
+    if (arguments.length == 2) {
+        // The two-argument form is the convenient syntax without ESnext
+        // decorators and class data properties. The first argument is an
+        // object with meta info such as properties and signals. The second
+        // argument is the class expression for the class itself.
+        //
+        //     var MyClass = GObject.registerClass({
+        //         Properties: { ... },
+        //         Signals: { ... },
+        //     }, class MyClass extends GObject.Object {
+        //         _init() { ... }
+        //     });
+        //
+        // When decorators and class data properties become part of the JS
+        // standard, this function can be used directly as a decorator.
+        let metaInfo = arguments[0];
+        klass = arguments[1];
+        if ('GTypeName' in metaInfo)
+            klass[GTypeName] = metaInfo.GTypeName;
+        if ('Implements' in metaInfo)
+            klass[interfaces] = metaInfo.Implements;
+        if ('Properties' in metaInfo)
+            klass[properties] = metaInfo.Properties;
+        if ('Signals' in metaInfo)
+            klass[signals] = metaInfo.Signals;
+        if ('Requires' in metaInfo)
+            klass[requires] = metaInfo.Requires;
+    }
+
+    if (!(klass.prototype instanceof GObject.Object) &&
+        !(klass.prototype instanceof GObject.Interface))
+        throw new TypeError('GObject.registerClass() used with invalid base ' +
+            `class (is ${Object.getPrototypeOf(klass).name})`);
+
+    // Find the "least derived" class with a _classInit static function; there
+    // definitely is one, since this class must inherit from GObject
+    let initclass = klass;
+    while (typeof initclass._classInit === 'undefined')
+        initclass = Object.getPrototypeOf(initclass.prototype).constructor;
+    return initclass._classInit(klass);
+}
+
+// Some common functions between GObject.Class and GObject.Interface
+
+function _createSignals(gtype, signals) {
+    for (let signalName in signals) {
+        let obj = signals[signalName];
+        let flags = (obj.flags !== undefined) ? obj.flags : GObject.SignalFlags.RUN_FIRST;
+        let accumulator = (obj.accumulator !== undefined) ? obj.accumulator : GObject.AccumulatorType.NONE;
+        let rtype = (obj.return_type !== undefined) ? obj.return_type : GObject.TYPE_NONE;
+        let paramtypes = (obj.param_types !== undefined) ? obj.param_types : [];
+
+        try {
+            obj.signal_id = Gi.signal_new(gtype, signalName, flags, accumulator, rtype, paramtypes);
+        } catch (e) {
+            throw new TypeError('Invalid signal ' + signalName + ': ' + e.message);
+        }
+    }
+}
+
+function _createGTypeName(klass) {
+    if (klass.hasOwnProperty(GTypeName))
+        return klass[GTypeName];
+    return `Gjs_${klass.name}`;
+}
+
+function _propertiesAsArray(klass) {
+    let propertiesArray = [];
+    if (klass.hasOwnProperty(properties)) {
+        for (let prop in klass[properties]) {
+            propertiesArray.push(klass[properties][prop]);
+        }
+    }
+    return propertiesArray;
+}
+
+function _copyAllDescriptors(target, source) {
+    Object.getOwnPropertyNames(source)
+    .filter(key => !['prototype', 'constructor'].includes(key))
+    .concat(Object.getOwnPropertySymbols(source))
+    .forEach(key => {
+        let descriptor = Object.getOwnPropertyDescriptor(source, key);
+        Object.defineProperty(target, key, descriptor);
+    });
+}
+
+function _interfacePresent(required, klass) {
+    if (!klass[interfaces])
+        return false;
+    if (klass[interfaces].includes(required))
+        return true;  // implemented here
+    // Might be implemented on a parent class
+    return _interfacePresent(required, Object.getPrototypeOf(klass));
+}
+
+function _checkInterface(iface, proto) {
+    // Check that proto implements all of this interface's required interfaces.
+    // "proto" refers to the object's prototype (which implements the interface)
+    // whereas "iface.prototype" is the interface's prototype (which may still
+    // contain unimplemented methods.)
+    if (typeof iface[requires] === 'undefined')
+        return;
+
+    let unfulfilledReqs = iface[requires].filter(required => {
+        // Either the interface is not present or it is not listed before the
+        // interface that requires it or the class does not inherit it. This is
+        // so that required interfaces don't copy over properties from other
+        // interfaces that require them.
+        let ifaces = proto.constructor[interfaces];
+        return ((!_interfacePresent(required, proto.constructor) ||
+            ifaces.indexOf(required) > ifaces.indexOf(iface)) &&
+            !(proto instanceof required));
+    }).map(required =>
+        // required.name will be present on JS classes, but on introspected
+        // GObjects it will be the C name. The alternative is just so that
+        // we print something if there is garbage in Requires.
+        required.name || required);
+    if (unfulfilledReqs.length > 0) {
+        throw new Error('The following interfaces must be implemented before ' +
+            `${iface.name}: ${unfulfilledReqs.join(', ')}`);
+    }
+}
+
 function _init() {
 
     GObject = this;
@@ -184,6 +316,112 @@ function _init() {
         return this;
     };
 
+    GObject.registerClass = registerClass;
+
+    GObject.Object._classInit = function(klass) {
+        let gtypename = _createGTypeName(klass);
+        let gobjectInterfaces = klass.hasOwnProperty(interfaces) ?
+            klass[interfaces] : [];
+        let propertiesArray = _propertiesAsArray(klass);
+        let parent = Object.getPrototypeOf(klass);
+        let gobjectSignals = klass.hasOwnProperty(signals) ?
+            klass[signals] : [];
+
+        let newClass = Gi.register_type(parent.prototype, gtypename,
+            gobjectInterfaces, propertiesArray);
+        Object.setPrototypeOf(newClass, parent);
+
+        _createSignals(newClass.$gtype, gobjectSignals);
+
+        _copyAllDescriptors(newClass, klass);
+        gobjectInterfaces.forEach(iface =>
+            _copyAllDescriptors(newClass.prototype, iface.prototype));
+        _copyAllDescriptors(newClass.prototype, klass.prototype);
+
+        Object.getOwnPropertyNames(newClass.prototype)
+        .filter(name => name.startsWith('vfunc_') || name.startsWith('on_'))
+        .forEach(name => {
+            let descr = Object.getOwnPropertyDescriptor(newClass.prototype, name);
+            if (typeof descr.value !== 'function')
+                return;
+
+            let func = newClass.prototype[name];
+
+            if (name.startsWith('vfunc_')) {
+                Gi.hook_up_vfunc(newClass.prototype, name.slice(6), func);
+            } else if (name.startsWith('on_')) {
+                let id = GObject.signal_lookup(name.slice(3).replace('_', '-'),
+                    newClass.$gtype);
+                if (id !== 0) {
+                    GObject.signal_override_class_closure(id, newClass.$gtype, function() {
+                        let argArray = Array.from(arguments);
+                        let emitter = argArray.shift();
+
+                        return func.apply(emitter, argArray);
+                    });
+                }
+            }
+        });
+
+        gobjectInterfaces.forEach(iface =>
+            _checkInterface(iface, newClass.prototype));
+
+        // For backwards compatibility only. Use instanceof instead.
+        newClass.implements = function(iface) {
+            if (iface.$gtype)
+                return GObject.type_is_a(newClass.$gtype, iface.$gtype);
+            return false;
+        }
+
+        return newClass;
+    };
+
+    GObject.Interface._classInit = function(klass) {
+        let gtypename = _createGTypeName(klass);
+        let gobjectInterfaces = klass.hasOwnProperty(requires) ?
+            klass[requires] : [];
+        let properties = _propertiesAsArray(klass);
+        let gobjectSignals = klass.hasOwnProperty(signals) ?
+            klass[signals] : [];
+
+        let newInterface = Gi.register_interface(gtypename, gobjectInterfaces,
+            properties);
+
+        _createSignals(newInterface.$gtype, gobjectSignals);
+
+        _copyAllDescriptors(newInterface, klass);
+
+        Object.getOwnPropertyNames(klass.prototype)
+        .filter(key => key !== 'constructor')
+        .concat(Object.getOwnPropertySymbols(klass.prototype))
+        .forEach(key => {
+            let descr = Object.getOwnPropertyDescriptor(klass.prototype, key);
+
+            // Create wrappers on the interface object so that generics work (e.g.
+            // SomeInterface.some_function(this, blah) instead of
+            // SomeInterface.prototype.some_function.call(this, blah)
+            if (typeof descr.value === 'function') {
+                let interfaceProto = klass.prototype;  // capture in closure
+                newInterface[key] = function () {
+                    return interfaceProto[key].call.apply(interfaceProto[key],
+                        arguments);
+                };
+            }
+
+            Object.defineProperty(newInterface.prototype, key, descr);
+        });
+
+        return newInterface;
+    };
+
+    /**
+     * Use this to signify a function that must be overridden in an
+     * implementation of the interface.
+     */
+    GObject.NotImplementedError = class NotImplementedError extends Error {
+        get name() { return 'NotImplementedError'; }
+    };
+
     // fake enum for signal accumulators, keep in sync with gi/object.c
     this.AccumulatorType = {
         NONE: 0,

From cf314d8395310b983c15f6e42d6001f9a5eaa746 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Thu, 3 Aug 2017 02:43:46 +0100
Subject: [PATCH 094/154] class: Move to ES6 GObject classes in internal code

This moves all remaining uses of Lang.Class (except for where the legacy
class framework is explicitly tested) from the codebase, in favour of
GObject.registerClass().

https://bugzilla.gnome.org/show_bug.cgi?id=785652
---
 installed-tests/js/testExceptions.js    | 15 +++------
 installed-tests/js/testGIMarshalling.js | 54 ++++++++-------------------------
 installed-tests/js/testGio.js           |  9 ++----
 test/gjs-tests.cpp                      |  7 +----
 4 files changed, 22 insertions(+), 63 deletions(-)

diff --git a/installed-tests/js/testExceptions.js b/installed-tests/js/testExceptions.js
index 595682ee..5c5e05f3 100644
--- a/installed-tests/js/testExceptions.js
+++ b/installed-tests/js/testExceptions.js
@@ -1,32 +1,27 @@
 const Gio = imports.gi.Gio;
 const GLib = imports.gi.GLib;
 const GObject = imports.gi.GObject;
-const Lang = imports.lang;
 
-const Foo = new Lang.Class({
-    Name: 'Foo',
-    Extends: GObject.Object,
+const Foo = GObject.registerClass({
     Properties: {
         'prop': GObject.ParamSpec.string('prop', '', '', GObject.ParamFlags.READWRITE, '')
     },
-
+}, class Foo extends GObject.Object {
     set prop(v) {
 	throw new Error('set');
-    },
+    }
 
     get prop() {
 	throw new Error('get');
     }
 });
 
-const Bar = new Lang.Class({
-    Name: 'Bar',
-    Extends: GObject.Object,
+const Bar = GObject.registerClass({
     Properties: {
         'prop': GObject.ParamSpec.string('prop', '', '',
             GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT, ''),
     }
-});
+}, class Bar extends GObject.Object {});
 
 describe('Exceptions', function () {
     it('are thrown from property setter', function () {
diff --git a/installed-tests/js/testGIMarshalling.js b/installed-tests/js/testGIMarshalling.js
index bf144d9e..4a7d4380 100644
--- a/installed-tests/js/testGIMarshalling.js
+++ b/installed-tests/js/testGIMarshalling.js
@@ -5,7 +5,6 @@ const GIMarshallingTests = imports.gi.GIMarshallingTests;
 const Gio = imports.gi.Gio;
 const GLib = imports.gi.GLib;
 const GObject = imports.gi.GObject;
-const Lang = imports.lang;
 
 describe('C array', function () {
     function createStructArray() {
@@ -536,72 +535,45 @@ describe('GType', function () {
     });
 });
 
-function callback_return_value_only() {
-    return 42;
-}
-
-function callback_one_out_parameter() {
-    return 43;
-}
-
-function callback_multiple_out_parameters() {
-    return [44, 45];
-}
-
-function callback_return_value_and_one_out_parameter() {
-    return [46, 47];
-}
-
-function callback_return_value_and_multiple_out_parameters() {
-    return [48, 49, 50];
-}
-
-function callback_array_out_parameter() {
-    return [50, 51];
-}
-
 describe('Callback', function () {
     it('marshals a return value', function () {
-        expect(GIMarshallingTests.callback_return_value_only(callback_return_value_only))
+        expect(GIMarshallingTests.callback_return_value_only(() => 42))
             .toEqual(42);
     });
 
     it('marshals one out parameter', function () {
-        expect(GIMarshallingTests.callback_one_out_parameter(callback_one_out_parameter))
+        expect(GIMarshallingTests.callback_one_out_parameter(() => 43))
             .toEqual(43);
     });
 
     it('marshals multiple out parameters', function () {
-        expect(GIMarshallingTests.callback_multiple_out_parameters(callback_multiple_out_parameters))
+        expect(GIMarshallingTests.callback_multiple_out_parameters(() => [44, 45]))
             .toEqual([44, 45]);
     });
 
     it('marshals a return value and one out parameter', function () {
-        expect(GIMarshallingTests.callback_return_value_and_one_out_parameter(callback_return_value_and_one_out_parameter))
+        expect(GIMarshallingTests.callback_return_value_and_one_out_parameter(() => [46, 47]))
             .toEqual([46, 47]);
     });
 
     it('marshals a return value and multiple out parameters', function () {
-        expect(GIMarshallingTests.callback_return_value_and_multiple_out_parameters(callback_return_value_and_multiple_out_parameters))
+        expect(GIMarshallingTests.callback_return_value_and_multiple_out_parameters(() => [48, 49, 50]))
             .toEqual([48, 49, 50]);
     });
 
     xit('marshals an array out parameter', function () {
-        expect(GIMarshallingTests.callback_array_out_parameter(callback_array_out_parameter))
+        expect(GIMarshallingTests.callback_array_out_parameter(() => [50, 51]))
             .toEqual([50, 51]);
     }).pend('Function not added to gobject-introspection test suite yet');
 });
 
-const VFuncTester = new Lang.Class({
-    Name: 'VFuncTester',
-    Extends: GIMarshallingTests.Object,
-
-    vfunc_vfunc_return_value_only: callback_return_value_only,
-    vfunc_vfunc_one_out_parameter: callback_one_out_parameter,
-    vfunc_vfunc_multiple_out_parameters: callback_multiple_out_parameters,
-    vfunc_vfunc_return_value_and_one_out_parameter: callback_return_value_and_one_out_parameter,
-    vfunc_vfunc_return_value_and_multiple_out_parameters: callback_return_value_and_multiple_out_parameters,
-    vfunc_vfunc_array_out_parameter: callback_array_out_parameter,
+const VFuncTester = GObject.registerClass(class VFuncTester extends GIMarshallingTests.Object {
+    vfunc_vfunc_return_value_only() { return 42; }
+    vfunc_vfunc_one_out_parameter() { return 43; }
+    vfunc_vfunc_multiple_out_parameters() { return [44, 45]; }
+    vfunc_vfunc_return_value_and_one_out_parameter() { return [46, 47]; }
+    vfunc_vfunc_return_value_and_multiple_out_parameters() { return [48, 49, 50]; }
+    vfunc_vfunc_array_out_parameter() { return [50, 51]; }
 });
 
 describe('Virtual function', function () {
diff --git a/installed-tests/js/testGio.js b/installed-tests/js/testGio.js
index 107221dc..7feeb79c 100644
--- a/installed-tests/js/testGio.js
+++ b/installed-tests/js/testGio.js
@@ -1,12 +1,9 @@
 const Gio = imports.gi.Gio;
 const GObject = imports.gi.GObject;
-const Lang = imports.lang;
 
-const Foo = new Lang.Class({
-    Name: 'Foo',
-    Extends: GObject.Object,
-    _init: function (value) {
-        this.parent();
+const Foo = GObject.registerClass(class Foo extends GObject.Object {
+    _init(value) {
+        super._init();
         this.value = value;
     }
 });
diff --git a/test/gjs-tests.cpp b/test/gjs-tests.cpp
index 7d971055..e45f8e7a 100644
--- a/test/gjs-tests.cpp
+++ b/test/gjs-tests.cpp
@@ -91,13 +91,8 @@ gjstest_test_func_gjs_context_exit(void)
 }
 
 #define JS_CLASS "\
-const Lang    = imports.lang; \
 const GObject = imports.gi.GObject; \
-\
-const FooBar = new Lang.Class({ \
-    Name: 'FooBar', \
-    Extends: GObject.Object, \
-}); \
+const FooBar = GObject.registerClass(class FooBar extends GObject.Object {}); \
 "
 
 static void

From 59972b872a1dbe8b5b3e5cf063c0e09eff1b402a Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sun, 23 Jul 2017 19:24:25 -0700
Subject: [PATCH 095/154] tests: Add ES6 class inheriting from legacy class

This should be supported, so add tests for it.

https://bugzilla.gnome.org/show_bug.cgi?id=785652
---
 installed-tests/js/testLegacyClass.js   |  68 +++++++++++++++++
 installed-tests/js/testLegacyGObject.js | 127 ++++++++++++++++++++++++++++++++
 2 files changed, 195 insertions(+)

diff --git a/installed-tests/js/testLegacyClass.js b/installed-tests/js/testLegacyClass.js
index 178c2d48..5675796a 100644
--- a/installed-tests/js/testLegacyClass.js
+++ b/installed-tests/js/testLegacyClass.js
@@ -652,3 +652,71 @@ describe('An interface', function () {
         expect(AnInterface.toString()).toEqual('[interface Interface for AnInterface]');
     });
 });
+
+describe('ES6 class inheriting from Lang.Class', function () {
+    let Shiny, Legacy;
+
+    beforeEach(function () {
+        Legacy = new Lang.Class({
+            Name: 'Legacy',
+            _init(someval) {
+                this.constructorCalledWith = someval;
+            },
+
+            instanceMethod() {},
+            chainUpToMe() {},
+            overrideMe() {},
+
+            get property() { return this._property + 1; },
+            set property(value) { this._property = value - 2; },
+        });
+        Legacy.staticMethod = function () {};
+        spyOn(Legacy, 'staticMethod');
+        spyOn(Legacy.prototype, 'instanceMethod');
+        spyOn(Legacy.prototype, 'chainUpToMe');
+        spyOn(Legacy.prototype, 'overrideMe');
+
+        Shiny = class Shiny extends Legacy {
+            constructor(someval) {
+                super(someval);
+            }
+
+            chainUpToMe() { super.chainUpToMe(); }
+            overrideMe() {}
+        };
+    });
+
+    it('calls a static method on the parent class', function () {
+        Shiny.staticMethod();
+        expect(Legacy.staticMethod).toHaveBeenCalled();
+    });
+
+    it('calls a method on the parent class', function () {
+        let instance = new Shiny();
+        instance.instanceMethod();
+        expect(Legacy.prototype.instanceMethod).toHaveBeenCalled();
+    });
+
+    it("passes arguments to the parent class's constructor", function () {
+        let instance = new Shiny(42);
+        expect(instance.constructorCalledWith).toEqual(42);
+    });
+
+    it('chains up to a method on the parent class', function () {
+        let instance = new Shiny();
+        instance.chainUpToMe();
+        expect(Legacy.prototype.chainUpToMe).toHaveBeenCalled();
+    });
+
+    it('overrides a method on the parent class', function () {
+        let instance = new Shiny();
+        instance.overrideMe();
+        expect(Legacy.prototype.overrideMe).not.toHaveBeenCalled();
+    });
+
+    it('sets and gets a property from the parent class', function () {
+        let instance = new Shiny();
+        instance.property = 42;
+        expect(instance.property).toEqual(41);
+    });
+});
diff --git a/installed-tests/js/testLegacyGObject.js b/installed-tests/js/testLegacyGObject.js
index 56ba1b78..f79e63e1 100644
--- a/installed-tests/js/testLegacyGObject.js
+++ b/installed-tests/js/testLegacyGObject.js
@@ -843,3 +843,130 @@ describe('Legacy Gtk overrides', function () {
         expect(Gtk.Widget.get_css_name.call(MyComplexGtkSubclass)).toEqual('complex-subclass');
     });
 });
+
+const LegacyInterface1 = new Lang.Interface({
+    Name: 'LegacyInterface1',
+    Requires: [GObject.Object],
+    Signals: { 'legacy-iface1-signal': {} },
+});
+
+const LegacyInterface2 = new Lang.Interface({
+    Name: 'LegacyInterface2',
+    Requires: [GObject.Object],
+    Signals: { 'legacy-iface2-signal': {} },
+});
+
+const Legacy = new Lang.Class({
+    Name: 'Legacy',
+    Extends: GObject.Object,
+    Implements: [LegacyInterface1],
+    Properties: {
+        'property': GObject.ParamSpec.int('property', 'Property',
+            'A magic property', GObject.ParamFlags.READWRITE, 0, 100, 0),
+        'override-property': GObject.ParamSpec.int('override-property',
+            'Override property', 'Another magic property',
+            GObject.ParamFlags.READWRITE, 0, 100, 0),
+    },
+    Signals: {
+        'signal': {},
+    },
+
+    _init(someval) {
+        this.constructorCalledWith = someval;
+        this.parent();
+    },
+
+    instanceMethod() {},
+    chainUpToMe() {},
+    overrideMe() {},
+
+    get property() { return this._property + 1; },
+    set property(value) { this._property = value - 2; },
+
+    get override_property() { return this._override_property + 1; },
+    set override_property(value) { this._override_property = value - 2; },
+});
+Legacy.staticMethod = function () {};
+
+const Shiny = GObject.registerClass({
+    Implements: [LegacyInterface2],
+    Properties: {
+        'override-property': GObject.ParamSpec.override('override-property',
+            Legacy),
+    },
+}, class Shiny extends Legacy {
+    chainUpToMe() {
+        super.chainUpToMe();
+    }
+
+    overrideMe() {}
+
+    get override_property() { return this._override_property + 2; }
+    set override_property(value) { this._override_property = value - 1; }
+});
+
+fdescribe('ES6 GObject class inheriting from GObject.Class', function () {
+    let instance;
+
+    beforeEach(function () {
+        spyOn(Legacy, 'staticMethod');
+        spyOn(Legacy.prototype, 'instanceMethod');
+        spyOn(Legacy.prototype, 'chainUpToMe');
+        spyOn(Legacy.prototype, 'overrideMe');
+        instance = new Shiny();
+    });
+
+    it('calls a static method on the parent class', function () {
+        Shiny.staticMethod();
+        expect(Legacy.staticMethod).toHaveBeenCalled();
+    });
+
+    it('calls a method on the parent class', function () {
+        instance.instanceMethod();
+        expect(Legacy.prototype.instanceMethod).toHaveBeenCalled();
+    });
+
+    it("passes arguments to the parent class's constructor", function () {
+        let instance = new Shiny(42);
+        expect(instance.constructorCalledWith).toEqual(42);
+    });
+
+    it('chains up to a method on the parent class', function () {
+        instance.chainUpToMe();
+        expect(Legacy.prototype.chainUpToMe).toHaveBeenCalled();
+    });
+
+    it('overrides a method on the parent class', function () {
+        instance.overrideMe();
+        expect(Legacy.prototype.overrideMe).not.toHaveBeenCalled();
+    });
+
+    it('sets and gets a property from the parent class', function () {
+        instance.property = 42;
+        expect(instance.property).toEqual(41);
+    });
+
+    it('overrides a property from the parent class', function () {
+        instance.override_property = 42;
+        expect(instance.override_property).toEqual(43);
+    });
+
+    it('inherits a signal from the parent class', function () {
+        let signalSpy = jasmine.createSpy('signalSpy');
+        expect(() => {
+            instance.connect('signal', signalSpy);
+            instance.emit('signal');
+        }).not.toThrow();
+        expect(signalSpy).toHaveBeenCalled();
+    });
+
+    it('inherits legacy interfaces from the parent', function () {
+        expect(() => instance.emit('legacy-iface1-signal')).not.toThrow();
+        expect(instance instanceof LegacyInterface1).toBeTruthy();
+    });
+
+    it('can implement a legacy interface itself', function () {
+        expect(() => instance.emit('legacy-iface2-signal')).not.toThrow();
+        expect(instance instanceof LegacyInterface2).toBeTruthy();
+    });
+});

From e2a994af137ad4002756e04fe7087dbecf38bd4d Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Tue, 8 Aug 2017 01:00:28 +0200
Subject: [PATCH 096/154] build: Fix distcheck

A deleted docs file was still left in the Makefile. At the same time, add
Hacking.md to the makefile so that it is distributed.

Unreviewed.
---
 Makefile.am | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Makefile.am b/Makefile.am
index 7fe4363a..9904fc80 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -157,7 +157,7 @@ EXTRA_DIST +=					\
 	COPYING.LGPL				\
 	doc/ByteArray.md			\
 	doc/cairo.md				\
-	doc/Class_Framework.md			\
+	doc/Hacking.md				\
 	doc/SpiderMonkey_Memory.md		\
 	doc/Style_Guide.md			\
 	win32/build-rules-msvc.mak		\

From e63591b9c8f00cda55ed27fa85d667166251e6aa Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Tue, 8 Aug 2017 01:01:29 +0200
Subject: [PATCH 097/154] release: Prepare for 1.49.90

---
 NEWS | 60 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 60 insertions(+)

diff --git a/NEWS b/NEWS
index 4963c636..059b7e48 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,63 @@
+Version 1.49.90
+---------------
+
+- New API: GObject.registerClass(), intended for use with ES6 classes. When
+  defining a GObject class using ES6 syntax, you must call
+  GObject.registerClass() on the class object, with an optional metadata
+  object as the first argument. (The metadata object works exactly like the
+  meta properties from Lang.Class, except that Name and Extends are not
+  present.)
+
+  Old:
+
+      var MyClass = new Lang.Class({
+          Name: 'MyClass',
+          Extends: GObject.Object,
+          Signals: { 'event': {} },
+          _init(props={}) {
+              this._private = [];
+              this.parent(props);
+          },
+      });
+
+  New:
+
+      var MyClass = GObject.registerClass({
+          Signals: { 'event': {} },
+      }, class MyClass extends GObject.Object {
+          _init(props={}) {
+              this._private = [];
+              super._init(props);
+          }
+      });
+
+  It is forward compatible with the following syntax requiring decorators and
+  class fields, which are not in the JS standard yet:
+
+      @GObject.registerClass
+      class MyClass extends GObject.Object {
+          static [GObject.signals] = { 'event': {} }
+          _init(props={}) {
+              this._private = [];
+              super._init(props);
+          }
+      }
+
+  One limitation is that GObject ES6 classes can't have constructor()
+  methods, they must do any setup in an _init() method. This may be able to be
+  fixed in the future.
+
+- Closed bugs:
+
+  * Misc 1.49 and mozjs52 enhancements [#785040, Philip Chimento]
+  * Switch to native promises [#784713, Philip Chimento]
+  * Can't call exports using top-level variable toString [#781623, Philip
+    Chimento]
+  * Properties no longer recognized when shadowed by a method [#785091, Philip
+    Chimento, Rico Tzschichholz]
+  * Patch: backport of changes required for use with mozjs-55 [#785424, Luke
+    Jones]
+
 Version 1.48.6
 --------------
 

From dd14f55081e13c9850a6a9480830ddb8c9bd8b94 Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 23:09:58 -0500
Subject: [PATCH 098/154] Gtk: Use GObject.registerClass() for Gtk.Widgets

This extends the GObject.registerClass() API to deal with the magic
properties from Gtk.WidgetClass: CssName, Template, Children, and
InternalChildren.

https://bugzilla.gnome.org/show_bug.cgi?id=785652

Based on https://github.com/GNOME/gjs/commit/2ede057f18c0c6a22b98fe04118ff06304b4a1cb
---
 installed-tests/js/testGtk.js | 40 +++++++++++++--------------------
 modules/_legacy.js            |  9 ++++----
 modules/overrides/GObject.js  | 19 ++++++++++++++++
 modules/overrides/Gtk.js      | 51 ++++++++++++++++++++++++++++++++++++++++---
 4 files changed, 87 insertions(+), 32 deletions(-)

diff --git a/installed-tests/js/testGtk.js b/installed-tests/js/testGtk.js
index db97108e..8e766057 100755
--- a/installed-tests/js/testGtk.js
+++ b/installed-tests/js/testGtk.js
@@ -1,8 +1,8 @@
 imports.gi.versions.Gtk = '3.0';
 
 const ByteArray = imports.byteArray;
+const GObject = imports.gi.GObject;
 const Gtk = imports.gi.Gtk;
-const Lang = imports.lang;
 
 // This is ugly here, but usually it would be in a resource
 const template = ' \
@@ -34,40 +34,30 @@ const template = ' \
   </template> \
 </interface>';
 
-const MyComplexGtkSubclass = new Lang.Class({
-    Name: 'MyComplexGtkSubclass',
-    Extends: Gtk.Grid,
+const MyComplexGtkSubclass = GObject.registerClass({
     Template: ByteArray.fromString(template),
     Children: ['label-child', 'label-child2'],
     InternalChildren: ['internal-label-child'],
     CssName: 'complex-subclass',
+}, class MyComplexGtkSubclass extends Gtk.Grid {});
 
-    // _init: function(params) {
-    //     this.parent(params);
-    // },
+// Sadly, putting this in the body of the class will prevent calling
+// get_template_child, since MyComplexGtkSubclass will be bound to the ES6
+// class name without the GObject goodies in it
+MyComplexGtkSubclass.prototype.testChildrenExist = function() {
+    this._internalLabel = this.get_template_child(MyComplexGtkSubclass, 'label-child');
+    expect(this._internalLabel).toEqual(jasmine.anything());
 
-    testChildrenExist: function () {
-        this._internalLabel = this.get_template_child(MyComplexGtkSubclass, 'label-child');
-        expect(this._internalLabel).toEqual(jasmine.anything());
+    expect(this.label_child2).toEqual(jasmine.anything());
+    expect(this._internal_label_child).toEqual(jasmine.anything());
+};
 
-        expect(this.label_child2).toEqual(jasmine.anything());
-        expect(this._internal_label_child).toEqual(jasmine.anything());
-    }
-});
-
-
-const MyComplexGtkSubclassFromResource = new Lang.Class({
-    Name: 'MyComplexGtkSubclassFromResource',
-    Extends: Gtk.Grid,
+const MyComplexGtkSubclassFromResource = GObject.registerClass({
     Template: 'resource:///org/gjs/jsunit/complex.ui',
     Children: ['label-child', 'label-child2'],
     InternalChildren: ['internal-label-child'],
-
-    // _init: function(params) {
-    //     this.parent(params);
-    // },
-
-    testChildrenExist: function () {
+}, class MyComplexGtkSubclassFromResource extends Gtk.Grid {
+    testChildrenExist() {
         expect(this.label_child).toEqual(jasmine.anything());
         expect(this.label_child2).toEqual(jasmine.anything());
         expect(this._internal_label_child).toEqual(jasmine.anything());
diff --git a/modules/_legacy.js b/modules/_legacy.js
index 92fe4b3b..6f73adeb 100644
--- a/modules/_legacy.js
+++ b/modules/_legacy.js
@@ -1,5 +1,6 @@
 /* -*- mode: js; indent-tabs-mode: nil; -*- */
-/* exported Class, Interface, defineGObjectLegacyObjects */
+/* exported Class, Interface, defineGObjectLegacyObjects,
+defineGtkLegacyObjects */
 // Copyright 2008  litl, LLC
 // Copyright 2011  Jasper St. Pierre
 
@@ -657,9 +658,9 @@ function defineGtkLegacyObjects(GObject, Gtk) {
                     Gtk.Widget.set_template.call(this, template);
             }
 
-            this.Template = template;
-            this.Children = children;
-            this.InternalChildren = internalChildren;
+            this[Gtk.template] = template;
+            this[Gtk.children] = children;
+            this[Gtk.internalChildren] = internalChildren;
 
             if (children) {
                 for (let i = 0; i < children.length; i++)
diff --git a/modules/overrides/GObject.js b/modules/overrides/GObject.js
index 7643fc34..4a7ffbc9 100644
--- a/modules/overrides/GObject.js
+++ b/modules/overrides/GObject.js
@@ -32,6 +32,12 @@ var properties = Symbol('GObject properties');
 var requires = Symbol('GObject interface requires');
 var signals = Symbol('GObject signals');
 
+// These four will be aliased to GTK
+var _children = Symbol('GTK widget template children');
+var _cssName = Symbol('GTK widget CSS name');
+var _internalChildren = Symbol('GTK widget template internal children');
+var _template = Symbol('GTK widget template');
+
 function registerClass(klass) {
     if (arguments.length == 2) {
         // The two-argument form is the convenient syntax without ESnext
@@ -60,6 +66,14 @@ function registerClass(klass) {
             klass[signals] = metaInfo.Signals;
         if ('Requires' in metaInfo)
             klass[requires] = metaInfo.Requires;
+        if ('CssName' in metaInfo)
+            klass[_cssName] = metaInfo.CssName;
+        if ('Template' in metaInfo)
+            klass[_template] = metaInfo.Template;
+        if ('Children' in metaInfo)
+            klass[_children] = metaInfo.Children;
+        if ('InternalChildren' in metaInfo)
+            klass[_internalChildren] = metaInfo.InternalChildren;
     }
 
     if (!(klass.prototype instanceof GObject.Object) &&
@@ -422,6 +436,11 @@ function _init() {
         get name() { return 'NotImplementedError'; }
     };
 
+    GObject._cssName = _cssName;
+    GObject._template = _template;
+    GObject._children = _children;
+    GObject._internalChildren = _internalChildren;
+
     // fake enum for signal accumulators, keep in sync with gi/object.c
     this.AccumulatorType = {
         NONE: 0,
diff --git a/modules/overrides/Gtk.js b/modules/overrides/Gtk.js
index 5e98a58c..bda7c12e 100644
--- a/modules/overrides/Gtk.js
+++ b/modules/overrides/Gtk.js
@@ -30,8 +30,14 @@ function _init() {
 
     Gtk = this;
 
+    Gtk.children = GObject._children;
+    Gtk.cssName = GObject._cssName;
+    Gtk.internalChildren = GObject._internalChildren;
+    Gtk.template = GObject._template;
+
     let {GtkWidgetClass} = Legacy.defineGtkLegacyObjects(GObject, Gtk);
     Gtk.Widget.prototype.__metaclass__ = GtkWidgetClass;
+
     if (CjsPrivate.gtk_container_child_set_property) {
         Gtk.Container.prototype.child_set_property = function(child, property, value) {
             CjsPrivate.gtk_container_child_set_property(this, child, property, value);
@@ -41,18 +47,57 @@ function _init() {
     Gtk.Widget.prototype._init = function(params) {
         GObject.Object.prototype._init.call(this, params);
 
-        if (this.constructor.Template) {
-            let children = this.constructor.Children || [];
+        if (this.constructor[Gtk.template]) {
+            let children = this.constructor[Gtk.children] || [];
             for (let child of children) {
                 this[child.replace(/-/g, '_')] =
                     this.get_template_child(this.constructor, child);
             }
 
-            let internalChildren = this.constructor.InternalChildren || [];
+            let internalChildren = this.constructor[Gtk.internalChildren] || [];
             for (let child of internalChildren) {
                 this['_' + child.replace(/-/g, '_')] =
                     this.get_template_child(this.constructor, child);
             }
         }
     };
+
+    Gtk.Widget._classInit = function(klass) {
+        let template = klass[Gtk.template];
+        let cssName = klass[Gtk.cssName];
+        let children = klass[Gtk.children];
+        let internalChildren = klass[Gtk.internalChildren];
+
+        if (template) {
+            klass.prototype._instance_init = function() {
+                this.init_template();
+            };
+        }
+
+        klass = GObject.Object._classInit(klass);
+
+        if (cssName)
+            Gtk.Widget.set_css_name.call(klass, cssName);
+
+        if (template) {
+            if (typeof template === 'string' &&
+                template.startsWith('resource:///'))
+                Gtk.Widget.set_template_from_resource.call(klass,
+                    template.slice(11));
+            else
+                Gtk.Widget.set_template.call(klass, template);
+        }
+
+        if (children) {
+            children.forEach(child =>
+                Gtk.Widget.bind_template_child_full.call(klass, child, false, 0));
+        }
+
+        if (internalChildren) {
+            internalChildren.forEach(child =>
+                Gtk.Widget.bind_template_child_full.call(klass, child, true, 0));
+        }
+
+        return klass;
+    };
 }

From c416f630080ff1ce0bd56bd28b7234857e48776f Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Tue, 8 Aug 2017 17:32:09 +0200
Subject: [PATCH 099/154] legacy class: Add name property to class object

Instead of the __name__ property on instances, add a name property to
class objects. The __name__ property continues to work, for backwards
compatibility in case any code used it (unlikely), but this is compatible
with ES6 classes.

https://bugzilla.gnome.org/show_bug.cgi?id=785652
---
 NEWS                                    |  8 ++++++++
 installed-tests/js/testLegacyClass.js   |  8 ++++++++
 installed-tests/js/testLegacyGObject.js | 12 ++++++++++--
 modules/_legacy.js                      | 26 ++++++++++++++++++++++++++
 4 files changed, 52 insertions(+), 2 deletions(-)

diff --git a/NEWS b/NEWS
index 059b7e48..2e865e67 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,11 @@
+NEXT
+----
+
+- Deprecation: The private "__name__" property on Lang.Class instances is
+  now discouraged. Code should not have been using this anyway, but if it did
+  then it should use the "name" property on the class (this.__name__ should
+  become this.constructor.name), which is compatible with ES6 classes.
+
 Version 1.49.90
 ---------------
 
diff --git a/installed-tests/js/testLegacyClass.js b/installed-tests/js/testLegacyClass.js
index 5675796a..6805532d 100644
--- a/installed-tests/js/testLegacyClass.js
+++ b/installed-tests/js/testLegacyClass.js
@@ -216,6 +216,10 @@ describe('Class framework', function () {
         expect(newMagic instanceof MagicBase).toBeTruthy();
     });
 
+    it('has a name', function () {
+        expect(Magic.name).toEqual('Magic');
+    });
+
     it('reports a sensible value for toString()', function () {
         let newMagic = new MagicBase();
         expect(newMagic.toString()).toEqual('[object MagicBase]');
@@ -424,6 +428,10 @@ describe('An interface', function () {
         expect(InterfaceRequiringOtherInterface instanceof Lang.Interface).toBeTruthy();
     });
 
+    it('has a name', function () {
+        expect(AnInterface.name).toEqual('AnInterface');
+    });
+
     it('cannot be instantiated', function () {
         expect(() => new AnInterface()).toThrow();
     });
diff --git a/installed-tests/js/testLegacyGObject.js b/installed-tests/js/testLegacyGObject.js
index f79e63e1..35f82fbe 100644
--- a/installed-tests/js/testLegacyGObject.js
+++ b/installed-tests/js/testLegacyGObject.js
@@ -214,6 +214,10 @@ describe('GObject class', function () {
         expect(myInstance3.construct).toEqual('quz');
     });
 
+    it('has a name', function () {
+        expect(MyObject.name).toEqual('MyObject');
+    });
+
     // the following would (should) cause a CRITICAL:
     // myInstance.readonly = 'val';
     // myInstance.construct = 'val';
@@ -513,6 +517,10 @@ describe('GObject interface', function () {
         expect(() => new AGObjectInterface()).toThrow();
     });
 
+    it('has a name', function () {
+        expect(AGObjectInterface.name).toEqual('AGObjectInterface');
+    });
+
     it('reports its type name', function () {
         expect(AGObjectInterface.$gtype.name).toEqual('ArbitraryGTypeName');
     });
@@ -527,8 +535,8 @@ describe('GObject interface', function () {
     it('is implemented by a GObject class with the correct class object', function () {
         let obj = new GObjectImplementingGObjectInterface();
         expect(obj.constructor).toEqual(GObjectImplementingGObjectInterface);
-        expect(obj.constructor.toString())
-            .toEqual('[object GObjectClass for GObjectImplementingGObjectInterface]');
+        expect(obj.constructor.name)
+            .toEqual('GObjectImplementingGObjectInterface');
     });
 
     it('can be implemented by a class also implementing a Lang.Interface', function () {
diff --git a/modules/_legacy.js b/modules/_legacy.js
index 6f73adeb..99cef8cb 100644
--- a/modules/_legacy.js
+++ b/modules/_legacy.js
@@ -149,6 +149,12 @@ Class.prototype._construct = function(params) {
             value: interfaces,
         },
     });
+    Object.defineProperty(newClass, 'name', {
+        writable: false,
+        configurable: true,
+        enumerable: false,
+        value: name,
+    });
 
     interfaces.forEach((iface) => {
         iface._check(newClass.prototype);
@@ -313,6 +319,12 @@ Interface.prototype._construct = function (params) {
         enumerable: false,
         value: this.constructor,
     });
+    Object.defineProperty(newInterface, 'name', {
+        writable: false,
+        configurable: true,
+        enumerable: false,
+        value: params.Name,
+    });
 
     return newInterface;
 };
@@ -544,6 +556,13 @@ function defineGObjectLegacyObjects(GObject) {
                     value: interfaces,
                 },
             });
+            // Overwrite the C++-set class name, as if it were an ES6 class
+            Object.defineProperty(newClass, 'name', {
+                writable: false,
+                configurable: true,
+                enumerable: false,
+                value: name,
+            });
 
             interfaces.forEach((iface) => {
                 if (iface instanceof Interface)
@@ -605,6 +624,13 @@ function defineGObjectLegacyObjects(GObject) {
             enumerable: false,
             value: this.constructor,
         });
+        // Overwrite the C++-set class name, as if it were an ES6 class
+        Object.defineProperty(newInterface, 'name', {
+            writable: false,
+            configurable: true,
+            enumerable: false,
+            value: params.Name,
+        });
 
         return newInterface;
     };

From 68739e428c9207493dac943db397d4508cf8d256 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Wed, 9 Aug 2017 16:14:17 +0200
Subject: [PATCH 100/154] legacy class: Reinstate Lang.getMetaClass()

Some client code was using this, so we should keep it as public API. Add
a trivial test to make sure it doesn't break in the future.

https://bugzilla.gnome.org/show_bug.cgi?id=785652
---
 installed-tests/js/testLegacyClass.js | 6 ++++++
 modules/lang.js                       | 2 +-
 2 files changed, 7 insertions(+), 1 deletion(-)

diff --git a/installed-tests/js/testLegacyClass.js b/installed-tests/js/testLegacyClass.js
index 6805532d..ac59e8e6 100644
--- a/installed-tests/js/testLegacyClass.js
+++ b/installed-tests/js/testLegacyClass.js
@@ -114,6 +114,12 @@ describe('A metaclass', function () {
         expect(instance).toEqual(jasmine.objectContaining({ one: 1, two: 2, three: 3 }));
         expect(instance.dynamic_method()).toEqual(73);
     });
+
+    it('can be detected with Lang.getMetaClass', function () {
+        expect(Lang.getMetaClass({
+            Extends: CustomMetaOne,
+        })).toBe(MetaClass);
+    });
 });
 
 const MagicBase = new Lang.Class({
diff --git a/modules/lang.js b/modules/lang.js
index da6d0dcd..54b5dbdb 100644
--- a/modules/lang.js
+++ b/modules/lang.js
@@ -23,7 +23,7 @@ countProperties */
 
 // Utilities that are "meta-language" things like manipulating object props
 
-var {Class, Interface} = imports._legacy;
+var {Class, Interface, getMetaClass} = imports._legacy;
 
 function countProperties(obj) {
     let count = 0;

From 794b1b88a1b18e6c42fa871584e2ec3bd32b7cc2 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Fri, 11 Aug 2017 13:11:20 +0100
Subject: [PATCH 101/154] gerror: Use JS::CaptureCurrentStack for stack info

This uses the new facilities available in JSAPI to define the standard JS
Error properties on GError-marshalled exceptions, rather than the
workaround of creating a new Error object and reading its properties that
was previously used in gjs_context_get_frame_info().

https://bugzilla.gnome.org/show_bug.cgi?id=786183
---
 cjs/jsapi-util.cpp | 28 ++++++++++++++++++++++++++++
 cjs/jsapi-util.h   | 16 ++++++++++++++++
 gi/gerror.cpp      | 36 +++++++++++++++++++++++-------------
 3 files changed, 67 insertions(+), 13 deletions(-)

diff --git a/cjs/jsapi-util.cpp b/cjs/jsapi-util.cpp
index 57e4cb43..bbec8d52 100644
--- a/cjs/jsapi-util.cpp
+++ b/cjs/jsapi-util.cpp
@@ -106,6 +106,34 @@ gjs_object_define_property(JSContext       *cx,
                                  value, flags, getter, setter);
 }
 
+bool
+gjs_object_define_property(JSContext       *cx,
+                           JS::HandleObject obj,
+                           GjsConstString   property_name,
+                           JS::HandleString value,
+                           unsigned         flags,
+                           JSNative         getter,
+                           JSNative         setter)
+{
+    return JS_DefinePropertyById(cx, obj,
+                                 gjs_context_get_const_string(cx, property_name),
+                                 value, flags, getter, setter);
+}
+
+bool
+gjs_object_define_property(JSContext       *cx,
+                           JS::HandleObject obj,
+                           GjsConstString   property_name,
+                           uint32_t         value,
+                           unsigned         flags,
+                           JSNative         getter,
+                           JSNative         setter)
+{
+    return JS_DefinePropertyById(cx, obj,
+                                 gjs_context_get_const_string(cx, property_name),
+                                 value, flags, getter, setter);
+}
+
 static void
 throw_property_lookup_error(JSContext       *cx,
                             JS::HandleObject obj,
diff --git a/cjs/jsapi-util.h b/cjs/jsapi-util.h
index fe5b524f..2bc24680 100644
--- a/cjs/jsapi-util.h
+++ b/cjs/jsapi-util.h
@@ -340,6 +340,22 @@ bool gjs_object_define_property(JSContext       *cx,
                                 JSNative         getter = nullptr,
                                 JSNative         setter = nullptr);
 
+bool gjs_object_define_property(JSContext       *cx,
+                                JS::HandleObject obj,
+                                GjsConstString   property_name,
+                                JS::HandleString value,
+                                unsigned         flags,
+                                JSNative         getter = nullptr,
+                                JSNative         setter = nullptr);
+
+bool gjs_object_define_property(JSContext       *cx,
+                                JS::HandleObject obj,
+                                GjsConstString   property_name,
+                                uint32_t         value,
+                                unsigned         flags,
+                                JSNative         getter = nullptr,
+                                JSNative         setter = nullptr);
+
 JS::HandleId gjs_context_get_const_string(JSContext     *cx,
                                           GjsConstString string);
 
diff --git a/gi/gerror.cpp b/gi/gerror.cpp
index 766e0182..fbabf3fe 100644
--- a/gi/gerror.cpp
+++ b/gi/gerror.cpp
@@ -392,25 +392,35 @@ find_error_domain_info(GQuark domain)
    fileName, lineNumber and stack
 */
 static void
-define_error_properties(JSContext       *context,
+define_error_properties(JSContext       *cx,
                         JS::HandleObject obj)
 {
-    JS::RootedValue stack(context), fileName(context), lineNumber(context);
-
-    if (!gjs_context_get_frame_info(context,
-                                    mozilla::Some<JS::MutableHandleValue>(&stack),
-                                    mozilla::Some<JS::MutableHandleValue>(&fileName),
-                                    mozilla::Some<JS::MutableHandleValue>(&lineNumber)))
+    JS::RootedObject frame(cx);
+    JS::RootedString stack(cx);
+    JS::RootedString source(cx);
+    uint32_t line;
+    JS::AutoSaveExceptionState exc(cx);
+
+    if (!JS::CaptureCurrentStack(cx, &frame) ||
+        !JS::BuildStackString(cx, frame, &stack)) {
+        exc.restore();
         return;
+    }
 
-    gjs_object_define_property(context, obj, GJS_STRING_STACK, stack,
-                               JSPROP_ENUMERATE);
+    JS::SavedFrameResult result;
+    result = JS::GetSavedFrameSource(cx, frame, &source);
+    g_assert(result == JS::SavedFrameResult::Ok);
 
-    gjs_object_define_property(context, obj, GJS_STRING_FILENAME,
-                               fileName, JSPROP_ENUMERATE);
+    result = JS::GetSavedFrameLine(cx, frame, &line);
+    g_assert(result == JS::SavedFrameResult::Ok);
 
-    gjs_object_define_property(context, obj, GJS_STRING_LINE_NUMBER,
-                               lineNumber, JSPROP_ENUMERATE);
+    if (!gjs_object_define_property(cx, obj, GJS_STRING_STACK, stack,
+                                    JSPROP_ENUMERATE) ||
+        !gjs_object_define_property(cx, obj, GJS_STRING_FILENAME, source,
+                                    JSPROP_ENUMERATE) ||
+        !gjs_object_define_property(cx, obj, GJS_STRING_LINE_NUMBER, line,
+                                    JSPROP_ENUMERATE))
+        exc.restore();
 }
 
 JSObject*

From 8f097d380bcf3e640642c1d300d7313643bcec9a Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Fri, 11 Aug 2017 13:15:02 +0100
Subject: [PATCH 102/154] stack: Remove gjs_context_get_frame_info()

This is not needed anymore as we can now use the new facilities in JSAPI
for getting frame info, and use gjs_format_stack_trace() to build the
actual stack string.

https://bugzilla.gnome.org/show_bug.cgi?id=786183
---
 cjs/jsapi-util.h    |  5 -----
 cjs/jsapi-wrapper.h |  1 -
 cjs/stack.cpp       | 47 +++++------------------------------------------
 3 files changed, 5 insertions(+), 48 deletions(-)

diff --git a/cjs/jsapi-util.h b/cjs/jsapi-util.h
index 2bc24680..b9d1959c 100644
--- a/cjs/jsapi-util.h
+++ b/cjs/jsapi-util.h
@@ -254,11 +254,6 @@ const char* gjs_get_type_name                (JS::Value        value);
 
 void gjs_maybe_gc (JSContext *context);
 
-bool gjs_context_get_frame_info(JSContext                             *cx,
-                                mozilla::Maybe<JS::MutableHandleValue> stack,
-                                mozilla::Maybe<JS::MutableHandleValue> fileName,
-                                mozilla::Maybe<JS::MutableHandleValue> lineNumber);
-
 bool gjs_eval_with_scope(JSContext             *context,
                          JS::HandleObject       object,
                          const char            *script,
diff --git a/cjs/jsapi-wrapper.h b/cjs/jsapi-wrapper.h
index bdc7245c..1eb06563 100644
--- a/cjs/jsapi-wrapper.h
+++ b/cjs/jsapi-wrapper.h
@@ -38,7 +38,6 @@
 #if defined(__clang__) || __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)
 #pragma GCC system_header
 #endif
-#include <mozilla/Maybe.h>
 #include <jsapi.h>
 #include <jsfriendapi.h>
 #include <js/Conversions.h>
diff --git a/cjs/stack.cpp b/cjs/stack.cpp
index 2d3a7cb9..f71f852a 100644
--- a/cjs/stack.cpp
+++ b/cjs/stack.cpp
@@ -47,57 +47,20 @@
 #include "jsapi-util.h"
 #include "jsapi-wrapper.h"
 
-bool
-gjs_context_get_frame_info(JSContext                             *context,
-                           mozilla::Maybe<JS::MutableHandleValue> stack,
-                           mozilla::Maybe<JS::MutableHandleValue> fileName,
-                           mozilla::Maybe<JS::MutableHandleValue> lineNumber)
-{
-    JSAutoRequest ar(context);
-    JS::RootedObject global(context, JS::CurrentGlobalOrNull(context)),
-        constructor(context);
-    JSAutoCompartment ac(context, global);
-
-    JS::RootedId error_id(context, gjs_intern_string_to_id(context, "Error"));
-    if (!gjs_object_require_property(context, global, "global object",
-                                     error_id, &constructor))
-        return false;
-
-    JS::RootedObject err_obj(context, JS_New(context, constructor,
-                                             JS::HandleValueArray::empty()));
-
-    if (stack &&
-        !gjs_object_get_property(context, err_obj, GJS_STRING_STACK,
-                                 stack.ref()))
-        return false;
-
-    if (fileName &&
-        !gjs_object_get_property(context, err_obj, GJS_STRING_FILENAME,
-                                 fileName.ref()))
-        return false;
-
-    if (lineNumber &&
-        !gjs_object_get_property(context, err_obj, GJS_STRING_LINE_NUMBER,
-                                 lineNumber.ref()))
-        return false;
-
-    return true;
-}
-
 void
 gjs_context_print_stack_stderr(GjsContext *context)
 {
     JSContext *cx = (JSContext*) gjs_context_get_native_context(context);
-    JS::RootedValue v_stack(cx);
+    JS::RootedObject frame(cx);
+    JS::AutoSaveExceptionState exc(cx);
     GjsAutoChar stack;
 
     g_printerr("== Stack trace for context %p ==\n", context);
 
-    /* Stderr is locale encoding, so we use string_to_filename here */
-    if (!gjs_context_get_frame_info(cx, mozilla::Some<JS::MutableHandleValue>(&v_stack),
-                                    mozilla::Nothing(), mozilla::Nothing()) ||
-        !gjs_string_to_filename(cx, v_stack, &stack)) {
+    if (!JS::CaptureCurrentStack(cx, &frame) ||
+        !(stack = gjs_format_stack_trace(cx, frame))) {
         g_printerr("No stack trace available\n");
+        exc.restore();
         return;
     }
 

From ee3872eefe99bacea5dfdc68ebc9f8d8fa293727 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Fri, 11 Aug 2017 13:38:37 +0100
Subject: [PATCH 103/154] gerror: Define a columnNumber on GError-backed errors

Newer JS defines a columnNumber property on Error objects, so our
GError-backed ones should have this property as well.

https://bugzilla.gnome.org/show_bug.cgi?id=786183
---
 cjs/context.cpp  | 4 ++--
 cjs/jsapi-util.h | 1 +
 gi/gerror.cpp    | 7 ++++++-
 3 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/cjs/context.cpp b/cjs/context.cpp
index 33f4ad51..8d92b72c 100644
--- a/cjs/context.cpp
+++ b/cjs/context.cpp
@@ -102,8 +102,8 @@ static const char *const_strings[] = {
     "__gjsKeepAlive", "__gjsPrivateNS",
     "gi", "versions", "overrides",
     "_init", "_instance_init", "_new_internal", "new",
-    "message", "code", "stack", "fileName", "lineNumber", "name",
-    "x", "y", "width", "height", "__modulePath__"
+    "message", "code", "stack", "fileName", "lineNumber", "columnNumber",
+    "name", "x", "y", "width", "height", "__modulePath__"
 };
 
 G_STATIC_ASSERT(G_N_ELEMENTS(const_strings) == GJS_STRING_LAST);
diff --git a/cjs/jsapi-util.h b/cjs/jsapi-util.h
index b9d1959c..cb90a2f3 100644
--- a/cjs/jsapi-util.h
+++ b/cjs/jsapi-util.h
@@ -283,6 +283,7 @@ typedef enum {
   GJS_STRING_STACK,
   GJS_STRING_FILENAME,
   GJS_STRING_LINE_NUMBER,
+  GJS_STRING_COLUMN_NUMBER,
   GJS_STRING_NAME,
   GJS_STRING_X,
   GJS_STRING_Y,
diff --git a/gi/gerror.cpp b/gi/gerror.cpp
index fbabf3fe..cd2f3650 100644
--- a/gi/gerror.cpp
+++ b/gi/gerror.cpp
@@ -398,7 +398,7 @@ define_error_properties(JSContext       *cx,
     JS::RootedObject frame(cx);
     JS::RootedString stack(cx);
     JS::RootedString source(cx);
-    uint32_t line;
+    uint32_t line, column;
     JS::AutoSaveExceptionState exc(cx);
 
     if (!JS::CaptureCurrentStack(cx, &frame) ||
@@ -414,11 +414,16 @@ define_error_properties(JSContext       *cx,
     result = JS::GetSavedFrameLine(cx, frame, &line);
     g_assert(result == JS::SavedFrameResult::Ok);
 
+    result = JS::GetSavedFrameColumn(cx, frame, &column);
+    g_assert(result == JS::SavedFrameResult::Ok);
+
     if (!gjs_object_define_property(cx, obj, GJS_STRING_STACK, stack,
                                     JSPROP_ENUMERATE) ||
         !gjs_object_define_property(cx, obj, GJS_STRING_FILENAME, source,
                                     JSPROP_ENUMERATE) ||
         !gjs_object_define_property(cx, obj, GJS_STRING_LINE_NUMBER, line,
+                                    JSPROP_ENUMERATE) ||
+        !gjs_object_define_property(cx, obj, GJS_STRING_COLUMN_NUMBER, column,
                                     JSPROP_ENUMERATE))
         exc.restore();
 }

From b144d84185810aeb1e3f75db837a7c03f615c229 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Fri, 11 Aug 2017 16:56:54 -0700
Subject: [PATCH 104/154] console: Print exception even when not from
 SpiderMonkey

This was a recent regression; the console shell would abort if an
exception couldn't be converted into an error report. However, only
exceptions created within SpiderMonkey have error reports associated with
them. Our exceptions created from GErrors do not, so if there is no error
report available simply convert the exception to a string.

https://bugzilla.gnome.org/show_bug.cgi?id=786183
---
 modules/console.cpp | 18 ++++++++++++------
 1 file changed, 12 insertions(+), 6 deletions(-)

diff --git a/modules/console.cpp b/modules/console.cpp
index 5b61f10a..d03b0db4 100644
--- a/modules/console.cpp
+++ b/modules/console.cpp
@@ -156,12 +156,18 @@ class AutoReportException {
 
         JS::RootedObject exn(m_cx, &v_exn.toObject());
         JSErrorReport *report = JS_ErrorFromException(m_cx, exn);
-        if (!report)
-            g_error("Out of memory initializing ErrorReport");
-
-        g_assert(!JSREPORT_IS_WARNING(report->flags));
-
-        gjs_console_print_error(report);
+        if (report) {
+            g_assert(!JSREPORT_IS_WARNING(report->flags));
+            gjs_console_print_error(report);
+        } else {
+            JS::RootedString message(m_cx, JS::ToString(m_cx, v_exn));
+            if (!message) {
+                g_printerr("(could not convert thrown exception to string)\n");
+            } else {
+                GjsAutoJSChar message_utf8(m_cx, JS_EncodeStringToUTF8(m_cx, message));
+                g_printerr("%s\n", message_utf8.get());
+            }
+        }
 
         JS::RootedObject stack(m_cx, ExceptionStackOrNull(exn));
         if (stack) {

From 1f171d5d0ec8b9a5ad7a1c1cfc4880b819ef54a3 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Wed, 16 Aug 2017 18:23:42 -0700
Subject: [PATCH 105/154] tests: Re-enable accidentally disabled tests

Accidentally put a commit up for review with some tests disabled, and
didn't catch it in time. This re-enables those tests.

Unreviewed.
---
 installed-tests/js/testLegacyGObject.js | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/installed-tests/js/testLegacyGObject.js b/installed-tests/js/testLegacyGObject.js
index 35f82fbe..39f0150e 100644
--- a/installed-tests/js/testLegacyGObject.js
+++ b/installed-tests/js/testLegacyGObject.js
@@ -913,7 +913,7 @@ const Shiny = GObject.registerClass({
     set override_property(value) { this._override_property = value - 1; }
 });
 
-fdescribe('ES6 GObject class inheriting from GObject.Class', function () {
+describe('ES6 GObject class inheriting from GObject.Class', function () {
     let instance;
 
     beforeEach(function () {

From d9f08c67f6ab09e422898759619d4ade196b0ca3 Mon Sep 17 00:00:00 2001
From: Benjamin Berg <bberg@redhat.com>
Date: Tue, 8 Aug 2017 20:53:50 +0200
Subject: [PATCH 106/154] jsapi-util: Also rate limit checking the process size

Querying /proc/self/stat has quite an overhead which e.g. can be seen
when draging a window. Before this patch the GC was already rate
limited to only run every 5 frames. This also lowers the rate of
checking whether the GC should be run to be lower.

This change may delay a GC run a bit. However the maximum delay is
equivalent to the previous rate limiting.

https://bugzilla.gnome.org/show_bug.cgi?id=786017
---
 cjs/jsapi-util.cpp | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/cjs/jsapi-util.cpp b/cjs/jsapi-util.cpp
index bbec8d52..0dfe12f0 100644
--- a/cjs/jsapi-util.cpp
+++ b/cjs/jsapi-util.cpp
@@ -706,7 +706,7 @@ _linux_get_self_process_size (gulong *vm_size,
 }
 
 static gulong linux_rss_trigger;
-static gint64 last_gc_time;
+static int64_t last_gc_check_time;
 #endif
 
 void
@@ -722,9 +722,11 @@ gjs_gc_if_needed (JSContext *context)
         /* We rate limit GCs to at most one per 5 frames.
            One frame is 16666 microseconds (1000000/60)*/
         now = g_get_monotonic_time();
-        if (now - last_gc_time < 5 * 16666)
+        if (now - last_gc_check_time < 5 * 16666)
             return;
 
+        last_gc_check_time = now;
+
         _linux_get_self_process_size (&vmsize, &rss_size);
 
         /* linux_rss_trigger is initialized to 0, so currently
@@ -740,7 +742,6 @@ gjs_gc_if_needed (JSContext *context)
         if (rss_size > linux_rss_trigger) {
             linux_rss_trigger = (gulong) MIN(G_MAXULONG, rss_size * 1.25);
             JS_GC(context);
-            last_gc_time = now;
         } else if (rss_size < (0.75 * linux_rss_trigger)) {
             /* If we've shrunk by 75%, lower the trigger */
             linux_rss_trigger = (rss_size * 1.25);

From affdabe0dbcc2f8ed14c9d6140e6654a65803f26 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Mon, 21 Aug 2017 16:16:44 -0700
Subject: [PATCH 107/154] release: Prepare for 1.49.91

---
 NEWS | 13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

diff --git a/NEWS b/NEWS
index 2e865e67..63b4ce2f 100644
--- a/NEWS
+++ b/NEWS
@@ -1,11 +1,20 @@
-NEXT
-----
+1.49.91
+-------
 
 - Deprecation: The private "__name__" property on Lang.Class instances is
   now discouraged. Code should not have been using this anyway, but if it did
   then it should use the "name" property on the class (this.__name__ should
   become this.constructor.name), which is compatible with ES6 classes.
 
+- Closed bugs:
+
+  * Use ES6 classes [#785652, Philip Chimento]
+  * A few fixes for stack traces and error reporting [#786183, Philip Chimento]
+  * /proc/self/stat is read for every frame if GC was not needed [#786017,
+    Benjamin Berg]
+
+- Build fix [Philip Chimento]
+
 Version 1.49.90
 ---------------
 

From 13a339f10991b7bfa772bb423acc310bc9e8cfa7 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Tue, 22 Aug 2017 16:57:43 -0700
Subject: [PATCH 108/154] object: Remove unused argument

gjs_object_prepare_shutdown() doesn't need to access the JSContext.

https://bugzilla.gnome.org/show_bug.cgi?id=786668
---
 cjs/context.cpp | 2 +-
 gi/object.cpp   | 2 +-
 gi/object.h     | 3 +--
 3 files changed, 3 insertions(+), 4 deletions(-)

diff --git a/cjs/context.cpp b/cjs/context.cpp
index 8d92b72c..28a86798 100644
--- a/cjs/context.cpp
+++ b/cjs/context.cpp
@@ -240,7 +240,7 @@ gjs_context_dispose(GObject *object)
          * the JS teardown and the C teardown.  The JSObject proxies
          * still exist, but point to NULL.
          */
-        gjs_object_prepare_shutdown(js_context->context);
+        gjs_object_prepare_shutdown();
 
         if (js_context->auto_gc_id > 0) {
             g_source_remove (js_context->auto_gc_id);
diff --git a/gi/object.cpp b/gi/object.cpp
index 5718ae5e..3e1ae3ad 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -1154,7 +1154,7 @@ gjs_object_clear_toggles(void)
 }
 
 void
-gjs_object_prepare_shutdown (JSContext *context)
+gjs_object_prepare_shutdown(void)
 {
     /* First, get rid of anything left over on the main context */
     gjs_object_clear_toggles();
diff --git a/gi/object.h b/gi/object.h
index 7004aac9..8271a6eb 100644
--- a/gi/object.h
+++ b/gi/object.h
@@ -56,8 +56,7 @@ bool      gjs_typecheck_is_object(JSContext       *context,
                                   JS::HandleObject obj,
                                   bool             throw_error);
 
-void      gjs_object_prepare_shutdown   (JSContext     *context);
-
+void gjs_object_prepare_shutdown(void);
 void gjs_object_clear_toggles(void);
 
 void gjs_object_define_static_methods(JSContext       *context,

From 4b5eb8f7baf2eb9e0334a5dfc541c3a3d3746edd Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 23:17:59 -0500
Subject: [PATCH 109/154] maint: add ASAN Address Sanitizer

AddressSanitizer (or ASan) is a programming tool that detects memory
corruption bugs such as buffer overflows or use after free. AddressSanitizer
is based on compiler instrumentation.

UndefinedBehaviorSanitizer (or UBSan) is a fast undefined behavior
detector. It modifies the program at compile-time to catch errors
such as using misaligned or null pointer and signed integer overflow.

The llvm.org states that Sanitizers have found thousands of bugs everywhere.
Sanitizers running during CI can prevent bugs from taking up residence. They
are helper tools to maintain bugs out.

https://bugzilla.gnome.org/show_bug.cgi?id=783220

Based on https://github.com/GNOME/gjs/commit/98830739c83e8807ee2e499f095e26f8a069309f
---
 Makefile.am    |  7 ++++---
 configure.ac   | 34 ++++++++++++++++++++++++++++++++++
 doc/Hacking.md | 16 ++++++++++++++++
 3 files changed, 54 insertions(+), 3 deletions(-)

diff --git a/Makefile.am b/Makefile.am
index 9904fc80..e2541175 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -60,9 +60,10 @@ libcjs_la_CPPFLAGS =		\
 	$(gjs_directory_defines)\
 	-I$(top_srcdir)/gi	\
 	-DGJS_COMPILATION
-libcjs_la_LDFLAGS = 		\
-	-export-symbols-regex "^[^_]" -version-info 0:0:0	\
-	-no-undefined \
+libcjs_la_LDFLAGS = 			\
+	-export-symbols-regex "^[^_]"	\
+	-version-info 0:0:0		\
+	$(NO_UNDEFINED_FLAG)		\
 	$(NULL)
 libcjs_la_LIBADD = 		\
 	$(GJS_LIBS)		\
diff --git a/configure.ac b/configure.ac
index 154c4814..431c5c44 100644
--- a/configure.ac
+++ b/configure.ac
@@ -216,6 +216,40 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
 ])
 CPPFLAGS="$CPPFLAGS_save"
 
+dnl
+dnl Check for -fsanitize=address and -fsanitize=undefined support
+dnl
+AC_ARG_ENABLE([asan],
+  [AS_HELP_STRING([--enable-asan], [Build with address sanitizer support @<:@default: no@:>@])])
+
+AS_IF([test "x$enable_asan" = "xyes"], [
+  AX_CHECK_COMPILE_FLAG([-fsanitize=address -fno-omit-frame-pointer -g], [
+    AX_CHECK_LINK_FLAG([-fsanitize=address], [SAN_FLAGS="-fsanitize=address"])
+  ])
+])
+
+AC_ARG_ENABLE([ubsan],
+  [AS_HELP_STRING([--enable-ubsan], [Build with undefined behavior sanitizer support @<:@default: no@:>@])])
+
+AS_IF([test "x$enable_ubsan" = "xyes"], [
+  AX_CHECK_COMPILE_FLAG([-fsanitize=undefined -fno-omit-frame-pointer -g], [
+    AX_CHECK_LINK_FLAG([-fsanitize=undefined],
+      [SAN_FLAGS="$SAN_FLAGS -fsanitize=undefined"])
+  ])
+])
+
+# According to https://github.com/google/sanitizers/issues/380, asan is not
+# compatible with -no-undefined.
+NO_UNDEFINED_FLAG=-no-undefined
+AS_IF([test -n "${SAN_FLAGS}"], [
+    GJS_CFLAGS="$GJS_CFLAGS $SAN_FLAGS -fno-omit-frame-pointer -g"
+    # We have to clobber LDFLAGS here and not use AM_LDFLAGS, or else
+    # g-ir-scanner will not pick it up.
+    LDFLAGS="$LDFLAGS $SAN_FLAGS"
+    NO_UNDEFINED_FLAG=
+])
+AC_SUBST([NO_UNDEFINED_FLAG])
+
 AC_ARG_WITH([xvfb-tests],
   [AS_HELP_STRING([--with-xvfb-tests],
     [Run all tests under an XVFB server @<:@default=no@:>@])])
diff --git a/doc/Hacking.md b/doc/Hacking.md
index 0da343e0..fd8a5552 100644
--- a/doc/Hacking.md
+++ b/doc/Hacking.md
@@ -100,6 +100,22 @@ It is a versatile tool that can check non-standard code, including: variable
 checking, bounds checking, leaks, etc. It can detect the types of bugs that
 the compilers normally fail to detect.
 
+### Sanitizers ###
+
+To add instrumentation code to gjs, put this (both, or any one of them) in
+your JHBuild configuration file:
+```python
+module_autogenargs['gjs'] = '--enable-asan --enable-ubsan'
+```
+
+Sanitizers are based on compile-time instrumentation. They are available
+in gcc and clang for a range of supported operating systems and
+platforms.
+
+Please, keep in mind that instrumentation is limited by execution coverage. So,
+if your "testing" session never reaches a particular point of execution, then
+instrumentation at that point collects no data.
+
 ### Test Coverage ###
 
 To generate a test coverage report, put this in your JHBuild

From 06621eaccc92d865bde393cd595bf2813746b310 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Thu, 24 Aug 2017 20:35:15 -0700
Subject: [PATCH 110/154] docs: Correct leftover mozjs38

mozjs38 -> mozjs52 in Hacking.md. Unreviewed.
---
 doc/Hacking.md | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/doc/Hacking.md b/doc/Hacking.md
index fd8a5552..51c18c00 100644
--- a/doc/Hacking.md
+++ b/doc/Hacking.md
@@ -9,10 +9,10 @@ Even if your system includes a development package for mozjs, we
 recommend building it on JHBuild so that you can enable the debugging
 features. Add this to your JHBuild configuration file:
 ```python
-module_autogenargs['mozjs38'] = '--enable-debug'
+module_autogenargs['mozjs52'] = '--enable-debug'
 ```
 
-Make sure it is built first with `jhbuild build mozjs38`, otherwise
+Make sure it is built first with `jhbuild build mozjs52`, otherwise
 `jhbuild build gjs` will skip it if you have the system package
 installed.
 
@@ -36,9 +36,11 @@ mozjs, but you can grab them from your JHBuild copy of mozjs.
 After reaching a breakpoint in your program, type this to activate the
 pretty-printers:
 ```
-source ~/.cache/jhbuild/build/mozjs-38.0.0/js/src/shell/js-gdb.py
+source ~/.cache/jhbuild/build/mozjs-52.Y.Z/js/src/shell/js-gdb.py
 ```
 
+(replace `Y.Z` with mozjs's minor and micro version numbers)
+
 ## Checking Things More Thoroughly Before A Release ##
 
 ### Distcheck ###

From d368db9e9b68ea10e25f5ec56b863c9f00bc6b57 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 29 Aug 2017 23:19:02 -0700
Subject: [PATCH 111/154] arg: Avoid assigning out-of-range values

Assigning out-of-range values to variables of these types is undefined
behaviour, and was caught by UBSan on Clang.

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 gi/arg.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/gi/arg.cpp b/gi/arg.cpp
index b63d97b5..fe37b009 100644
--- a/gi/arg.cpp
+++ b/gi/arg.cpp
@@ -1405,7 +1405,7 @@ gjs_value_to_g_argument(JSContext      *context,
             wrong = true;
         if (i > G_MAXUINT32 || i < 0)
             out_of_range = true;
-        arg->v_uint32 = (guint32)i;
+        arg->v_uint32 = CLAMP(i, 0, G_MAXUINT32);
         break;
     }
 
@@ -1426,7 +1426,7 @@ gjs_value_to_g_argument(JSContext      *context,
         if (v < 0)
             out_of_range = true;
         /* XXX we fail with values close to G_MAXUINT64 */
-        arg->v_uint64 = v;
+        arg->v_uint64 = MAX(v, 0);
     }
         break;
 

From c8b0b6a85151adf71bcd97a2966d6afb55da225c Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Wed, 30 Aug 2017 13:29:52 -0700
Subject: [PATCH 112/154] build: Add LSan suppression file

Compiling with ASan also automatically enables LSan (leak sanitizer).
There is an intentional leak (of a few bytes) of GType structures in
GJS, and SpiderMonkey also leaks a few bytes for each GC helper thread.
Add a suppression file (unfortunately, a different format than
Valgrind's suppression file) to make LSan ignore these leaks.

One nice feature of LSan is that it prints a total of bytes leaked for
each suppressed function.

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 Makefile-test.am                | 2 ++
 installed-tests/extra/lsan.supp | 5 +++++
 2 files changed, 7 insertions(+)
 create mode 100644 installed-tests/extra/lsan.supp

diff --git a/Makefile-test.am b/Makefile-test.am
index cf6d3eb3..f2493bf9 100644
--- a/Makefile-test.am
+++ b/Makefile-test.am
@@ -264,6 +264,7 @@ EXTRA_DIST +=						\
 	installed-tests/js/testCairo.js			\
 	installed-tests/js/testGtk.js			\
 	installed-tests/js/testGDBus.js			\
+	installed-tests/extra/lsan.supp			\
 	$(NULL)
 
 ### TEST EXECUTION #####################################################
@@ -277,6 +278,7 @@ AM_TESTS_ENVIRONMENT =					\
 	export GI_TYPELIB_PATH="$(builddir):$${GI_TYPELIB_PATH:+:$$GI_TYPELIB_PATH}"; \
 	export LD_LIBRARY_PATH="$(builddir)/.libs:$${LD_LIBRARY_PATH:+:$$LD_LIBRARY_PATH}"; \
 	export G_FILENAME_ENCODING=latin1;		\
+	export LSAN_OPTIONS="suppressions=$(abs_top_srcdir)/installed-tests/extra/lsan.supp"; \
 	$(XVFB_START)					\
 	$(NULL)
 
diff --git a/installed-tests/extra/lsan.supp b/installed-tests/extra/lsan.supp
new file mode 100644
index 00000000..4eadd497
--- /dev/null
+++ b/installed-tests/extra/lsan.supp
@@ -0,0 +1,5 @@
+# SpiderMonkey leaks a mutex for each GC helper thread.
+leak:js::HelperThread::threadLoop
+
+# We leak a small wrapper in GJS for each registered GType.
+leak:gjs_gtype_create_gtype_wrapper

From 398c8a4625d6129350aabf791c32d2e5aba08c37 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Wed, 30 Aug 2017 13:34:28 -0700
Subject: [PATCH 113/154] build: Don't use the vptr sanitizer

SpiderMonkey compiles without runtime type information by default, and
the vptr sanitizer (part of UBSan) is not compatible with that. This
caused too many false positives to be useful.

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 configure.ac | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/configure.ac b/configure.ac
index 431c5c44..18b744a1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -232,9 +232,9 @@ AC_ARG_ENABLE([ubsan],
   [AS_HELP_STRING([--enable-ubsan], [Build with undefined behavior sanitizer support @<:@default: no@:>@])])
 
 AS_IF([test "x$enable_ubsan" = "xyes"], [
-  AX_CHECK_COMPILE_FLAG([-fsanitize=undefined -fno-omit-frame-pointer -g], [
-    AX_CHECK_LINK_FLAG([-fsanitize=undefined],
-      [SAN_FLAGS="$SAN_FLAGS -fsanitize=undefined"])
+  AX_CHECK_COMPILE_FLAG([-fsanitize=undefined -fno-sanitize=vptr -fno-omit-frame-pointer -g], [
+    AX_CHECK_LINK_FLAG([-fsanitize=undefined -fno-sanitize=vptr],
+      [SAN_FLAGS="$SAN_FLAGS -fsanitize=undefined -fno-sanitize=vptr"])
   ])
 ])
 

From 81dc307547ca01a096da54ad598ce128ef8b2ab6 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Wed, 30 Aug 2017 13:36:51 -0700
Subject: [PATCH 114/154] arg: Avoid taking abs() of -2^63

It's undefined behaviour to call abs() on (int64_t)(-2^63) because 2^63
can't be stored in an int64_t. Add a special case for this value.

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 gi/arg.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/gi/arg.cpp b/gi/arg.cpp
index fe37b009..27c7036e 100644
--- a/gi/arg.cpp
+++ b/gi/arg.cpp
@@ -2623,7 +2623,8 @@ gjs_value_from_g_argument (JSContext             *context,
         break;
 
     case GI_TYPE_TAG_INT64:
-        if (std::abs(arg->v_int64) > MAX_SAFE_INT64)
+        if (arg->v_int64 == G_MININT64 ||
+            std::abs(arg->v_int64) > MAX_SAFE_INT64)
             g_warning("Value %" G_GINT64_FORMAT " cannot be safely stored in "
                       "a JS Number and may be rounded", arg->v_int64);
         value_p.setNumber(static_cast<double>(arg->v_int64));

From 3f57423776f57da3a289e6c4b3a55c5a577560a6 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Thu, 31 Aug 2017 15:06:45 -0700
Subject: [PATCH 116/154] tests: Suppress message about too-big integer

In case of running the tests with fatal criticals, this should not abort
the test, because it's expected.

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 installed-tests/js/testEverythingBasic.js | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/installed-tests/js/testEverythingBasic.js b/installed-tests/js/testEverythingBasic.js
index 3b198456..ad6dd266 100644
--- a/installed-tests/js/testEverythingBasic.js
+++ b/installed-tests/js/testEverythingBasic.js
@@ -85,8 +85,17 @@ describe('Life, the Universe and Everything', function () {
         function run_test(bytes, limit, method_stem) {
             if(skip[limit + bytes])
                 pending("This test doesn't work");
+
+            if (bytes === '64')
+                GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+                    "*cannot be safely stored*");
+
             let val = Limits[bytes][limit];
             expect(Regress[method_stem + bytes](val)).toBe(val);
+
+            if (bytes === '64')
+                GLib.test_assert_expected_messages_internal('Gjs',
+                    'testEverythingBasic.js', 0, 'Ignore message');
         }
         ['8', '16', '32', '64'].forEach(bytes => {
             it('marshals max value of unsigned ' + bytes + '-bit integers', function () {

From b8cb644f59a4dba65abdf8dac9f25d09541197b2 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Thu, 31 Aug 2017 15:08:46 -0700
Subject: [PATCH 117/154] main: Use g_option_context_parse_strv()

Using g_option_context_parse() on anything but the main function's argc
and argv will leak memory. Instead, use g_option_context_parse_strv()
which is intended for use with GStrv-style allocated arrays.

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 cjs/console.cpp | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/cjs/console.cpp b/cjs/console.cpp
index ee73c7af..d3cfcac1 100644
--- a/cjs/console.cpp
+++ b/cjs/console.cpp
@@ -99,7 +99,7 @@ check_script_args_for_stray_gjs_args(int           argc,
         { NULL }
     };
     char **argv_copy = g_new(char *, argc + 2);
-    int ix, argc_copy = argc + 1;
+    int ix;
 
     argv_copy[0] = g_strdup("dummy"); /* Fake argv[0] for GOptionContext */
     for (ix = 0; ix < argc; ix++)
@@ -110,9 +110,10 @@ check_script_args_for_stray_gjs_args(int           argc,
     g_option_context_set_ignore_unknown_options(script_options, true);
     g_option_context_set_help_enabled(script_options, false);
     g_option_context_add_main_entries(script_options, script_check_entries, NULL);
-    if (!g_option_context_parse(script_options, &argc_copy, &argv_copy, &error)) {
+    if (!g_option_context_parse_strv(script_options, &argv_copy, &error)) {
         g_warning("Scanning script arguments failed: %s", error->message);
         g_error_free(error);
+        g_strfreev(argv_copy);
         return;
     }
 
@@ -158,7 +159,7 @@ main(int argc, char **argv)
     const char *filename;
     const char *program_name;
     gsize len;
-    int code, argc_copy = argc, gjs_argc = argc, script_argc, ix;
+    int code, gjs_argc = argc, script_argc, ix;
     char **argv_copy = g_strdupv(argv), **argv_copy_addr = argv_copy;
     char **gjs_argv, **gjs_argv_addr;
     char * const *script_argv;
@@ -173,10 +174,11 @@ main(int argc, char **argv)
     g_option_context_set_help_enabled(context, false);
 
     g_option_context_add_main_entries(context, entries, NULL);
-    if (!g_option_context_parse(context, &argc_copy, &argv_copy, &error))
+    if (!g_option_context_parse_strv(context, &argv_copy, &error))
         g_error("option parsing failed: %s", error->message);
 
     /* Split options so we pass unknown ones through to the JS script */
+    int argc_copy = g_strv_length(argv_copy);
     for (ix = 1; ix < argc; ix++) {
         /* Check if a file was given and split after it */
         if (argc_copy >= 2 && strcmp(argv[ix], argv_copy[1]) == 0) {
@@ -205,7 +207,7 @@ main(int argc, char **argv)
     print_version = false;
     g_option_context_set_ignore_unknown_options(context, false);
     g_option_context_set_help_enabled(context, true);
-    if (!g_option_context_parse(context, &gjs_argc, &gjs_argv, &error))
+    if (!g_option_context_parse_strv(context, &gjs_argv, &error))
         g_error("option parsing failed: %s", error->message);
 
     g_option_context_free (context);
@@ -215,6 +217,7 @@ main(int argc, char **argv)
         exit(0);
     }
 
+    gjs_argc = g_strv_length(gjs_argv);
     if (command != NULL) {
         script = command;
         len = strlen(script);

From 1dd13c3e2f3b4d0396aa8401f8edd06a07b68d38 Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 23:22:39 -0500
Subject: [PATCH 118/154] build: Put dbus-run-session in AM_TESTS_ENVIRONMENT

This makes the makefile simpler, and also fixes an inadvertently broken
combination of code coverage plus running tests under Xvfb.

This is needed for enabling Valgrind test runs with AX_VALGRIND_CHECK.

https://bugzilla.gnome.org/show_bug.cgi?id=786995

Based on https://github.com/GNOME/gjs/commit/531d33ae169aee22637f29212ba1efe13ad63ab1
---
 Makefile-test.am | 34 +++++++++++++++++++---------------
 1 file changed, 19 insertions(+), 15 deletions(-)

diff --git a/Makefile-test.am b/Makefile-test.am
index f2493bf9..37c42e54 100644
--- a/Makefile-test.am
+++ b/Makefile-test.am
@@ -269,6 +269,21 @@ EXTRA_DIST +=						\
 
 ### TEST EXECUTION #####################################################
 
+if DBUS_TESTS
+DBUS_SESSION_COMMAND = $(DBUS_RUN_SESSION) --config-file=$(srcdir)/test/test-bus.conf --
+else
+DBUS_SESSION_COMMAND =
+endif
+
+if CODE_COVERAGE_ENABLED
+COVERAGE_TESTS_ENVIRONMENT = 						\
+	export GJS_UNIT_COVERAGE_OUTPUT=lcov;				\
+	export GJS_UNIT_COVERAGE_PREFIX=resource:///org/gnome/gjs/;	\
+	$(NULL)
+else
+COVERAGE_TESTS_ENVIRONMENT =
+endif
+
 # GJS_PATH is empty here since we want to force the use of our own
 # resources. G_FILENAME_ENCODING ensures filenames are not UTF-8.
 AM_TESTS_ENVIRONMENT =					\
@@ -279,7 +294,9 @@ AM_TESTS_ENVIRONMENT =					\
 	export LD_LIBRARY_PATH="$(builddir)/.libs:$${LD_LIBRARY_PATH:+:$$LD_LIBRARY_PATH}"; \
 	export G_FILENAME_ENCODING=latin1;		\
 	export LSAN_OPTIONS="suppressions=$(abs_top_srcdir)/installed-tests/extra/lsan.supp"; \
+	$(COVERAGE_TESTS_ENVIRONMENT)			\
 	$(XVFB_START)					\
+	$(DBUS_SESSION_COMMAND)				\
 	$(NULL)
 
 simple_tests =						\
@@ -297,25 +314,12 @@ TESTS =				\
 TEST_EXTENSIONS = .js
 
 LOG_DRIVER = env AM_TAP_AWK='$(AWK)' $(SHELL) $(top_srcdir)/tap-driver.sh
-JS_LOG_DRIVER = env AM_TAP_AWK='$(AWK)' $(SHELL) $(top_srcdir)/tap-driver.sh
-
-if DBUS_TESTS
-LOG_COMPILER = $(DBUS_RUN_SESSION)
-AM_LOG_FLAGS = --config-file=$(srcdir)/test/test-bus.conf -- $(top_srcdir)/test/run-test
-JS_LOG_COMPILER = $(DBUS_RUN_SESSION)
-AM_JS_LOG_FLAGS = --config-file=$(srcdir)/test/test-bus.conf -- $(top_builddir)/minijasmine
-else
 LOG_COMPILER = $(top_srcdir)/test/run-test
 AM_LOG_FLAGS =
+
+JS_LOG_DRIVER = $(LOG_DRIVER)
 JS_LOG_COMPILER = $(top_builddir)/minijasmine
 AM_JS_LOG_FLAGS =
-endif !DBUS_TESTS
-
-if CODE_COVERAGE_ENABLED
-AM_TESTS_ENVIRONMENT += 						\
-	export GJS_UNIT_COVERAGE_OUTPUT=lcov;				\
-	export GJS_UNIT_COVERAGE_PREFIX=resource:///org/gnome/gjs/;	\
-	$(NULL)
 
 CODE_COVERAGE_IGNORE_PATTERN = */{include,mfbt,gjs/test,gjs/installed-tests}/*
 CODE_COVERAGE_GENHTML_OPTIONS = 			\

From 882707fc5aa517abf78f92b300701f0b3eb4be0f Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 13 Sep 2017 23:24:01 -0500
Subject: [PATCH 119/154] build: Don't use LOG_COMPILER for shell scripts

Give all the tests started with shell scripts their own FOO_LOG_COMPILER
variable rather than using the common LOG_COMPILER one. This is because
AX_VALGRIND_CHECK will override LOG_COMPILER with a valgrind command, and
expect the test to be a binary, not a shell script. (Otherwise the shell
binary will be run under valgrind, not the test.)

https://bugzilla.gnome.org/show_bug.cgi?id=786995

Based on https://github.com/GNOME/gjs/commit/ded21f7a0ad1009b8ccd9f9f24c17f8a85f7a0d3
---
 Makefile-test.am | 25 ++++++++++++++-----------
 1 file changed, 14 insertions(+), 11 deletions(-)

diff --git a/Makefile-test.am b/Makefile-test.am
index 37c42e54..ecb8c82b 100644
--- a/Makefile-test.am
+++ b/Makefile-test.am
@@ -75,26 +75,27 @@ CLEANFILES +=						\
 
 ### TEST PROGRAMS ######################################################
 
-# gjs-tests checks private APIs and is run only uninstalled, on "make check".
+# gjs-tests.gtester checks private APIs and is run only uninstalled,
+# on "make check".
 #
 # jsunit checks public APIs using JS test scripts, and is run on "make check",
 # as well as installed if --enable-installed-tests is given at configure time.
 # See Makefile-insttest.am for the build rules installing the tests.
 
-check_PROGRAMS += gjs-tests minijasmine
+check_PROGRAMS += gjs-tests.gtester minijasmine
 
-gjs_tests_CPPFLAGS =				\
+gjs_tests_gtester_CPPFLAGS =			\
 	$(AM_CPPFLAGS)				\
 	-DGJS_COMPILATION			\
 	$(GJSTESTS_CFLAGS)			\
 	$(gjs_directory_defines)		\
 	-I$(top_srcdir)/test
 
-gjs_tests_LDADD =		\
+gjs_tests_gtester_LDADD =	\
 	libcjs.la		\
 	$(GJSTESTS_LIBS)
 
-gjs_tests_SOURCES =					\
+gjs_tests_gtester_SOURCES =				\
 	test/gjs-tests.cpp				\
 	test/gjs-test-utils.cpp				\
 	test/gjs-test-utils.h				\
@@ -104,7 +105,7 @@ gjs_tests_SOURCES =					\
 	mock-js-resources.c				\
 	$(NULL)
 
-gjs_tests_DEPENDENCIES =				\
+gjs_tests_gtester_DEPENDENCIES =			\
 	mock-cache-invalidation-before.gresource	\
 	mock-cache-invalidation-after.gresource		\
 	$(NULL)
@@ -306,20 +307,22 @@ simple_tests =						\
 EXTRA_DIST += $(simple_tests)
 
 TESTS =				\
-	gjs-tests		\
+	gjs-tests.gtester	\
 	$(simple_tests)		\
 	$(jasmine_tests)	\
 	$(NULL)
 
-TEST_EXTENSIONS = .js
+TEST_EXTENSIONS = .gtester .sh .js
 
 LOG_DRIVER = env AM_TAP_AWK='$(AWK)' $(SHELL) $(top_srcdir)/tap-driver.sh
-LOG_COMPILER = $(top_srcdir)/test/run-test
-AM_LOG_FLAGS =
+
+GTESTER_LOG_DRIVER = $(LOG_DRIVER)
+GTESTER_LOG_COMPILER = $(top_srcdir)/test/run-test
+
+SH_LOG_DRIVER = $(LOG_DRIVER)
 
 JS_LOG_DRIVER = $(LOG_DRIVER)
 JS_LOG_COMPILER = $(top_builddir)/minijasmine
-AM_JS_LOG_FLAGS =
 
 CODE_COVERAGE_IGNORE_PATTERN = */{include,mfbt,gjs/test,gjs/installed-tests}/*
 CODE_COVERAGE_GENHTML_OPTIONS = 			\

From a15f400f6f0dc370e1af105802dcfb4f367d8611 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 29 Aug 2017 23:20:41 -0700
Subject: [PATCH 120/154] object: Avoid taking address of empty vector

Given a std::vector<T> vec, &vec[0] is undefined behaviour when the
vector is empty. C++11 provides a vec.data() method which does the same
thing safely.

This is an opportunity for a small refactor; the free function didn't
actually free the vector, so it should be renamed "clear", and it can
just take in the vector instead of a pointer to the data. We can also
keep all the memory management of the vector in the same place, in
object_instance_init().

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 gi/object.cpp | 44 ++++++++++++++++++--------------------------
 1 file changed, 18 insertions(+), 26 deletions(-)

diff --git a/gi/object.cpp b/gi/object.cpp
index 3e1ae3ad..0ec8528b 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -874,19 +874,10 @@ object_instance_resolve(JSContext       *context,
     return true;
 }
 
-static void
-free_g_params(GParameter *params,
-              int         n_params)
-{
-    int i;
-
-    for (i = 0; i < n_params; ++i) {
-        g_value_unset(&params[i].value);
-    }
-}
-
 /* Set properties from args to constructor (argv[0] is supposed to be
  * a hash)
+ * The GParameter elements in the passed-in vector must be unset by the caller,
+ * regardless of the return value of this function.
  */
 static bool
 object_instance_props_to_g_parameters(JSContext                  *context,
@@ -902,7 +893,6 @@ object_instance_props_to_g_parameters(JSContext                  *context,
 
     if (!args[0].isObject()) {
         gjs_throw(context, "argument should be a hash with props to set");
-        free_g_params(&gparams[0], gparams.size());
         return false;
     }
 
@@ -912,7 +902,7 @@ object_instance_props_to_g_parameters(JSContext                  *context,
     JS::Rooted<JS::IdVector> ids(context, context);
     if (!JS_Enumerate(context, props, &ids)) {
         gjs_throw(context, "Failed to create property iterator for object props hash");
-        goto free_array_and_fail;
+        return false;
     }
 
     for (ix = 0, length = ids.length(); ix < length; ix++) {
@@ -923,12 +913,10 @@ object_instance_props_to_g_parameters(JSContext                  *context,
          * doesn't know that */
         prop_id = ids[ix];
 
-        if (!gjs_object_require_property(context, props, "property list", prop_id, &value)) {
-            goto free_array_and_fail;
-        }
-
-        if (!gjs_get_string_id(context, prop_id, &name))
-            goto free_array_and_fail;
+        if (!gjs_object_require_property(context, props, "property list",
+                                         prop_id, &value) ||
+            !gjs_get_string_id(context, prop_id, &name))
+            return false;
 
         switch (init_g_param_from_property(context, name,
                                            value,
@@ -940,7 +928,7 @@ object_instance_props_to_g_parameters(JSContext                  *context,
                       name.get(), g_type_name(gtype));
             /* fallthrough */
         case SOME_ERROR_OCCURRED:
-            goto free_array_and_fail;
+            return false;
         case VALUE_WAS_SET:
         default:
             break;
@@ -950,10 +938,6 @@ object_instance_props_to_g_parameters(JSContext                  *context,
     }
 
     return true;
-
- free_array_and_fail:
-    free_g_params(&gparams[0], gparams.size());
-    return false;
 }
 
 #define DEBUG_DISPOSE 0
@@ -1322,6 +1306,13 @@ disassociate_js_gobject(GObject *gobj)
     priv->js_object_finalized = true;
 }
 
+static void
+clear_g_params(std::vector<GParameter>& params)
+{
+    for (GParameter param : params)
+        g_value_unset(&param.value);
+}
+
 static bool
 object_instance_init (JSContext                  *context,
                       JS::MutableHandleObject     object,
@@ -1345,6 +1336,7 @@ object_instance_init (JSContext                  *context,
 
     if (!object_instance_props_to_g_parameters(context, object, args,
                                                gtype, params)) {
+        clear_g_params(params);
         return false;
     }
 
@@ -1357,10 +1349,10 @@ object_instance_init (JSContext                  *context,
     }
 
 G_GNUC_BEGIN_IGNORE_DEPRECATIONS
-    gobj = (GObject*) g_object_newv(gtype, params.size(), &params[0]);
+    gobj = (GObject*) g_object_newv(gtype, params.size(), params.data());
 G_GNUC_END_IGNORE_DEPRECATIONS
 
-    free_g_params(&params[0], params.size());
+    clear_g_params(params);
 
     ObjectInstance *other_priv = get_object_qdata(gobj);
     if (other_priv && other_priv->keep_alive != object.get()) {

From 615c6e5722e106d55aece3977019227e5f682543 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Wed, 30 Aug 2017 13:41:34 -0700
Subject: [PATCH 121/154] context: Avoid null pointer dereference

gjs_context_eval_file() was returning false but not setting the error
parameter if the file did not exist.

That check makes no sense anyway, since it is also done by
g_file_load_contents(). Therefore we remove it and take the opportunity
to refactor the function to use autoptrs.

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 cjs/context.cpp | 32 +++++++++-----------------------
 1 file changed, 9 insertions(+), 23 deletions(-)

diff --git a/cjs/context.cpp b/cjs/context.cpp
index 28a86798..29a4bdac 100644
--- a/cjs/context.cpp
+++ b/cjs/context.cpp
@@ -752,31 +752,17 @@ gjs_context_eval_file(GjsContext    *js_context,
                       int           *exit_status_p,
                       GError       **error)
 {
-    char     *script = NULL;
-    gsize    script_len;
-    bool ret = true;
+    char *script;
+    size_t script_len;
+    GjsAutoUnref<GFile> file = g_file_new_for_commandline_arg(filename);
 
-    GFile *file = g_file_new_for_commandline_arg(filename);
-
-    if (!g_file_query_exists(file, NULL)) {
-        ret = false;
-        goto out;
-    }
-
-    if (!g_file_load_contents(file, NULL, &script, &script_len, NULL, error)) {
-        ret = false;
-        goto out;
-    }
-
-    if (!gjs_context_eval(js_context, script, script_len, filename, exit_status_p, error)) {
-        ret = false;
-        goto out;
-    }
+    if (!g_file_load_contents(file, nullptr, &script, &script_len, nullptr,
+                              error))
+        return false;
+    GjsAutoChar script_ref = script;
 
-out:
-    g_free(script);
-    g_object_unref(file);
-    return ret;
+    return gjs_context_eval(js_context, script, script_len, filename,
+                            exit_status_p, error);
 }
 
 bool

From 2c2b51af648f8ebe8ac96283dff00327dee7919b Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Wed, 30 Aug 2017 14:50:10 -0700
Subject: [PATCH 122/154] build: Update Valgrind suppressions rules

The suppressions rules were out of date. They can also be simplified a
bit.

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 installed-tests/extra/gjs.supp | 192 ++++++++++++-----------------------------
 1 file changed, 55 insertions(+), 137 deletions(-)

diff --git a/installed-tests/extra/gjs.supp b/installed-tests/extra/gjs.supp
index 43f3a50a..32816a6b 100644
--- a/installed-tests/extra/gjs.supp
+++ b/installed-tests/extra/gjs.supp
@@ -1,167 +1,85 @@
-{
-   g_type_init_with_debug_flags calloc
-   Memcheck:Leak
-   fun:calloc
-   ...
-   fun:g_type_init_with_debug_flags
-   ...
-}
-
-{
-  g_type_add_interface_static malloc
-  Memcheck:Leak
-  fun:malloc
-  ...
-  fun:g_type_add_interface_static
-  ...
-}
-
-{
-  g_type_add_interface_dynamic malloc
-  Memcheck:Leak
-  fun:malloc
-  ...
-  fun:g_type_add_interface_dynamic
-  ...
-}
-
-{
-  g_type_class_ref malloc
-  Memcheck:Leak
-  fun:malloc
-  ...
-  fun:g_type_class_ref
-  ...
-}
-
-{
-  g_type_register_dynamic malloc
-  Memcheck:Leak
-  fun:malloc
-  ...
-  fun:g_type_register_dynamic
-  ...
-}
-
-{
-   g_type_init_with_debug_flags malloc
-   Memcheck:Leak
-   fun:malloc
-   ...
-   fun:g_type_init_with_debug_flags
-   ...
-}
-
-{
-   g_type_init_with_debug_flags realloc
-   Memcheck:Leak
-   fun:realloc
-   ...
-   fun:g_type_init_with_debug_flags
-   ...
-}
-
-{
-   g_test_add_vtable malloc
-   Memcheck:Leak
-   fun:malloc
-   ...
-   fun:g_test_add_vtable
-   ...
-}
+# Valgrind suppressions file for GJS
+# This is intended to be used in addition to GLib's glib.supp file.
 
-{
-   g_test_init
-   Memcheck:Leak
-   fun:malloc
-   ...
-   fun:g_test_init
-   ...
-}
+# We leak a small wrapper in GJS for each registered GType.
 
 {
-   g_type_register_static malloc
+   gtype-wrapper-new
    Memcheck:Leak
-   fun:malloc
-   ...
-   fun:g_type_register_static
-   ...
+   match-leak-kinds: definite
+   fun:_Znwm
+   fun:gjs_gtype_create_gtype_wrapper
 }
 
 {
-   g_type_register_static realloc
+   gtype-wrapper-qdata
    Memcheck:Leak
-   fun:realloc
-   ...
-   fun:g_type_register_static
+   match-leak-kinds: possible
    ...
+   fun:type_set_qdata_W
+   fun:g_type_set_qdata
+   fun:gjs_gtype_create_gtype_wrapper
 }
 
 {
    g_type_register_fundamental never freed
    Memcheck:Leak
-   fun:malloc
+   fun:calloc
    ...
    fun:g_type_register_fundamental
    ...
 }
 
+# SpiderMonkey leaks
+
 {
-   g_type_class_ref never finalized
+   mozjs-thread-stack-init
    Memcheck:Leak
+   match-leak-kinds: possible
    fun:calloc
-   fun:g_malloc0
-   fun:g_type_class_ref
-   ...
+   fun:allocate_dtv
+   fun:_dl_allocate_tls
+   fun:allocate_stack
+   fun:pthread_create@@GLIBC_2.2.5
+   fun:_ZN7mozilla9TimeStamp20ComputeProcessUptimeEv
+   fun:_ZN7mozilla9TimeStamp15ProcessCreationERb
+   fun:_ZN2JS6detail25InitWithFailureDiagnosticEb
+   fun:JS_Init
 }
 
 {
-   DBusGValue qdata
+   mozjs-thread-stack-new-context
    Memcheck:Leak
-   fun:realloc
-   fun:g_realloc
-   fun:g_type_set_qdata
-   fun:_dbus_g_value_types_init
-   ...
-}
-
-{
-   gettext conditional jump
-   Memcheck:Cond
-   fun:__GI___strcasecmp_l
-   fun:__gconv_open
-   fun:_nl_find_msg
-   fun:__dcigettext
-   ...
-}
-
-{
-   gettext uninitialized value
-   Memcheck:Value8
-   fun:__GI___strcasecmp_l
-   fun:__gconv_open
-   fun:_nl_find_msg
-   fun:__dcigettext
-   ...
-}
-
-{
-   font config invalid reads
-   Memcheck:Addr4
-   ...
-   fun:FcConfigParseAndLoad
-   ...
+   match-leak-kinds: possible
+   fun:calloc
+   fun:allocate_dtv
+   fun:_dl_allocate_tls
+   fun:allocate_stack
+   fun:pthread_create@@GLIBC_2.2.5
+   fun:_ZN2js6Thread6createEPFPvS1_ES1_
+   fun:init<void (&)(void*), js::HelperThread*>
+   fun:_ZN2js23GlobalHelperThreadState17ensureInitializedEv
+   fun:_ZN9JSRuntime4initEjj
+   fun:init
+   fun:NewContext
+   fun:_Z13JS_NewContextjjP9JSContext
 }
 
 {
-   dynamic loader conditional jump
-   Memcheck:Cond
-   fun:index
-   fun:expand_dynamic_string_token
-   fun:_dl_map_object
-   fun:map_doit
-   fun:_dl_catch_error
-   fun:do_preload
-   fun:dl_main
-   ...
+   mozjs-gc-helper-thread-mutex-guard
+   Memcheck:Leak
+   match-leak-kinds: definite
+   fun:malloc
+   fun:js_malloc
+   fun:js_new<mozilla::Vector<const js::Mutex*> >
+   fun:_ZN2js5Mutex14heldMutexStackEv.part.293
+   fun:heldMutexStack
+   fun:_ZN2js5Mutex4lockEv
+   fun:LockGuard
+   fun:_ZN2js25AutoLockHelperThreadStateC1EON7mozilla6detail19GuardObjectNotifierE
+   fun:_ZN2js12HelperThread10threadLoopEv
+   fun:callMain<0ul>
+   fun:_ZN2js6detail16ThreadTrampolineIRFvPvEJPNS_12HelperThreadEEE5StartES2_
+   fun:start_thread
+   fun:clone
 }

From 93e218eb1b349e15134f66e4f39be74dadb57559 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Wed, 30 Aug 2017 22:46:10 -0700
Subject: [PATCH 123/154] build: Valgrind with AX_VALGRIND_CHECK

This adds a "make check-valgrind" target which will run the test suite
under two Valgrind tools in succession: memcheck and helgrind. Requires
a bit of surgery on the shell script test runners, because
AX_VALGRIND_CHECK mainly assumes your tests are binaries.

The Valgrind tools drd and sgcheck are also available, but disabled by
default because they seem to crash on SpiderMonkey's threading.

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 Makefile-test.am                           | 10 +++++-
 configure.ac                               |  5 +++
 doc/Hacking.md                             | 19 +++++-------
 installed-tests/scripts/testCommandLine.sh | 50 +++++++++++++++---------------
 installed-tests/scripts/testWarnings.sh    |  8 ++---
 test/run-test                              |  2 +-
 6 files changed, 52 insertions(+), 42 deletions(-)

diff --git a/Makefile-test.am b/Makefile-test.am
index ecb8c82b..2211b0e6 100644
--- a/Makefile-test.am
+++ b/Makefile-test.am
@@ -265,11 +265,18 @@ EXTRA_DIST +=						\
 	installed-tests/js/testCairo.js			\
 	installed-tests/js/testGtk.js			\
 	installed-tests/js/testGDBus.js			\
+	installed-tests/extra/gjs.supp			\
 	installed-tests/extra/lsan.supp			\
 	$(NULL)
 
 ### TEST EXECUTION #####################################################
 
+@VALGRIND_CHECK_RULES@
+VALGRIND_SUPPRESSIONS_FILES = 				\
+	$(datadir)/glib-2.0/valgrind/glib.supp		\
+	$(top_srcdir)/installed-tests/extra/gjs.supp	\
+	$(NULL)
+
 if DBUS_TESTS
 DBUS_SESSION_COMMAND = $(DBUS_RUN_SESSION) --config-file=$(srcdir)/test/test-bus.conf --
 else
@@ -295,6 +302,7 @@ AM_TESTS_ENVIRONMENT =					\
 	export LD_LIBRARY_PATH="$(builddir)/.libs:$${LD_LIBRARY_PATH:+:$$LD_LIBRARY_PATH}"; \
 	export G_FILENAME_ENCODING=latin1;		\
 	export LSAN_OPTIONS="suppressions=$(abs_top_srcdir)/installed-tests/extra/lsan.supp"; \
+	export NO_AT_BRIDGE=1;				\
 	$(COVERAGE_TESTS_ENVIRONMENT)			\
 	$(XVFB_START)					\
 	$(DBUS_SESSION_COMMAND)				\
@@ -322,7 +330,7 @@ GTESTER_LOG_COMPILER = $(top_srcdir)/test/run-test
 SH_LOG_DRIVER = $(LOG_DRIVER)
 
 JS_LOG_DRIVER = $(LOG_DRIVER)
-JS_LOG_COMPILER = $(top_builddir)/minijasmine
+JS_LOG_COMPILER = $$LOG_COMPILER $$LOG_FLAGS $(top_builddir)/minijasmine
 
 CODE_COVERAGE_IGNORE_PATTERN = */{include,mfbt,gjs/test,gjs/installed-tests}/*
 CODE_COVERAGE_GENHTML_OPTIONS = 			\
diff --git a/configure.ac b/configure.ac
index 18b744a1..fa04c78e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -55,6 +55,11 @@ AX_CHECK_LINK_FLAG([-lgcov],, [
 	CODE_COVERAGE_LDFLAGS=
 ])
 
+AX_VALGRIND_DFLT([drd], [off])
+AX_VALGRIND_DFLT([sgcheck], [off])
+# DRD and sgcheck don't produce useful diagnostics at this time
+AX_VALGRIND_CHECK
+
 # Checks for libraries.
 m4_define(glib_required_version, 2.42.0)
 
diff --git a/doc/Hacking.md b/doc/Hacking.md
index 51c18c00..2987b221 100644
--- a/doc/Hacking.md
+++ b/doc/Hacking.md
@@ -75,22 +75,19 @@ not being updated after GC moved it.
 ### Valgrind ###
 
 Valgrind catches memory leak errors in the C++ code.
-It's a good idea to run the test suite under Valgrind every once in a
-while.
+It's a good idea to run the test suite under Valgrind before each
+release.
 
-Download the Valgrind false-positive suppression file from GLib:
+To run the test suite under a succession of Valgrind tools:
 ```sh
-wget https://git.gnome.org/browse/glib/plain/glib.supp
+jhbuild make check-valgrind
 ```
 
-Run the test suite:
-```sh
-jhbuild shell
-cd ~/.cache/jhbuild/build/gjs
-G_DEBUG=gc-friendly G_SLICE=always-malloc ./libtool --mode=execute valgrind --leak-check=yes --suppressions=/path/to/glib.supp ./gjs-tests
-```
+The logs from each run will be in `~/.cache/jhbuild/build/gjs/test-suite-<toolname>.log`, where `<toolname>` is `drd`, `helgrind`, `memcheck`, and `sgcheck`.
 
-(And a similar command to run each `minijasmine` test.)
+Note that LeakSanitizer, part of ASan (see below) can catch many, but
+not all, errors that Valgrind can catch.
+LSan executes faster than Valgrind, however.
 
 ### Static Code Analysis ###
 
diff --git a/installed-tests/scripts/testCommandLine.sh b/installed-tests/scripts/testCommandLine.sh
index 74ce17d9..df9c6e6c 100755
--- a/installed-tests/scripts/testCommandLine.sh
+++ b/installed-tests/scripts/testCommandLine.sh
@@ -1,9 +1,9 @@
 #!/bin/sh
 
 if test "$GJS_USE_UNINSTALLED_FILES" = "1"; then
-    gjs="$TOP_BUILDDIR/gjs-console"
+    gjs="$LOG_COMPILER $LOG_FLAGS $TOP_BUILDDIR/gjs-console"
 else
-    gjs="gjs-console"
+    gjs="$LOG_COMPILER $LOG_FLAGS gjs-console"
 fi
 
 # This JS script should exit immediately with code 42. If that is not working,
@@ -73,52 +73,52 @@ report_xfail () {
 }
 
 # Test that System.exit() works in gjs-console
-"$gjs" -c 'imports.system.exit(0)'
+$gjs -c 'imports.system.exit(0)'
 report "System.exit(0) should exit successfully"
-"$gjs" -c 'imports.system.exit(42)'
+$gjs -c 'imports.system.exit(42)'
 test $? -eq 42
 report "System.exit(42) should exit with the correct exit code"
 
 # FIXME: should check -eq 42 specifically, but in debug mode we will be
 # hitting an assertion
-"$gjs" exit.js
+$gjs exit.js
 test $? -ne 0
 report "System.exit() should still exit across an FFI boundary"
 
 # gjs --help prints GJS help
-"$gjs" --help >/dev/null
+$gjs --help >/dev/null
 report "--help should succeed"
-test -n "$("$gjs" --help)"
+test -n "$($gjs --help)"
 report "--help should print something"
 
 # print GJS help even if it's not the first argument
-"$gjs" -I . --help >/dev/null
+$gjs -I . --help >/dev/null
 report "should succeed when --help is not first arg"
-test -n "$("$gjs" -I . --help)"
+test -n "$($gjs -I . --help)"
 report "should print something when --help is not first arg"
 
 # --help before a script file name prints GJS help
-"$gjs" --help help.js >/dev/null
+$gjs --help help.js >/dev/null
 report "--help should succeed before a script file"
-test -n "$("$gjs" --help help.js)"
+test -n "$($gjs --help help.js)"
 report "--help should print something before a script file"
 
 # --help before a -c argument prints GJS help
 script='imports.system.exit(1)'
-"$gjs" --help -c "$script" >/dev/null
+$gjs --help -c "$script" >/dev/null
 report "--help should succeed before -c"
-test -n "$("$gjs" --help -c "$script")"
+test -n "$($gjs --help -c "$script")"
 report "--help should print something before -c"
 
 # --help after a script file name is passed to the script
-"$gjs" -I sentinel help.js --help
+$gjs -I sentinel help.js --help
 report "--help after script file should be passed to script"
 test -z "$("$gjs" -I sentinel help.js --help)"
 report "--help after script file should not print anything"
 
 # --help after a -c argument is passed to the script
 script='if(ARGV[0] !== "--help") imports.system.exit(1)'
-"$gjs" -c "$script" --help
+$gjs -c "$script" --help
 report "--help after -c should be passed to script"
 test -z "$("$gjs" -c "$script" --help)"
 report "--help after -c should not print anything"
@@ -128,29 +128,29 @@ report "--help after -c should not print anything"
 # "$gjs" help.js --help -I sentinel
 # report_xfail "-I after script file should not be added to search path"
 # fi
-"$gjs" help.js --help -I sentinel 2>&1 | grep -q 'Gjs-WARNING.*--include-path'
+$gjs help.js --help -I sentinel 2>&1 | grep -q 'Gjs-WARNING.*--include-path'
 report "-I after script should succeed but give a warning"
-"$gjs" -c 'imports.system.exit(0)' --coverage-prefix=foo --coverage-output=foo 2>&1 | grep -q 'Gjs-WARNING.*--coverage-prefix'
+$gjs -c 'imports.system.exit(0)' --coverage-prefix=foo --coverage-output=foo 2>&1 | grep -q 'Gjs-WARNING.*--coverage-prefix'
 report "--coverage-prefix after script should succeed but give a warning"
-"$gjs" -c 'imports.system.exit(0)' --coverage-prefix=foo --coverage-output=foo 2>&1 | grep -q 'Gjs-WARNING.*--coverage-output'
+$gjs -c 'imports.system.exit(0)' --coverage-prefix=foo --coverage-output=foo 2>&1 | grep -q 'Gjs-WARNING.*--coverage-output'
 report "--coverage-output after script should succeed but give a warning"
 rm -f foo/coverage.lcov
 
 # --version works
-"$gjs" --version >/dev/null
+$gjs --version >/dev/null
 report "--version should work"
-test -n "$("$gjs" --version)"
+test -n "$($gjs --version)"
 report "--version should print something"
 
 # --version after a script goes to the script
 script='if(ARGV[0] !== "--version") imports.system.exit(1)'
-"$gjs" -c "$script" --version
+$gjs -c "$script" --version
 report "--version after -c should be passed to script"
-test -z "$("$gjs" -c "$script" --version)"
+test -z "$($gjs -c "$script" --version)"
 report "--version after -c should not print anything"
 
 # interpreter handles queued promise jobs correctly
-output=$("$gjs" promise.js)
+output=$($gjs promise.js)
 test $? -eq 42
 report "interpreter should exit with the correct exit code from a queued promise job"
 test -n "$output" -a -z "${output##*Should be printed*}"
@@ -158,9 +158,9 @@ report "interpreter should run queued promise jobs before finishing"
 test -n "${output##*Should not be printed*}"
 report "interpreter should stop running jobs when one calls System.exit()"
 
-"$gjs" -c "Promise.resolve().then(() => { throw new Error(); });" 2>&1 | grep -q 'Gjs-WARNING.*Unhandled promise rejection.*[sS]tack trace'
+$gjs -c "Promise.resolve().then(() => { throw new Error(); });" 2>&1 | grep -q 'Gjs-WARNING.*Unhandled promise rejection.*[sS]tack trace'
 report "unhandled promise rejection should be reported"
-test -z $("$gjs" awaitcatch.js)
+test -z $($gjs awaitcatch.js)
 report "catching an await expression should not cause unhandled rejection"
 
 rm -f exit.js help.js promise.js awaitcatch.js
diff --git a/installed-tests/scripts/testWarnings.sh b/installed-tests/scripts/testWarnings.sh
index ebf3143c..804cfb6e 100755
--- a/installed-tests/scripts/testWarnings.sh
+++ b/installed-tests/scripts/testWarnings.sh
@@ -1,9 +1,9 @@
 #!/bin/sh
 
 if test "$GJS_USE_UNINSTALLED_FILES" = "1"; then
-    gjs="$TOP_BUILDDIR/gjs-console"
+    gjs="$LOG_COMPILER $LOG_FLAGS $TOP_BUILDDIR/gjs-console"
 else
-    gjs="gjs-console"
+    gjs="$LOG_COMPILER $LOG_FLAGS gjs-console"
 fi
 
 total=0
@@ -18,11 +18,11 @@ report () {
     fi
 }
 
-"$gjs" -c 'imports.signals.addSignalMethods({connect: "foo"})' 2>&1 | \
+$gjs -c 'imports.signals.addSignalMethods({connect: "foo"})' 2>&1 | \
     grep -q 'addSignalMethods is replacing existing .* connect method'
 report "overwriting method with Signals.addSignalMethods() should warn"
 
-"$gjs" -c 'imports.gi.GLib.get_home_dir("foobar")' 2>&1 | \
+$gjs -c 'imports.gi.GLib.get_home_dir("foobar")' 2>&1 | \
     grep -q 'Too many arguments to .*: expected 0, got 1'
 report "passing too many arguments to a GI function should warn"
 
diff --git a/test/run-test b/test/run-test
index 028ffd3e..75f62cf6 100755
--- a/test/run-test
+++ b/test/run-test
@@ -6,4 +6,4 @@ if test -z "$1"; then
     exit 1
 fi
 
-"$1" --tap --keep-going --verbose
+$LOG_COMPILER $LOG_FLAGS "$1" --tap --keep-going --verbose

From b88dfb454131ea4ea5c0e423750423ab1d297310 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Thu, 31 Aug 2017 17:30:50 -0700
Subject: [PATCH 124/154] maint: Add SpiderMonkey helgrind suppression rules

Helgrind detects all kinds of data races in SpiderMonkey's atomic
operations, but we can only assume that SpiderMonkey has got its atomic
operations working correctly; these are not races in GJS, in any case.

https://bugzilla.gnome.org/show_bug.cgi?id=786995
---
 installed-tests/extra/gjs.supp | 58 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 58 insertions(+)

diff --git a/installed-tests/extra/gjs.supp b/installed-tests/extra/gjs.supp
index 32816a6b..5f10734e 100644
--- a/installed-tests/extra/gjs.supp
+++ b/installed-tests/extra/gjs.supp
@@ -83,3 +83,61 @@
    fun:start_thread
    fun:clone
 }
+
+
+# SpiderMonkey data races
+
+# These are in SpiderMonkey's atomics / thread barrier stuff so presumably
+# locking is working correctly and helgrind just can't detect it?
+
+{
+   mozjs-helgrind-atomic-load-1
+   Helgrind:Race
+   fun:load
+   fun:load
+   fun:operator unsigned int
+}
+
+{
+   mozjs-helgrind-atomic-load-2
+   Helgrind:Race
+   fun:load
+   fun:load
+   fun:operator bool
+}
+
+{
+   mozjs-helgrind-atomic-store
+   Helgrind:Race
+   fun:store
+   fun:store
+   fun:operator=
+}
+
+# Presumably this one is OK since the function is called "thread safe"?!
+{
+   mozjs-helgrind-thread-safe-lookup
+   Helgrind:Race
+   ...
+   fun:lookup
+   fun:readonlyThreadsafeLookup
+   fun:readonlyThreadsafeLookup
+}
+
+{
+   mozjs-helgrind-jit-code
+   Helgrind:Race
+   obj:*
+   ...
+   fun:_ZL13EnterBaselineP9JSContextRN2js3jit12EnterJitDataE
+}
+
+{
+   mozjs-helgrind-probably-jit-code
+   Helgrind:Race
+   obj:*
+   obj:*
+   obj:*
+   obj:*
+   obj:*
+}

From 603dbc5b2e98ca446d026e90eb68dbc83386de6e Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Thu, 31 Aug 2017 21:32:00 -0700
Subject: [PATCH 125/154] tests: Split legacy Gtk.Widget tests out

This creates a new test file, testLegacyGtk.js, which is only run if the
GTK dependency is present.

https://bugzilla.gnome.org/show_bug.cgi?id=787113
---
 Makefile-test.am                        |   6 +-
 installed-tests/js/testLegacyGObject.js | 103 ------------------------------
 installed-tests/js/testLegacyGtk.js     | 108 ++++++++++++++++++++++++++++++++
 3 files changed, 113 insertions(+), 104 deletions(-)
 create mode 100644 installed-tests/js/testLegacyGtk.js

diff --git a/Makefile-test.am b/Makefile-test.am
index 2211b0e6..03578a8a 100644
--- a/Makefile-test.am
+++ b/Makefile-test.am
@@ -253,7 +253,10 @@ jasmine_tests += installed-tests/js/testGDBus.js
 endif
 
 if ENABLE_GTK
-jasmine_tests += installed-tests/js/testGtk.js
+jasmine_tests += 				\
+	installed-tests/js/testGtk.js		\
+	installed-tests/js/testLegacyGtk.js	\
+	$(NULL)
 endif
 
 if ENABLE_CAIRO
@@ -265,6 +268,7 @@ EXTRA_DIST +=						\
 	installed-tests/js/testCairo.js			\
 	installed-tests/js/testGtk.js			\
 	installed-tests/js/testGDBus.js			\
+	installed-tests/js/testLegacyGtk.js		\
 	installed-tests/extra/gjs.supp			\
 	installed-tests/extra/lsan.supp			\
 	$(NULL)
diff --git a/installed-tests/js/testLegacyGObject.js b/installed-tests/js/testLegacyGObject.js
index 39f0150e..38cd6ea2 100644
--- a/installed-tests/js/testLegacyGObject.js
+++ b/installed-tests/js/testLegacyGObject.js
@@ -1,7 +1,6 @@
 // -*- mode: js; indent-tabs-mode: nil -*-
 imports.gi.versions.Gtk = '3.0';
 
-const ByteArray = imports.byteArray;
 const Gio = imports.gi.Gio;
 const GLib = imports.gi.GLib;
 const GObject = imports.gi.GObject;
@@ -750,108 +749,6 @@ describe('GObject interface', function () {
     });
 });
 
-const template = ' \
-<interface> \
-  <template class="Gjs_MyComplexGtkSubclass" parent="GtkGrid"> \
-    <property name="margin_top">10</property> \
-    <property name="margin_bottom">10</property> \
-    <property name="margin_start">10</property> \
-    <property name="margin_end">10</property> \
-    <property name="visible">True</property> \
-    <child> \
-      <object class="GtkLabel" id="label-child"> \
-        <property name="label">Complex!</property> \
-        <property name="visible">True</property> \
-      </object> \
-    </child> \
-    <child> \
-      <object class="GtkLabel" id="label-child2"> \
-        <property name="label">Complex as well!</property> \
-        <property name="visible">True</property> \
-      </object> \
-    </child> \
-    <child> \
-      <object class="GtkLabel" id="internal-label-child"> \
-        <property name="label">Complex and internal!</property> \
-        <property name="visible">True</property> \
-      </object> \
-    </child> \
-  </template> \
-</interface>';
-
-const MyComplexGtkSubclass = new Lang.Class({
-    Name: 'MyComplexGtkSubclass',
-    Extends: Gtk.Grid,
-    Template: ByteArray.fromString(template),
-    Children: ['label-child', 'label-child2'],
-    InternalChildren: ['internal-label-child'],
-    CssName: 'complex-subclass',
-
-    testChildrenExist: function () {
-        this._internalLabel = this.get_template_child(MyComplexGtkSubclass, 'label-child');
-        expect(this._internalLabel).toEqual(jasmine.anything());
-
-        expect(this.label_child2).toEqual(jasmine.anything());
-        expect(this._internal_label_child).toEqual(jasmine.anything());
-    }
-});
-
-const MyComplexGtkSubclassFromResource = new Lang.Class({
-    Name: 'MyComplexGtkSubclassFromResource',
-    Extends: Gtk.Grid,
-    Template: 'resource:///org/gjs/jsunit/complex.ui',
-    Children: ['label-child', 'label-child2'],
-    InternalChildren: ['internal-label-child'],
-
-    testChildrenExist: function () {
-        expect(this.label_child).toEqual(jasmine.anything());
-        expect(this.label_child2).toEqual(jasmine.anything());
-        expect(this._internal_label_child).toEqual(jasmine.anything());
-    }
-});
-
-function validateTemplate(description, ClassName) {
-    describe(description, function () {
-        let win, content;
-        beforeEach(function () {
-            win = new Gtk.Window({ type: Gtk.WindowType.TOPLEVEL });
-            content = new ClassName();
-            win.add(content);
-        });
-
-        it('sets up internal and public template children', function () {
-            content.testChildrenExist();
-        });
-
-        it('sets up public template children with the correct widgets', function () {
-            expect(content.label_child.get_label()).toEqual('Complex!');
-            expect(content.label_child2.get_label()).toEqual('Complex as well!');
-        });
-
-        it('sets up internal template children with the correct widgets', function () {
-            expect(content._internal_label_child.get_label())
-                .toEqual('Complex and internal!');
-        });
-
-        afterEach(function () {
-            win.destroy();
-        });
-    });
-}
-
-describe('Legacy Gtk overrides', function () {
-    beforeAll(function () {
-        Gtk.init(null);
-    });
-
-    validateTemplate('UI template', MyComplexGtkSubclass);
-    validateTemplate('UI template from resource', MyComplexGtkSubclassFromResource);
-
-    it('sets CSS names on classes', function () {
-        expect(Gtk.Widget.get_css_name.call(MyComplexGtkSubclass)).toEqual('complex-subclass');
-    });
-});
-
 const LegacyInterface1 = new Lang.Interface({
     Name: 'LegacyInterface1',
     Requires: [GObject.Object],
diff --git a/installed-tests/js/testLegacyGtk.js b/installed-tests/js/testLegacyGtk.js
new file mode 100644
index 00000000..b812d297
--- /dev/null
+++ b/installed-tests/js/testLegacyGtk.js
@@ -0,0 +1,108 @@
+// -*- mode: js; indent-tabs-mode: nil -*-
+imports.gi.versions.Gtk = '3.0';
+
+const ByteArray = imports.byteArray;
+const Gtk = imports.gi.Gtk;
+const Lang = imports.lang;
+
+const template = `
+<interface>
+  <template class="Gjs_MyComplexGtkSubclass" parent="GtkGrid">
+    <property name="margin_top">10</property>
+    <property name="margin_bottom">10</property>
+    <property name="margin_start">10</property>
+    <property name="margin_end">10</property>
+    <property name="visible">True</property>
+    <child>
+      <object class="GtkLabel" id="label-child">
+        <property name="label">Complex!</property>
+        <property name="visible">True</property>
+      </object>
+    </child>
+    <child>
+      <object class="GtkLabel" id="label-child2">
+        <property name="label">Complex as well!</property>
+        <property name="visible">True</property>
+      </object>
+    </child>
+    <child>
+      <object class="GtkLabel" id="internal-label-child">
+        <property name="label">Complex and internal!</property>
+        <property name="visible">True</property>
+      </object>
+    </child>
+  </template>
+</interface>`;
+
+const MyComplexGtkSubclass = new Lang.Class({
+    Name: 'MyComplexGtkSubclass',
+    Extends: Gtk.Grid,
+    Template: ByteArray.fromString(template),
+    Children: ['label-child', 'label-child2'],
+    InternalChildren: ['internal-label-child'],
+    CssName: 'complex-subclass',
+
+    testChildrenExist: function () {
+        this._internalLabel = this.get_template_child(MyComplexGtkSubclass, 'label-child');
+        expect(this._internalLabel).toEqual(jasmine.anything());
+
+        expect(this.label_child2).toEqual(jasmine.anything());
+        expect(this._internal_label_child).toEqual(jasmine.anything());
+    }
+});
+
+const MyComplexGtkSubclassFromResource = new Lang.Class({
+    Name: 'MyComplexGtkSubclassFromResource',
+    Extends: Gtk.Grid,
+    Template: 'resource:///org/gjs/jsunit/complex.ui',
+    Children: ['label-child', 'label-child2'],
+    InternalChildren: ['internal-label-child'],
+
+    testChildrenExist: function () {
+        expect(this.label_child).toEqual(jasmine.anything());
+        expect(this.label_child2).toEqual(jasmine.anything());
+        expect(this._internal_label_child).toEqual(jasmine.anything());
+    }
+});
+
+function validateTemplate(description, ClassName) {
+    describe(description, function () {
+        let win, content;
+        beforeEach(function () {
+            win = new Gtk.Window({ type: Gtk.WindowType.TOPLEVEL });
+            content = new ClassName();
+            win.add(content);
+        });
+
+        it('sets up internal and public template children', function () {
+            content.testChildrenExist();
+        });
+
+        it('sets up public template children with the correct widgets', function () {
+            expect(content.label_child.get_label()).toEqual('Complex!');
+            expect(content.label_child2.get_label()).toEqual('Complex as well!');
+        });
+
+        it('sets up internal template children with the correct widgets', function () {
+            expect(content._internal_label_child.get_label())
+                .toEqual('Complex and internal!');
+        });
+
+        afterEach(function () {
+            win.destroy();
+        });
+    });
+}
+
+describe('Legacy Gtk overrides', function () {
+    beforeAll(function () {
+        Gtk.init(null);
+    });
+
+    validateTemplate('UI template', MyComplexGtkSubclass);
+    validateTemplate('UI template from resource', MyComplexGtkSubclassFromResource);
+
+    it('sets CSS names on classes', function () {
+        expect(Gtk.Widget.get_css_name.call(MyComplexGtkSubclass)).toEqual('complex-subclass');
+    });
+});

From 9a17ab35054c6129936b95b4706098cf7cd2fccc Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 6 Dec 2017 06:34:07 -0600
Subject: [PATCH 126/154] Revert freeing closures in idle handler

This turned out to cause a lot of problems; it has been responsible for
almost all of the crashes in gnome-shell since 1.48. We revert back to
the original code modulo a few improvements that have been made along the
way.

This state at least does not crash in the test suite, although it is
definitely not correct since it breaks SpiderMonkey's garbage collector
pre barrier verification mode (the reason the change was made in the
first place.) That still must be fixed using a different approach.

This partially reverts commits [41b78ae], [db3e387], [bace908],
[9eb4a2b], [2593d3d], and [334ba96].

https://bugzilla.gnome.org/show_bug.cgi?id=786668
---
 gi/closure.cpp | 1 -
 1 file changed, 1 deletion(-)

diff --git a/gi/closure.cpp b/gi/closure.cpp
index 3041cce4..993e06a0 100644
--- a/gi/closure.cpp
+++ b/gi/closure.cpp
@@ -166,7 +166,6 @@ closure_set_invalid(gpointer  data,
 {
     Closure *self = &((GjsClosure*) closure)->priv;
 
-    JS::ExposeObjectToActiveJS(self->obj);
     self->obj.reset();
     self->context = nullptr;
 

From 38943dcbb45a871d77d1f42f85d021941a81fc0e Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Tue, 22 Aug 2017 12:08:26 -0700
Subject: [PATCH 127/154] closure: Debug message on invalidate signal

We log a closure debug message in the other case where a closure is
invalidated, so we should do it here as well.

https://bugzilla.gnome.org/show_bug.cgi?id=786668
---
 gi/closure.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/gi/closure.cpp b/gi/closure.cpp
index 993e06a0..f641bb9d 100644
--- a/gi/closure.cpp
+++ b/gi/closure.cpp
@@ -166,6 +166,9 @@ closure_set_invalid(gpointer  data,
 {
     Closure *self = &((GjsClosure*) closure)->priv;
 
+    gjs_debug_closure("Invalidating signal closure %p which calls object %p",
+                      closure, self->obj.get());
+
     self->obj.reset();
     self->context = nullptr;
 

From b675ef12afc185604a75e8bdbbe8a3d6a18d3710 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Tue, 22 Aug 2017 12:10:12 -0700
Subject: [PATCH 128/154] object: Refactor out ConnectData

The ConnectData struct is not exactly needed; we can keep a list of
GClosure signal closures directly. The 'obj' member was only used in the
invalidate notifier, so we can pass that as the notifier callback data
instead of the ConnectData struct.

https://bugzilla.gnome.org/show_bug.cgi?id=786668
---
 gi/object.cpp | 34 +++++++++++-----------------------
 1 file changed, 11 insertions(+), 23 deletions(-)

diff --git a/gi/object.cpp b/gi/object.cpp
index 0ec8528b..8a6bd3f6 100644
--- a/gi/object.cpp
+++ b/gi/object.cpp
@@ -55,8 +55,6 @@
 #include <util/hash-x32.h>
 #include <girepository.h>
 
-typedef struct _ConnectData ConnectData;
-
 struct ObjectInstance {
     GIObjectInfo *info;
     GObject *gobj; /* NULL if we are the prototype and not an instance */
@@ -64,7 +62,7 @@ struct ObjectInstance {
     GType gtype;
 
     /* a list of all signal connections, used when tracing */
-    std::set<ConnectData *> signals;
+    std::set<GClosure *> signals;
 
     /* the GObjectClass wrapped by this JS Object (only used for
        prototypes) */
@@ -76,11 +74,6 @@ struct ObjectInstance {
     unsigned js_object_finalized : 1;
 };
 
-struct _ConnectData {
-    ObjectInstance *obj;
-    GClosure *closure;
-};
-
 static std::stack<JS::PersistentRootedObject> object_init_list;
 static GHashTable *class_init_properties;
 
@@ -1267,10 +1260,10 @@ invalidate_all_signals(ObjectInstance *priv)
      * invalidate notifier */
     while (!priv->signals.empty()) {
         /* This will also free cd, through the closure invalidation mechanism */
-        ConnectData *cd = *priv->signals.begin();
-        g_closure_invalidate(cd->closure);
+        GClosure *closure = *priv->signals.begin();
+        g_closure_invalidate(closure);
         /* Erase element if not already erased */
-        priv->signals.erase(cd);
+        priv->signals.erase(closure);
     }
 }
 
@@ -1446,8 +1439,8 @@ object_instance_trace(JSTracer *tracer,
     if (priv == NULL)
         return;
 
-    for (ConnectData *cd : priv->signals)
-        gjs_closure_trace(cd->closure, tracer);
+    for (GClosure *closure : priv->signals)
+        gjs_closure_trace(closure, tracer);
 
     for (auto vfunc : priv->vfuncs)
         vfunc->js_function.trace(tracer, "ObjectInstance::vfunc");
@@ -1457,10 +1450,8 @@ static void
 signal_connection_invalidated(void     *data,
                               GClosure *closure)
 {
-    auto cd = static_cast<ConnectData *>(data);
-
-    cd->obj->signals.erase(cd);
-    g_slice_free(ConnectData, cd);
+    auto priv = static_cast<ObjectInstance *>(data);
+    priv->signals.erase(closure);
 }
 
 static void
@@ -1635,7 +1626,6 @@ real_connect_func(JSContext *context,
     guint signal_id;
     GjsAutoJSChar signal_name(context);
     GQuark signal_detail;
-    ConnectData *connect_data;
 
     gjs_debug_gsignal("connect obj %p priv %p argc %d", obj.get(), priv, argc);
     if (priv == NULL) {
@@ -1674,12 +1664,10 @@ real_connect_func(JSContext *context,
     if (closure == NULL)
         return false;
 
-    connect_data = g_slice_new0(ConnectData);
-    priv->signals.insert(connect_data);
-    connect_data->obj = priv;
     /* This is a weak reference, and will be cleared when the closure is invalidated */
-    connect_data->closure = closure;
-    g_closure_add_invalidate_notifier(closure, connect_data, signal_connection_invalidated);
+    priv->signals.insert(closure);
+    g_closure_add_invalidate_notifier(closure, priv,
+                                      signal_connection_invalidated);
 
     id = g_signal_connect_closure_by_id(priv->gobj,
                                         signal_id,

From 3a610cea41cb905047af5c84e5d37b20a03bd80d Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 22 Aug 2017 22:58:56 -0700
Subject: [PATCH 129/154] closure: Prevent collection of invalidated closure

It's not possible to stop tracing an object in the middle of GC. However,
by using JS::ExposeObjectToActiveJS(), it is possible to mark an object
as reachable for the duration of one GC. This is exactly what we need for
closures, to keep the closure's callable object from disappearing while
GC is going on.

This requires adding a method, prevent_collection(), to GjsMaybeOwned.
This method is only valid in non-rooted mode. It also requires a bit of
GC API magic to avoid running afoul of some debug-mode assertions.
SpiderMonkey master at least has an official API for one of these bits of
magic, which we can switch to in SpiderMonkey 59.

https://bugzilla.gnome.org/show_bug.cgi?id=786668
---
 cjs/jsapi-util-root.h | 24 ++++++++++++++++++++++++
 gi/closure.cpp        |  1 +
 2 files changed, 25 insertions(+)

diff --git a/cjs/jsapi-util-root.h b/cjs/jsapi-util-root.h
index 31601441..1237057f 100644
--- a/cjs/jsapi-util-root.h
+++ b/cjs/jsapi-util-root.h
@@ -67,6 +67,7 @@
 template<typename T>
 struct GjsHeapOperation {
     static bool update_after_gc(JS::Heap<T> *location);
+    static void expose_to_js(JS::Heap<T>& thing);
 };
 
 template<>
@@ -77,6 +78,18 @@ struct GjsHeapOperation<JSObject *> {
         JS_UpdateWeakPointerAfterGC(location);
         return (location->unbarrieredGet() == nullptr);
     }
+
+    static void expose_to_js(JS::Heap<JSObject *>& thing) {
+        JSObject *obj = thing.unbarrieredGet();
+        /* If the object has been swept already, then the zone is nullptr */
+        if (!obj || !js::gc::detail::GetGCThingZone(uintptr_t(obj)))
+            return;
+        /* COMPAT: Use JS::CurrentThreadIsHeapCollecting() in mozjs59 */
+        JS::GCCellPtr ptr(obj, JS::TraceKind::Object);
+        JS::shadow::Runtime *rt = js::gc::detail::GetCellRuntime(ptr.asCell());
+        if (!rt->isHeapCollecting())
+            JS::ExposeObjectToActiveJS(obj);
+    }
 };
 
 template<>
@@ -249,6 +262,17 @@ class GjsMaybeOwned {
         m_heap = thing;
     }
 
+    /* Marks an object as reachable for one GC with ExposeObjectToActiveJS().
+     * Use to avoid stopping tracing an object during GC. This makes no sense
+     * in the rooted case. */
+    void
+    prevent_collection(void)
+    {
+        debug("prevent_collection()");
+        g_assert(!m_rooted);
+        GjsHeapOperation<T>::expose_to_js(m_heap);
+    }
+
     void
     reset(void)
     {
diff --git a/gi/closure.cpp b/gi/closure.cpp
index f641bb9d..1df01938 100644
--- a/gi/closure.cpp
+++ b/gi/closure.cpp
@@ -169,6 +169,7 @@ closure_set_invalid(gpointer  data,
     gjs_debug_closure("Invalidating signal closure %p which calls object %p",
                       closure, self->obj.get());
 
+    self->obj.prevent_collection();
     self->obj.reset();
     self->context = nullptr;
 

From dd7bfb25df39ca0d44db4e511be96e80d7eb5054 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Mon, 4 Sep 2017 15:43:38 -0700
Subject: [PATCH 130/154] release: Prepare for 1.49.92

---
 NEWS | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/NEWS b/NEWS
index 63b4ce2f..8cb486cb 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,27 @@
+Version 1.49.92
+---------------
+
+- It's now possible to build GJS with sanitizers (ASan and UBSan) enabled; add
+  "--enable-asan" and "--enable-ubsan" to your configure flags. This has
+  already caught some memory leaks.
+
+- There's also a "make check-valgrind" target which will run GJS's test suite
+  under Valgrind to catch memory leaks and threading races.
+
+- Many of the crashes in GNOME 3.24 were caused by GJS's closure invalidation
+  code which had to change from the known-working state in 1.46 because of
+  changes to SpiderMonkey's garbage collector. This code has been refactored to
+  be less complicated, which will hopefully improve stability and debuggability.
+
+- Closed bugs:
+
+  * Clean up the idle closure invalidation mess [#786668, Philip Chimento]
+  * Add ASan and UBSan to GJS [#783220, Claudio André]
+  * Run analysis tools on GJS to prepare for release [#786995, Philip Chimento]
+  * Fix testLegacyGObject importing the GTK overrides [#787113, Philip Chimento]
+
+- Docs tweak [Philip Chimento]
+
 1.49.91
 -------
 

From 6c87c2a1800b9bc9bf2049dec580bc3bc40371f5 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Mon, 11 Sep 2017 11:29:22 -0700
Subject: [PATCH 131/154] coverage: Correct licensing mistake

https://bugzilla.gnome.org/show_bug.cgi?id=787263
---
 cjs/coverage-internal.h    | 27 ++++++++++++++++-----------
 cjs/coverage.cpp           | 27 ++++++++++++++++-----------
 cjs/coverage.h             | 28 +++++++++++++++++-----------
 test/gjs-test-coverage.cpp | 27 ++++++++++++++++-----------
 test/gjs-test-utils.h      | 28 +++++++++++++++++-----------
 5 files changed, 82 insertions(+), 55 deletions(-)

diff --git a/cjs/coverage-internal.h b/cjs/coverage-internal.h
index 5f2b8a34..d26679d0 100644
--- a/cjs/coverage-internal.h
+++ b/cjs/coverage-internal.h
@@ -1,19 +1,24 @@
+/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; -*- */
 /*
  * Copyright © 2015 Endless Mobile, Inc.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
  *
  * Authored By: Sam Spilsbury <sam@endlessm.com>
  */
diff --git a/cjs/coverage.cpp b/cjs/coverage.cpp
index e6a80a59..d6bf2c6a 100644
--- a/cjs/coverage.cpp
+++ b/cjs/coverage.cpp
@@ -1,19 +1,24 @@
+/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; -*- */
 /*
  * Copyright © 2014 Endless Mobile, Inc.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
  *
  * Authored By: Sam Spilsbury <sam@endlessm.com>
  */
diff --git a/cjs/coverage.h b/cjs/coverage.h
index 358ba6f8..7bff1759 100644
--- a/cjs/coverage.h
+++ b/cjs/coverage.h
@@ -1,22 +1,28 @@
+/* -*- mode: C; c-basic-offset: 4; indent-tabs-mode: nil; -*- */
 /*
  * Copyright © 2014 Endless Mobile, Inc.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
  *
  * Authored By: Sam Spilsbury <sam@endlessm.com>
  */
+
 #ifndef _GJS_COVERAGE_H
 #define _GJS_COVERAGE_H
 
diff --git a/test/gjs-test-coverage.cpp b/test/gjs-test-coverage.cpp
index 535495d1..4ac3b776 100644
--- a/test/gjs-test-coverage.cpp
+++ b/test/gjs-test-coverage.cpp
@@ -1,19 +1,24 @@
+/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; -*- */
 /*
  * Copyright © 2014 Endless Mobile, Inc.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
  *
  * Authored By: Sam Spilsbury <sam@endlessm.com>
  */
diff --git a/test/gjs-test-utils.h b/test/gjs-test-utils.h
index b19f4c5b..7a2c8561 100644
--- a/test/gjs-test-utils.h
+++ b/test/gjs-test-utils.h
@@ -1,22 +1,28 @@
+/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; -*- */
 /*
  * Copyright © 2013 Endless Mobile, Inc.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
  *
  * Authored By: Sam Spilsbury <sam@endlessm.com>
  */
+
 #ifndef GJS_TEST_UTILS_H
 #define GJS_TEST_UTILS_H
 

From 4e4c55c8162e1b2b863ef37796b486c6133dff35 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Mon, 11 Sep 2017 11:43:08 -0700
Subject: [PATCH 132/154] release: Prepare for 1.50.0

---
 NEWS | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/NEWS b/NEWS
index 8cb486cb..20ef5f2d 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,12 @@
+Version 1.50.0
+--------------
+
+- Closed bugs:
+
+  * Relicense coverage.cpp and coverage.h to the same license as the rest of
+    GJS [#787263, Philip Chimento; thanks to Dominique Leuenberger for pointing
+    out the mistake]
+
 Version 1.49.92
 ---------------
 

From 0d340e17868a50e3c1eeed6399e53a09774bd5f1 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Thu, 7 Sep 2017 21:11:14 -0700
Subject: [PATCH 133/154] stack: Use js::DumpBacktrace() for gjs_dumpstack()

It would be nice to be able to print a JS stack even if the JS engine is
in the middle of a garbage collection. I have tested and
js::DumpBacktrace() can do this. The output format is slightly less nice
but that's OK because gjs_dumpstack() is only for debugging.

https://bugzilla.gnome.org/show_bug.cgi?id=786186
---
 cjs/stack.cpp   | 13 +------------
 gi/function.cpp |  6 +-----
 gi/value.cpp    |  6 +-----
 3 files changed, 3 insertions(+), 22 deletions(-)

diff --git a/cjs/stack.cpp b/cjs/stack.cpp
index f71f852a..c2c6c0f3 100644
--- a/cjs/stack.cpp
+++ b/cjs/stack.cpp
@@ -51,20 +51,9 @@ void
 gjs_context_print_stack_stderr(GjsContext *context)
 {
     JSContext *cx = (JSContext*) gjs_context_get_native_context(context);
-    JS::RootedObject frame(cx);
-    JS::AutoSaveExceptionState exc(cx);
-    GjsAutoChar stack;
 
     g_printerr("== Stack trace for context %p ==\n", context);
-
-    if (!JS::CaptureCurrentStack(cx, &frame) ||
-        !(stack = gjs_format_stack_trace(cx, frame))) {
-        g_printerr("No stack trace available\n");
-        exc.restore();
-        return;
-    }
-
-    g_printerr("%s\n", stack.get());
+    js::DumpBacktrace(cx, stderr);
 }
 
 void
diff --git a/gi/function.cpp b/gi/function.cpp
index 38831ab7..0d0d7520 100644
--- a/gi/function.cpp
+++ b/gi/function.cpp
@@ -197,11 +197,7 @@ gjs_callback_closure(ffi_cif *cif,
             g_critical("The offending callback was %s()%s.", name,
                        trampoline->is_vfunc ? ", a vfunc" : "");
         }
-        /* A gjs_dumpstack() would be nice here, but we can't,
-           because that works by creating a new Error object and
-           reading the stack property, which is the worst possible
-           idea during a GC session.
-        */
+        gjs_dumpstack();
         gjs_callback_trampoline_unref(trampoline);
         return;
     }
diff --git a/gi/value.cpp b/gi/value.cpp
index af04cf8c..5a52089d 100644
--- a/gi/value.cpp
+++ b/gi/value.cpp
@@ -154,11 +154,7 @@ closure_marshal(GClosure        *closure,
             g_critical("The offending signal was %s on %s %p.", signal_query.signal_name,
                        g_type_name(G_TYPE_FROM_INSTANCE(instance)), instance);
         }
-        /* A gjs_dumpstack() would be nice here, but we can't,
-           because that works by creating a new Error object and
-           reading the stack property, which is the worst possible
-           idea during a GC session.
-        */
+        gjs_dumpstack();
         return;
     }
 

From 0b088c2737202a96d16e181a421512017a28ab31 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Fri, 22 Sep 2017 22:52:49 -0700
Subject: [PATCH 134/154] coverage: Don't error out on various files

The coverage statistics should handle files with #! on the first line,
and ignore files with names within angle brackets, which is our
convention for scripts that are fed to the JS engine programmatically.

https://bugzilla.gnome.org/show_bug.cgi?id=788166
---
 installed-tests/js/testCoverage.js | 19 +++++++++++++++----
 modules/coverage.js                |  6 ++++++
 2 files changed, 21 insertions(+), 4 deletions(-)

diff --git a/installed-tests/js/testCoverage.js b/installed-tests/js/testCoverage.js
index 6d2b9263..9f761f13 100644
--- a/installed-tests/js/testCoverage.js
+++ b/installed-tests/js/testCoverage.js
@@ -1042,11 +1042,16 @@ describe('Coverage statistics container', function () {
                     "\n",
         'uncached': "function f() {\n" +
                     "    return 1;\n" +
-                    "}\n"
+                    '}\n',
+        'shebang': `#!/usr/bin/env gjs
+            function f() {}
+            `,
     };
 
     const MockFilenames = Object.keys(MockFiles).concat(['nonexistent']);
 
+    let container;
+
     beforeEach(function () {
         Coverage.getFileContents =
             jasmine.createSpy('getFileContents').and.callFake(f => MockFiles[f]);
@@ -1054,11 +1059,10 @@ describe('Coverage statistics container', function () {
             jasmine.createSpy('getFileChecksum').and.returnValue('abcd');
         Coverage.getFileModificationTime =
             jasmine.createSpy('getFileModificationTime').and.returnValue([1, 2]);
+        container = new Coverage.CoverageStatisticsContainer(MockFilenames);
     });
 
     it('fetches valid statistics for file', function () {
-        let container = new Coverage.CoverageStatisticsContainer(MockFilenames);
-
         let statistics = container.fetchStatistics('filename');
         expect(statistics).toBeDefined();
 
@@ -1067,10 +1071,17 @@ describe('Coverage statistics container', function () {
     });
 
     it('throws for nonexisting file', function () {
-        let container = new Coverage.CoverageStatisticsContainer(MockFilenames);
         expect(() => container.fetchStatistics('nonexistent')).toThrow();
     });
 
+    it('handles a shebang on line 1', function () {
+        expect(() => container.fetchStatistics('shebang')).not.toThrow();
+    });
+
+    it('ignores a file in angle brackets (our convention for programmatic scripts)', function () {
+        expect(() => container.fetchStatistics('<script>')).not.toThrow();
+    });
+
     const MockCache = '{ \
         "filename": { \
             "mtime": [1, 2], \
diff --git a/modules/coverage.js b/modules/coverage.js
index 0ed3407c..ff97f233 100644
--- a/modules/coverage.js
+++ b/modules/coverage.js
@@ -757,6 +757,9 @@ function _fetchCountersFromCache(filename, cache, nLines) {
 }
 
 function _fetchCountersFromReflection(filename, contents, nLines) {
+    // Shebang is illegal character sequence to JS parser
+    if (contents.startsWith('#!'))
+        contents = '//' + contents;
     let reflection = Reflect.parse(contents);
     let functions = functionsForAST(reflection);
 
@@ -795,6 +798,9 @@ function CoverageStatisticsContainer(prefixes, cache) {
     }
 
     function ensureStatisticsFor(filename) {
+        // Skip scripts fed to JS engine programmatically.
+        if (filename.startsWith('<') && filename.endsWith('>'))
+            return undefined;
         if (!coveredFiles[filename])
             coveredFiles[filename] = createStatisticsFor(filename);
         return coveredFiles[filename];

From 79c9777b7c62a87ada0b65d1d395a507abe38c32 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Fri, 22 Sep 2017 22:57:11 -0700
Subject: [PATCH 135/154] coverage: Scan ES6 classes for functions

Previously, class methods and property getters/setters were not counted
for coverage statistics.

https://bugzilla.gnome.org/show_bug.cgi?id=788166
---
 installed-tests/js/testCoverage.js | 72 ++++++++++++++++++++++++++++++++++++++
 modules/coverage.js                |  5 ++-
 2 files changed, 76 insertions(+), 1 deletion(-)

diff --git a/installed-tests/js/testCoverage.js b/installed-tests/js/testCoverage.js
index 9f761f13..379123bc 100644
--- a/installed-tests/js/testCoverage.js
+++ b/installed-tests/js/testCoverage.js
@@ -456,6 +456,78 @@ describe('Coverage.functionsForAST', function () {
                 { key: "(anonymous):2:0", line: 2, n_params: 0 }
             ],
         ],
+
+        'finds class methods': [
+            `class Foo {
+                bar() {}
+            }`,
+            [
+                { key: 'bar:2:0', line: 2, n_params: 0 },
+            ],
+        ],
+
+        'finds class property setters': [
+            `class Foo {
+                set bar(value) {}
+            }`,
+            [
+                { key: 'set bar:2:1', line: 2, n_params: 1 },
+            ],
+        ],
+
+        'finds class property getters': [
+            `class Foo {
+                get bar() {}
+            }`,
+            [
+                { key: 'get bar:2:0', line: 2, n_params: 0 },
+            ],
+        ],
+
+        'finds class constructors': [
+            `class Foo {
+                constructor(baz) {}
+            }`,
+            [
+                { key: 'Foo:2:1', line: 2, n_params: 1 },
+            ],
+        ],
+
+        'finds class expression methods': [
+            `void class {
+                baz() {}
+            }`,
+            [
+                { key: 'baz:2:0', line: 2, n_params: 0 },
+            ],
+        ],
+
+        'finds class expression property setters': [
+            `void class {
+                set baz(value) {}
+            }`,
+            [
+                { key: 'set baz:2:1', line: 2, n_params: 1 },
+            ],
+        ],
+
+        'finds class expression property getters': [
+            `void class {
+                get baz() {}
+            }`,
+            [
+                { key: 'get baz:2:0', line: 2, n_params: 0 },
+            ],
+        ],
+
+        'finds class expression constructors': [
+            `void class {
+                constructor(baz) {}
+            }`,
+            [
+                { key: '(anonymous):2:1', line: 2, n_params: 1 },
+            ],
+        ],
     };
 
     Object.keys(testTable).forEach(testcase => {
diff --git a/modules/coverage.js b/modules/coverage.js
index ff97f233..85e47b3d 100644
--- a/modules/coverage.js
+++ b/modules/coverage.js
@@ -31,6 +31,7 @@ function getSubNodesForNode(node) {
     case 'FunctionDeclaration':
     case 'FunctionExpression':
     case 'CatchClause':
+    case 'ClassMethod':
         subNodes.push(node.body);
         break;
     case 'LetStatement':
@@ -62,7 +63,9 @@ function getSubNodesForNode(node) {
         subNodes.push(node.left, node.right, node.body);
         break;
     case 'BlockStatement':
-        Array.prototype.push.apply(subNodes, node.body);
+    case 'ClassStatement':
+    case 'ClassExpression':
+        subNodes.push(...node.body);
         break;
     case 'ThrowStatement':
     case 'ReturnStatement':

From ddf5961e7f6bbbcd0235dce52270d24794f61606 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sat, 23 Sep 2017 11:55:21 -0700
Subject: [PATCH 136/154] coverage: Correct AST walking for labelled statements

The AST string constant for labelled statements uses the alternate
spelling 'LabeledStatement', so these were not getting scanned correctly.

https://bugzilla.gnome.org/show_bug.cgi?id=788166
---
 installed-tests/js/testCoverage.js | 8 ++++++++
 modules/coverage.js                | 4 ++--
 2 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/installed-tests/js/testCoverage.js b/installed-tests/js/testCoverage.js
index 379123bc..cb0281cc 100644
--- a/installed-tests/js/testCoverage.js
+++ b/installed-tests/js/testCoverage.js
@@ -528,6 +528,14 @@ describe('Coverage.functionsForAST', function () {
                 { key: '(anonymous):2:1', line: 2, n_params: 1 },
             ],
         ],
+
+        'finds functions inside labeled statement': [
+            `loop:
+            for (function () {}; ; ) {}`,
+            [
+                { key: '(anonymous):2:0', line: 2, n_params: 0 },
+            ],
+        ],
     };
 
     Object.keys(testTable).forEach(testcase => {
diff --git a/modules/coverage.js b/modules/coverage.js
index 85e47b3d..22a0eb90 100644
--- a/modules/coverage.js
+++ b/modules/coverage.js
@@ -26,7 +26,7 @@ function getSubNodesForNode(node) {
     let subNodes = [];
     switch (node.type) {
     /* These statements have a single body */
-    case 'LabelledStatement':
+    case 'LabeledStatement':
     case 'WithStatement':
     case 'FunctionDeclaration':
     case 'FunctionExpression':
@@ -282,7 +282,7 @@ function getBranchExitStartLine(branchBodyNode) {
         return -1;
     /* These types of statements are never executable */
     case 'EmptyStatement':
-    case 'LabelledStatement':
+    case 'LabeledStatement':
         return -1;
     default:
         break;

From 02c2f370f3591eb409a70af86c9329fa41ec03d1 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Fri, 22 Sep 2017 23:08:01 -0700
Subject: [PATCH 137/154] coverage: Walk AST in more cases

- The switch expression of a switch-case statement
- Default parameters to a function

https://bugzilla.gnome.org/show_bug.cgi?id=788166
---
 installed-tests/js/testCoverage.js | 23 +++++++++++++++++++++++
 modules/coverage.js                |  7 ++++---
 2 files changed, 27 insertions(+), 3 deletions(-)

diff --git a/installed-tests/js/testCoverage.js b/installed-tests/js/testCoverage.js
index cb0281cc..ca447e30 100644
--- a/installed-tests/js/testCoverage.js
+++ b/installed-tests/js/testCoverage.js
@@ -536,6 +536,29 @@ describe('Coverage.functionsForAST', function () {
                 { key: '(anonymous):2:0', line: 2, n_params: 0 },
             ],
         ],
+
+        'finds functions inside switch expression': [
+            'switch (function () {}) {}',
+            [
+                { key: '(anonymous):1:0', line: 1, n_params: 0 },
+            ],
+        ],
+
+        'finds functions inside function default arguments': [
+            'function foo(bar=function () {}) {}',
+            [
+                { key: 'foo:1:1', line: 1, n_params: 1 },
+                { key: '(anonymous):1:0', line: 1, n_params: 0 },
+            ],
+        ],
+
+        'finds functions inside function expression default arguments': [
+            'void function foo(bar=function () {}) {}',
+            [
+                { key: 'foo:1:1', line: 1, n_params: 1 },
+                { key: '(anonymous):1:0', line: 1, n_params: 0 },
+            ],
+        ],
     };
 
     Object.keys(testTable).forEach(testcase => {
diff --git a/modules/coverage.js b/modules/coverage.js
index 22a0eb90..6860d2ba 100644
--- a/modules/coverage.js
+++ b/modules/coverage.js
@@ -28,8 +28,6 @@ function getSubNodesForNode(node) {
     /* These statements have a single body */
     case 'LabeledStatement':
     case 'WithStatement':
-    case 'FunctionDeclaration':
-    case 'FunctionExpression':
     case 'CatchClause':
     case 'ClassMethod':
         subNodes.push(node.body);
@@ -95,8 +93,10 @@ function getSubNodesForNode(node) {
                 subNodes.push(elem);
         });
         break;
+    case 'FunctionDeclaration':
+    case 'FunctionExpression':
     case 'ArrowFunctionExpression':
-        Array.prototype.push.apply(subNodes, node.defaults);
+        subNodes.push(...node.defaults);
         subNodes.push(node.body);
         break;
     case 'SequenceExpression':
@@ -139,6 +139,7 @@ function getSubNodesForNode(node) {
             subNodes.push(node.finalizer);
         break;
     case 'SwitchStatement':
+        subNodes.push(node.discriminant);
         for (let caseClause of node.cases) {
             caseClause.consequent.forEach(function(expression) {
                 subNodes.push(expression);

From 7b0c3a93686504fd644c78b1cd5d53430d87276b Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Fri, 22 Sep 2017 23:37:28 -0700
Subject: [PATCH 138/154] tests: Create test ASTs by parsing JS

The previous approach of object literals as ASTs is not robust when
SpiderMonkey adds to or changes the AST structure that its parser
returns.

https://bugzilla.gnome.org/show_bug.cgi?id=788166
---
 installed-tests/js/testCoverage.js | 118 +++----------------------------------
 1 file changed, 8 insertions(+), 110 deletions(-)

diff --git a/installed-tests/js/testCoverage.js b/installed-tests/js/testCoverage.js
index ca447e30..8806dc77 100644
--- a/installed-tests/js/testCoverage.js
+++ b/installed-tests/js/testCoverage.js
@@ -827,55 +827,21 @@ describe('Coverage', function () {
     });
 
     it('function key from function with name matches schema', function () {
+        let ast = Reflect.parse('function f(a, b) {}').body[0];
         let functionKeyForFunctionName =
-            Coverage._getFunctionKeyFromReflectedFunction({
-                id: {
-                    name: 'f'
-                },
-                loc: {
-                  start: {
-                      line: 1
-                  }
-                },
-                params: ['a', 'b']
-            });
+            Coverage._getFunctionKeyFromReflectedFunction(ast);
         expect(functionKeyForFunctionName).toEqual('f:1:2');
     });
 
     it('function key from function without name is anonymous', function () {
+        let ast = Reflect.parse('\nvoid function (a, b, c) {}').body[0].expression.argument;
         let functionKeyForAnonymousFunction =
-            Coverage._getFunctionKeyFromReflectedFunction({
-                id: null,
-                loc: {
-                  start: {
-                      line: 2
-                  }
-                },
-                params: ['a', 'b', 'c']
-            });
+            Coverage._getFunctionKeyFromReflectedFunction(ast);
         expect(functionKeyForAnonymousFunction).toEqual('(anonymous):2:3');
     });
 
     it('returns a function counter map for function keys', function () {
-        let ast = {
-            body: [{
-                type: 'FunctionDeclaration',
-                id: {
-                    name: 'name'
-                },
-                loc: {
-                  start: {
-                      line: 1
-                  }
-                },
-                params: [],
-                body: {
-                    type: 'BlockStatement',
-                    body: []
-                }
-            }]
-        };
-
+        let ast = Reflect.parse('function name() {}');
         let detectedFunctions = Coverage.functionsForAST(ast);
         let functionCounters =
             Coverage._functionsToFunctionCounters('script', detectedFunctions);
@@ -884,40 +850,7 @@ describe('Coverage', function () {
 
     it('reports an error when two indistinguishable functions are present', function () {
         spyOn(window, 'log');
-        let ast = {
-            body: [{
-                type: 'FunctionDeclaration',
-                id: {
-                    name: '(anonymous)'
-                },
-                loc: {
-                  start: {
-                      line: 1
-                  }
-                },
-                params: [],
-                body: {
-                    type: 'BlockStatement',
-                    body: []
-                }
-            }, {
-                type: 'FunctionDeclaration',
-                id: {
-                    name: '(anonymous)'
-                },
-                loc: {
-                  start: {
-                      line: 1
-                  }
-                },
-                params: [],
-                body: {
-                    type: 'BlockStatement',
-                    body: []
-                }
-            }]
-        };
-
+        let ast = Reflect.parse('() => {}; () => {}');
         let detectedFunctions = Coverage.functionsForAST(ast);
         Coverage._functionsToFunctionCounters('script', detectedFunctions);
 
@@ -1031,25 +964,7 @@ describe('Coverage.incrementFunctionCounters', function () {
     });
 
     it('increments for function on earlier start line', function () {
-        let ast = {
-            body: [{
-                type: 'FunctionDeclaration',
-                id: {
-                    name: 'name'
-                },
-                loc: {
-                  start: {
-                      line: 1
-                  }
-                },
-                params: [],
-                body: {
-                    type: 'BlockStatement',
-                    body: []
-                }
-            }]
-        };
-
+        let ast = Reflect.parse('function name() {}');
         let detectedFunctions = Coverage.functionsForAST(ast);
         let knownFunctionsArray = Coverage._populateKnownFunctions(detectedFunctions, 3);
         let functionCounters = Coverage._functionsToFunctionCounters('script',
@@ -1063,24 +978,7 @@ describe('Coverage.incrementFunctionCounters', function () {
     });
 
     it('throws an error on unexpected function', function () {
-        let ast = {
-            body: [{
-                type: 'FunctionDeclaration',
-                id: {
-                    name: 'name'
-                },
-                loc: {
-                  start: {
-                      line: 1
-                  }
-                },
-                params: [],
-                body: {
-                    type: 'BlockStatement',
-                    body: []
-                }
-            }]
-        };
+        let ast = Reflect.parse('function name() {}');
         let detectedFunctions = Coverage.functionsForAST(ast);
         let knownFunctionsArray = Coverage._populateKnownFunctions(detectedFunctions, 3);
         let functionCounters = Coverage._functionsToFunctionCounters('script',

From e6972bee1a9d538fa4461e532522ce74fdc3f5e8 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sat, 23 Sep 2017 10:30:23 -0700
Subject: [PATCH 139/154] coverage: Don't count literals as executable

The AST type used to detect this is "Literal", previously it was given as
"LiteralExpression" which caused literals on their own line to be counted
as executable, but never executed during code coverage measurements.

Requires some changes in the tests, since there was some test data
assuming that literals were executable.

https://bugzilla.gnome.org/show_bug.cgi?id=788166
---
 installed-tests/js/testCoverage.js | 46 +++++++++++++++++++-------------------
 modules/coverage.js                |  2 +-
 2 files changed, 24 insertions(+), 24 deletions(-)

diff --git a/installed-tests/js/testCoverage.js b/installed-tests/js/testCoverage.js
index 8806dc77..547bb413 100644
--- a/installed-tests/js/testCoverage.js
+++ b/installed-tests/js/testCoverage.js
@@ -57,23 +57,23 @@ describe('Coverage.expressionLinesForAST', function () {
         ],
 
         'finds lines inside multiline function arguments': [
-            "function f(a, b, c) {\n" +
-            "}\n" +
-            "f(1,\n" +
-            "  2,\n" +
-            "  3);\n",
+            `function f(a, b, c) {
+            }
+            f(1,
+                2 + 3,
+                3 + 4);`,
             [1, 3, 4, 5],
         ],
 
         'finds lines inside function argument that is an object': [
-            "function f(o) {\n" +
-            "}\n" +
-            "let obj = {\n" +
-            "    Name: new f({ a: 1,\n" +
-            "                  b: 2,\n" +
-            "                  c: 3\n" +
-            "                })\n" +
-            "}\n",
+            `function f(o) {
+            }
+            let obj = {
+                Name: new f({ a: 1,
+                    b: 2 + 3,
+                    c: 3 + 4,
+                })
+            } `,
             [1, 3, 4, 5, 6],
         ],
 
@@ -154,10 +154,10 @@ describe('Coverage.expressionLinesForAST', function () {
         ],
 
         'finds lines for object property literals': [
-            "var a = {\n" +
-            "    Name: 'foo',\n" +
-            "    Ex: 'bar'\n" +
-            "};\n",
+            `var a = {
+                Name: 'foo' + 'bar',
+                Ex: 'bar' + 'foo',
+            }`,
             [1, 2, 3],
         ],
 
@@ -190,12 +190,12 @@ describe('Coverage.expressionLinesForAST', function () {
         ],
 
         'finds lines inside object-valued argument to throw statement': [
-            "function f() {\n" +
-            "    throw {\n" +
-            "        a: 1,\n" +
-            "        b: 2\n" +
-            "    }\n" +
-            "}\n",
+            `function f() {
+                throw {
+                    a: 1 + 2,
+                    b: 2 + 3,
+                }
+            }`,
             [2, 3, 4],
         ],
     };
diff --git a/modules/coverage.js b/modules/coverage.js
index 6860d2ba..295693c7 100644
--- a/modules/coverage.js
+++ b/modules/coverage.js
@@ -351,7 +351,7 @@ function expressionLinesForNode(statement) {
         /* These expressions aren't executable on their own */
         switch (statement.type) {
         case 'FunctionDeclaration':
-        case 'LiteralExpression':
+        case 'Literal':
             break;
         /* Perplexingly, an empty block statement is actually executable,
          * push it if it is */

From a5dacf3be58b99836e91b8a1d0de7ad44a1a3ce6 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sat, 23 Sep 2017 11:51:59 -0700
Subject: [PATCH 140/154] coverage: Don't mark empty var declarations
 executable

These never get executed. I'm not sure why they are treated differently
than empty let declarations, but it's probably to do with scope.

https://bugzilla.gnome.org/show_bug.cgi?id=788166
---
 installed-tests/js/testCoverage.js | 12 +++++++++++-
 modules/coverage.js                | 11 +++++++++++
 2 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/installed-tests/js/testCoverage.js b/installed-tests/js/testCoverage.js
index 547bb413..e82210ae 100644
--- a/installed-tests/js/testCoverage.js
+++ b/installed-tests/js/testCoverage.js
@@ -13,7 +13,7 @@ describe('Coverage.expressionLinesForAST', function () {
             "x = (function() {\n" +
             "    return 10;\n" +
             "})();\n",
-            [1, 2, 3],
+            [2, 3],
         ],
 
         'finds lines inside functions': [
@@ -198,6 +198,16 @@ describe('Coverage.expressionLinesForAST', function () {
             }`,
             [2, 3, 4],
         ],
+
+        'does not find lines in empty var declarations': [
+            'var foo;',
+            [],
+        ],
+
+        'finds lines in empty let declarations': [
+            'let foo;',
+            [1],
+        ],
     };
 
     Object.keys(testTable).forEach(testcase => {
diff --git a/modules/coverage.js b/modules/coverage.js
index 295693c7..7963dc11 100644
--- a/modules/coverage.js
+++ b/modules/coverage.js
@@ -360,6 +360,17 @@ function expressionLinesForNode(statement) {
                 break;
             expressionLines.push(statement.loc.start.line);
             break;
+        case 'VariableDeclaration':
+            if (statement.kind === 'var') {
+                /* empty 'var foo;' declarations are not executable */
+                let nonEmpty = statement.declarations.filter(decl =>
+                    decl.init !== null);
+                nonEmpty.forEach(decl => {
+                    expressionLines.push(decl.loc.start.line);
+                });
+                break;
+            }
+            /* fall through */
         default:
             expressionLines.push(statement.loc.start.line);
             break;

From 1fb7833d460ab8950f180399becc09860222c0d5 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sat, 23 Sep 2017 22:02:46 -0700
Subject: [PATCH 141/154] coverage: Misc refactors

- Include default code coverage options in makefile so that branch
  coverage works

- Eliminate some double exceptions being thrown in cache code

- Fix unused parameter in C++ function

- Remove unused constant dealing with binary cache which we don't have
  anymore

- Remove or change some obsolete comments

https://bugzilla.gnome.org/show_bug.cgi?id=788166
---
 Makefile-test.am           |  1 +
 cjs/coverage.cpp           | 55 ++++++++++------------------------------------
 test/gjs-test-coverage.cpp |  1 +
 3 files changed, 14 insertions(+), 43 deletions(-)

diff --git a/Makefile-test.am b/Makefile-test.am
index 03578a8a..a9f2ac77 100644
--- a/Makefile-test.am
+++ b/Makefile-test.am
@@ -338,6 +338,7 @@ JS_LOG_COMPILER = $$LOG_COMPILER $$LOG_FLAGS $(top_builddir)/minijasmine
 
 CODE_COVERAGE_IGNORE_PATTERN = */{include,mfbt,gjs/test,gjs/installed-tests}/*
 CODE_COVERAGE_GENHTML_OPTIONS = 			\
+	$(CODE_COVERAGE_GENHTML_OPTIONS_DEFAULT)	\
 	lcov/coverage.lcov 				\
 	--prefix $(abs_top_builddir)/lcov/org/gnome/gjs	\
 	--prefix $(abs_top_builddir) 			\
diff --git a/cjs/coverage.cpp b/cjs/coverage.cpp
index d6bf2c6a..e0ea7ec7 100644
--- a/cjs/coverage.cpp
+++ b/cjs/coverage.cpp
@@ -431,21 +431,17 @@ get_array_from_js_value(JSContext             *context,
     if (element_clear_func)
         g_array_set_clear_func(c_side_array, element_clear_func);
 
-    if (JS_GetArrayLength(context, js_array, &js_array_len)) {
-        uint32_t i = 0;
-        JS::RootedValue element(context);
-        for (; i < js_array_len; ++i) {
-            if (!JS_GetElement(context, js_array, i, &element)) {
-                g_array_unref(c_side_array);
-                gjs_throw(context, "Failed to get function names array element %d", i);
-                return false;
-            }
+    if (!JS_GetArrayLength(context, js_array, &js_array_len)) {
+        g_array_unref(c_side_array);
+        return false;
+    }
 
-            if (!(inserter(c_side_array, context, element))) {
-                g_array_unref(c_side_array);
-                gjs_throw(context, "Failed to convert array element %d", i);
-                return false;
-            }
+    JS::RootedValue element(context);
+    for (uint32_t i = 0; i < js_array_len; ++i) {
+        if (!JS_GetElement(context, js_array, i, &element) ||
+            !inserter(c_side_array, context, element)) {
+            g_array_unref(c_side_array);
+            return false;
         }
     }
 
@@ -526,12 +522,12 @@ get_hit_count_and_line_data(JSContext       *cx,
                             int32_t         *line)
 {
     JS::RootedId hit_count_name(cx, gjs_intern_string_to_id(cx, "hitCount"));
-    if (!gjs_object_require_property(cx, obj, "function element",
+    if (!gjs_object_require_property(cx, obj, description,
                                      hit_count_name, hit_count))
         return false;
 
     JS::RootedId line_number_name(cx, gjs_intern_string_to_id(cx, "line"));
-    return gjs_object_require_property(cx, obj, "function_element",
+    return gjs_object_require_property(cx, obj, description,
                                        line_number_name, line);
 }
 
@@ -970,33 +966,6 @@ gjs_get_file_checksum(GFile *file)
     return checksum;
 }
 
-/* The binary data for the cache has the following structure:
- *
- * {
- *     array [ tuple {
- *         string filename;
- *         string? checksum;
- *         tuple? {
- *             mtime_sec;
- *             mtime_usec;
- *         }
- *         array [
- *             int line;
- *         ] executable lines;
- *         array [ tuple {
- *             int branch_point;
- *             array [
- *                 int line;
- *             ] exits;
- *         } branch_info ] branches;
- *         array [ tuple {
- *             int line;
- *             string key;
- *         } function ] functions;
- *     } file ] files;
- */
-const char *COVERAGE_STATISTICS_CACHE_BINARY_DATA_TYPE = "a(sm(xx)msaia(iai)a(is))";
-
 GBytes *
 gjs_serialize_statistics(GjsCoverage *coverage)
 {
diff --git a/test/gjs-test-coverage.cpp b/test/gjs-test-coverage.cpp
index 4ac3b776..2a65269c 100644
--- a/test/gjs-test-coverage.cpp
+++ b/test/gjs-test-coverage.cpp
@@ -1843,6 +1843,7 @@ test_coverage_cache_invalidation(gpointer      fixture_data,
 
     const gsize expected_len = G_N_ELEMENTS(expected);
     const char *record = line_starting_with(coverage_data_contents, "SF:");
+    g_assert_nonnull(record);
     g_assert(check_coverage_data_for_source_file(expected, expected_len, record));
 
     g_free(script_output_path);

From cc061d4c9997399af478095eabde00017bb2af81 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sat, 30 Sep 2017 00:25:15 -0700
Subject: [PATCH 142/154] coverage: Fix coverage prefixes

Filename prefixes passed to gjs_coverage_new() were ignored. This
implements the expected functionality. Coverage is only recorded for JS
files which are prefixed with one of the specified prefixes.

https://bugzilla.gnome.org/show_bug.cgi?id=788166
---
 installed-tests/js/testCoverage.js | 64 ++++++++++++++++++++++++--------------
 modules/coverage.js                |  5 +++
 2 files changed, 45 insertions(+), 24 deletions(-)

diff --git a/installed-tests/js/testCoverage.js b/installed-tests/js/testCoverage.js
index e82210ae..a6fab7f1 100644
--- a/installed-tests/js/testCoverage.js
+++ b/installed-tests/js/testCoverage.js
@@ -1045,21 +1045,30 @@ describe('Coverage.incrementFunctionCounters', function () {
 
 describe('Coverage statistics container', function () {
     const MockFiles = {
-        'filename': "function f() {\n" +
-                    "    return 1;\n" +
-                    "}\n" +
-                    "if (f())\n" +
-                    "    f = 0;\n" +
-                    "\n",
-        'uncached': "function f() {\n" +
-                    "    return 1;\n" +
-                    '}\n',
-        'shebang': `#!/usr/bin/env gjs
+        'prefix/filename':
+            `function f() {
+                return 1;
+            }
+            if (f())
+                f = 0;
+            `,
+        'prefix/uncached':
+            `function f() {
+                return 1;
+            }
+            `,
+        'unprefixed':
+            `function f() {
+                return 1;
+            }
+            `,
+        'prefix/shebang':
+            `#!/usr/bin/env gjs
             function f() {}
             `,
     };
 
-    const MockFilenames = Object.keys(MockFiles).concat(['nonexistent']);
+    const MockFilenames = Object.keys(MockFiles).concat(['prefix/nonexistent']);
 
     let container;
 
@@ -1070,31 +1079,38 @@ describe('Coverage statistics container', function () {
             jasmine.createSpy('getFileChecksum').and.returnValue('abcd');
         Coverage.getFileModificationTime =
             jasmine.createSpy('getFileModificationTime').and.returnValue([1, 2]);
-        container = new Coverage.CoverageStatisticsContainer(MockFilenames);
+        container = new Coverage.CoverageStatisticsContainer(['prefix/']);
     });
 
     it('fetches valid statistics for file', function () {
-        let statistics = container.fetchStatistics('filename');
+        let statistics = container.fetchStatistics('prefix/filename');
         expect(statistics).toBeDefined();
 
         let files = container.getCoveredFiles();
-        expect(files).toEqual(['filename']);
+        expect(files).toEqual(['prefix/filename']);
     });
 
     it('throws for nonexisting file', function () {
-        expect(() => container.fetchStatistics('nonexistent')).toThrow();
+        expect(() => container.fetchStatistics('prefix/nonexistent')).toThrow();
     });
 
     it('handles a shebang on line 1', function () {
-        expect(() => container.fetchStatistics('shebang')).not.toThrow();
+        let statistics = container.fetchStatistics('prefix/shebang');
+        expect(statistics).toBeDefined();
     });
 
     it('ignores a file in angle brackets (our convention for programmatic scripts)', function () {
-        expect(() => container.fetchStatistics('<script>')).not.toThrow();
+        let statistics = container.fetchStatistics('<script>');
+        expect(statistics).not.toBeDefined();
+    });
+
+    it('ignores a file without the specified prefix', function () {
+        let statistics = container.fetchStatistics('unprefixed');
+        expect(statistics).not.toBeDefined();
     });
 
     const MockCache = '{ \
-        "filename": { \
+        "prefix/filename": { \
             "mtime": [1, 2], \
             "checksum": null, \
             "lines": [2, 4, 5], \
@@ -1122,22 +1138,22 @@ describe('Coverage statistics container', function () {
         });
 
         it('fetches counters from cache', function () {
-            container.fetchStatistics('filename');
+            container.fetchStatistics('prefix/filename');
             expect(Coverage._fetchCountersFromReflection).not.toHaveBeenCalled();
         });
 
         it('fetches counters from reflection if missed', function () {
-            container.fetchStatistics('uncached');
+            container.fetchStatistics('prefix/uncached');
             expect(Coverage._fetchCountersFromReflection).toHaveBeenCalled();
         });
 
         it('cache is not stale if all hit', function () {
-            container.fetchStatistics('filename');
+            container.fetchStatistics('prefix/filename');
             expect(container.staleCache()).toBeFalsy();
         });
 
         it('cache is stale if missed', function () {
-            container.fetchStatistics('uncached');
+            container.fetchStatistics('prefix/uncached');
             expect(container.staleCache()).toBeTruthy();
         });
     });
@@ -1148,10 +1164,10 @@ describe('Coverage statistics container', function () {
         beforeEach(function () {
             container = new Coverage.CoverageStatisticsContainer(MockFilenames,
                                                                  MockCache);
-            statistics = container.fetchStatistics('filename');
+            statistics = container.fetchStatistics('prefix/filename');
 
             containerWithNoCaching = new Coverage.CoverageStatisticsContainer(MockFilenames);
-            statisticsWithNoCaching = containerWithNoCaching.fetchStatistics('filename');
+            statisticsWithNoCaching = containerWithNoCaching.fetchStatistics('prefix/filename');
         });
 
         it('have same executable lines as reflection', function () {
diff --git a/modules/coverage.js b/modules/coverage.js
index 7963dc11..c087e162 100644
--- a/modules/coverage.js
+++ b/modules/coverage.js
@@ -790,6 +790,7 @@ function _fetchCountersFromReflection(filename, contents, nLines) {
 function CoverageStatisticsContainer(prefixes, cache) {
     /* Copy the files array, so that it can be re-used in the tests */
     let cachedASTs = cache ? JSON.parse(cache) : null;
+    let _prefixes = prefixes;
     let coveredFiles = {};
     let cacheMisses = 0;
 
@@ -816,6 +817,10 @@ function CoverageStatisticsContainer(prefixes, cache) {
         // Skip scripts fed to JS engine programmatically.
         if (filename.startsWith('<') && filename.endsWith('>'))
             return undefined;
+
+        if (!_prefixes.some(prefix => filename.startsWith(prefix)))
+            return undefined;
+
         if (!coveredFiles[filename])
             coveredFiles[filename] = createStatisticsFor(filename);
         return coveredFiles[filename];

From e711a3d69a31f3062d21fb0d09ae35feaa6ba3bf Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip@endlessm.com>
Date: Mon, 2 Oct 2017 17:04:45 -0700
Subject: [PATCH 143/154] release: Prepare for 1.50.1

---
 NEWS | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/NEWS b/NEWS
index 20ef5f2d..ac4d7f93 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,16 @@
+Version 1.50.1
+--------------
+
+- As a debugging aid, gjs_dumpstack() now works even during garbage collection.
+
+- Code coverage tools did not work so well in the last few 1.49 releases. The
+  worst problems are now fixed, although even more improvements will be
+  released in the next unstable version. Fixes include:
+
+  * Specifing prefixes for code coverage files now works again
+  * Code coverage now works on lines inside ES6 class definitions
+  * The detection of which lines are executable has been improved a bit
+
 Version 1.50.0
 --------------
 

From c2bd39bc22a34fd6bd980e331e1e45f000a92af9 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Mon, 11 Sep 2017 11:19:09 -0700
Subject: [PATCH 144/154] jsapi-util-args: Update out-of-date comments

---
 cjs/jsapi-util-args.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/cjs/jsapi-util-args.h b/cjs/jsapi-util-args.h
index 520ac8f6..76003d79 100644
--- a/cjs/jsapi-util-args.h
+++ b/cjs/jsapi-util-args.h
@@ -352,9 +352,9 @@ gjs_parse_call_args(JSContext    *cx,
  * value location pairs.  The currently accepted format specifiers are:
  *
  * b: A boolean (pass a bool *)
- * s: A string, converted into UTF-8 (pass a char **)
+ * s: A string, converted into UTF-8 (pass a GjsAutoJSChar *)
  * F: A string, converted into "filename encoding" (i.e. active locale) (pass
- *   a char **)
+ *   a GjsAutoChar *)
  * i: A number, will be converted to a 32-bit int (pass an int32_t * or a
  *   pointer to an enum type)
  * u: A number, converted into a 32-bit unsigned int (pass a uint32_t *)

From a0f428d9664c1ee50e8fdd6729a658cc7a19de33 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 3 Oct 2017 22:37:17 -0700
Subject: [PATCH 145/154] build: Tweak code coverage options

We want to include the default options so that if you set
CODE_COVERAGE_BRANCH_COVERAGE=1 it will get included in the options.

Remove an unnecessary entry from the ignore pattern.

https://bugzilla.gnome.org/show_bug.cgi?id=788166
---
 Makefile-test.am | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Makefile-test.am b/Makefile-test.am
index a9f2ac77..b6f104d1 100644
--- a/Makefile-test.am
+++ b/Makefile-test.am
@@ -336,7 +336,7 @@ SH_LOG_DRIVER = $(LOG_DRIVER)
 JS_LOG_DRIVER = $(LOG_DRIVER)
 JS_LOG_COMPILER = $$LOG_COMPILER $$LOG_FLAGS $(top_builddir)/minijasmine
 
-CODE_COVERAGE_IGNORE_PATTERN = */{include,mfbt,gjs/test,gjs/installed-tests}/*
+CODE_COVERAGE_IGNORE_PATTERN = */{include,mfbt,gjs/test}/*
 CODE_COVERAGE_GENHTML_OPTIONS = 			\
 	$(CODE_COVERAGE_GENHTML_OPTIONS_DEFAULT)	\
 	lcov/coverage.lcov 				\

From 54f75b214a545ad6a194f7c42f298161e1adf2cc Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 6 Dec 2017 06:41:15 -0600
Subject: [PATCH 146/154] tweener: Fix a couple of warnings

Spidermonkey now warns when relying on the falsiness of undefined
properties, so provide explicit fallbacks to avoid the warnings.

https://github.com/GNOME/gjs/commit/7906bb7a1b932225b6a8c35427f15f2224d838a6
---
 modules/tweener/tweener.js | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/modules/tweener/tweener.js b/modules/tweener/tweener.js
index 4c95d3b9..8d30aea0 100644
--- a/modules/tweener/tweener.js
+++ b/modules/tweener/tweener.js
@@ -545,7 +545,7 @@ function _addTweenOrCaller(target, tweeningParameters, isCaller) {
                                                         properties[istr].valueComplete,
                                                         properties[istr].arrayIndex || 0,
                                                         {},
-                                                        properties[istr].isSpecialProperty,
+                                                        properties[istr].isSpecialProperty || false,
                                                         properties[istr].modifierFunction || null,
                                                         properties[istr].modifierParameters || null);
             }

From d5af79611cbe789c391f421f90d5263cab2f5a59 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Florian=20M=C3=BCllner?= <fmuellner@gnome.org>
Date: Sat, 28 Oct 2017 17:59:33 +0200
Subject: [PATCH 147/154] legacy: Allow ES6 classes to inherit from abstract
 Lang.Class class

Currently Lang.Class uses a distinct constructor for abstract classes,
which just throws when instantiated. This works as Lang.Class classes
chain up to _init rather than the real constructor, which isn't the
case for ES6 classes. In order to allow ES6 classes to directly inherit
from an abstract Lang.Class class, check whether an abstract class
has been instantiated directly inside the regular constructor.
---
 installed-tests/js/testLegacyClass.js |  7 +++++++
 modules/_legacy.js                    | 16 ++++++----------
 2 files changed, 13 insertions(+), 10 deletions(-)

diff --git a/installed-tests/js/testLegacyClass.js b/installed-tests/js/testLegacyClass.js
index ac59e8e6..e691abb6 100644
--- a/installed-tests/js/testLegacyClass.js
+++ b/installed-tests/js/testLegacyClass.js
@@ -292,6 +292,13 @@ describe('Class framework', function () {
         expect(newAbstract.foo).toEqual(42);
     });
 
+    it('allows ES6 classes to inherit from abstract base classes', function() {
+        class AbstractImpl extends AbstractBase {};
+
+        let newAbstract = new AbstractImpl();
+        expect(newAbstract.foo).toEqual(42);
+    });
+
     it('lets methods call other methods without clobbering __caller__', function () {
         let newMagic = new Magic();
         let buffer = [];
diff --git a/modules/_legacy.js b/modules/_legacy.js
index 99cef8cb..a89420c4 100644
--- a/modules/_legacy.js
+++ b/modules/_legacy.js
@@ -105,18 +105,14 @@ Class.prototype._construct = function(params) {
     if (!parent)
         parent = _Base;
 
-    let newClass;
-    if (params.Abstract) {
-        newClass = function() {
+    let newClass = function() {
+        if (params.Abstract && new.target.name === name)
             throw new TypeError('Cannot instantiate abstract class ' + name);
-        };
-    } else {
-        newClass = function() {
-            this.__caller__ = null;
 
-            return this._construct.apply(this, arguments);
-        };
-    }
+        this.__caller__ = null;
+
+        return this._construct(...arguments);
+    };
 
     // Since it's not possible to create a constructor with
     // a custom [[Prototype]], we have to do this to make

From 7ee7bc728af062cc04590c40c10a85bf2a089f46 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Tue, 31 Oct 2017 09:07:05 -0700
Subject: [PATCH 148/154] release: Prepare for 1.50.2

---
 NEWS | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/NEWS b/NEWS
index ac4d7f93..f787da16 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,14 @@
+Version 1.50.2
+--------------
+
+- Closed bugs and merge requests:
+
+  * tweener: Fix a couple of warnings [!5, Florian Müllner]
+  * legacy: Allow ES6 classes to inherit from abstract Lang.Class class [!6,
+    Florian Müllner]
+
+- Minor bugfixes [Philip Chimento]
+
 Version 1.50.1
 --------------
 

From 491315fa46a648e9c097f8949ab09e909a95c9de Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Thu, 14 Sep 2017 04:14:47 -0500
Subject: [PATCH 149/154] importer.cpp: Update search path for Cinnamon

This reverts commit 6b9681930f0d51f6ee5c23c5ea96f35bddc5e18f.

Conflicts:
	doc/Hacking.md
---
 cjs/importer.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/cjs/importer.cpp b/cjs/importer.cpp
index 95e3a9c1..b4f28f70 100644
--- a/cjs/importer.cpp
+++ b/cjs/importer.cpp
@@ -914,7 +914,7 @@ gjs_get_search_path(void)
             g_free(dirs);
         }
 
-        g_ptr_array_add(path, g_strdup("resource:///org/gnome/gjs/modules/"));
+        g_ptr_array_add(path, g_strdup("resource:///org/cinnamon/cjs/modules/"));
 
         /* $XDG_DATA_DIRS /gjs-1.0 */
         system_data_dirs = g_get_system_data_dirs();

From 6d41f943ace4117abfa3d8f08856178f37520f3e Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Wed, 6 Dec 2017 06:44:21 -0600
Subject: [PATCH 150/154] Remove valgrind configuration

Failed to build with "syntax error near token [drd]".
---
 Makefile-test.am | 3 +--
 configure.ac     | 9 +--------
 2 files changed, 2 insertions(+), 10 deletions(-)

diff --git a/Makefile-test.am b/Makefile-test.am
index b6f104d1..c816c138 100644
--- a/Makefile-test.am
+++ b/Makefile-test.am
@@ -275,7 +275,7 @@ EXTRA_DIST +=						\
 
 ### TEST EXECUTION #####################################################
 
-@VALGRIND_CHECK_RULES@
+#@VALGRIND_CHECK_RULES@
 VALGRIND_SUPPRESSIONS_FILES = 				\
 	$(datadir)/glib-2.0/valgrind/glib.supp		\
 	$(top_srcdir)/installed-tests/extra/gjs.supp	\
@@ -344,4 +344,3 @@ CODE_COVERAGE_GENHTML_OPTIONS = 			\
 	--prefix $(abs_top_builddir) 			\
 	$(NULL)
 @CODE_COVERAGE_RULES@
-endif
diff --git a/configure.ac b/configure.ac
index fa04c78e..cc7d9da9 100644
--- a/configure.ac
+++ b/configure.ac
@@ -46,20 +46,13 @@ AC_PROG_AWK
 
 AX_COMPILER_FLAGS
 
-m4_ifdef([AX_CODE_COVERAGE],
-         [AX_CODE_COVERAGE],
-         [AM_CONDITIONAL(CODE_COVERAGE_ENABLED, false)])
+AX_CODE_COVERAGE
 dnl Clang does not need to link with -lgcov
 AX_CHECK_LINK_FLAG([-lgcov],, [
 	CODE_COVERAGE_LIBS=
 	CODE_COVERAGE_LDFLAGS=
 ])
 
-AX_VALGRIND_DFLT([drd], [off])
-AX_VALGRIND_DFLT([sgcheck], [off])
-# DRD and sgcheck don't produce useful diagnostics at this time
-AX_VALGRIND_CHECK
-
 # Checks for libraries.
 m4_define(glib_required_version, 2.42.0)
 

From ebe116d40c8b3d443d66f092e8cff62cf6425113 Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Thu, 14 Sep 2017 04:18:03 -0500
Subject: [PATCH 151/154] Fix DEBUG compiler error in Spidermonkey 52

---
 cjs/jsapi-wrapper.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/cjs/jsapi-wrapper.h b/cjs/jsapi-wrapper.h
index 1eb06563..85b0f1cb 100644
--- a/cjs/jsapi-wrapper.h
+++ b/cjs/jsapi-wrapper.h
@@ -29,10 +29,10 @@
 
 /* COMPAT: SpiderMonkey headers in some places use DEBUG instead of JS_DEBUG */
 /* https://bugzilla.mozilla.org/show_bug.cgi?id=1261161 */
-#ifdef HAVE_DEBUG_SPIDERMONKEY
+/*#ifdef HAVE_DEBUG_SPIDERMONKEY
 #define DEBUG 1
 #endif
-
+*/
 #include <js-config.h>  /* SpiderMonkey's #defines that affect public API */
 
 #if defined(__clang__) || __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)

From 1e478975896a9b234f2dab71e3044fa8ef8d47b5 Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Thu, 14 Sep 2017 04:21:59 -0500
Subject: [PATCH 152/154] Depend on libmozjs-52

---
 debian/control    | 4 ++--
 debian/control.in | 4 ++--
 debian/rules      | 2 +-
 3 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/debian/control b/debian/control
index 828aff50..45f2df16 100644
--- a/debian/control
+++ b/debian/control
@@ -14,7 +14,7 @@ Build-Depends: debhelper (>= 10),
                libglib2.0-dev (>= 2.42.0),
                libgirepository1.0-dev (>= 1.46.0),
                gobject-introspection (>= 1.46.0),
-               libmozjs-38-dev,
+               libmozjs-52-dev,
                libreadline-dev,
                libgtk-3-dev,
                libcairo2-dev,
@@ -59,7 +59,7 @@ Depends: ${misc:Depends},
          libcjs0f (= ${binary:Version}),
          libgirepository1.0-dev (>= 1.41.4),
          libgtk-3-dev,
-         libmozjs-38-dev
+         libmozjs-52-dev
 Description: Mozilla-based javascript bindings for the Cinnamon platform
  Makes it possible for applications to use all of Cinnamon's platform
  libraries using the JavaScript language. It's mainly based on the
diff --git a/debian/control.in b/debian/control.in
index 2e1041ce..9990cc75 100644
--- a/debian/control.in
+++ b/debian/control.in
@@ -10,7 +10,7 @@ Build-Depends: debhelper (>= 10),
                libglib2.0-dev (>= 2.42.0),
                libgirepository1.0-dev (>= 1.46.0),
                gobject-introspection (>= 1.46.0),
-               libmozjs-38-dev,
+               libmozjs-52-dev,
                libreadline-dev,
                libgtk-3-dev,
                libcairo2-dev,
@@ -55,7 +55,7 @@ Depends: ${misc:Depends},
          libcjs0f (= ${binary:Version}),
          libgirepository1.0-dev (>= 1.41.4),
          libgtk-3-dev,
-         libmozjs-38-dev
+         libmozjs-52-dev
 Description: Mozilla-based javascript bindings for the Cinnamon platform
  Makes it possible for applications to use all of Cinnamon's platform
  libraries using the JavaScript language. It's mainly based on the
diff --git a/debian/rules b/debian/rules
index 05fd9a3e..dfb9c0c1 100755
--- a/debian/rules
+++ b/debian/rules
@@ -6,7 +6,7 @@ include /usr/share/gnome-pkg-tools/1/rules/gnome-get-source.mk
 # files have been installed.
 #LIBMOZJS = $(shell objdump -p debian/tmp/usr/lib/libgjs.so | awk '$$1=="NEEDED" && $$2~/^libmozjs/ { print $$2 }' | sed s/\\.so\\./-/ )
 # Hard code the mozjs version here since the above line didn't seem to work
-LIBMOZJS = libmozjs-38-0
+LIBMOZJS = libmozjs-52-0
 
 %:
 	dh $@ --with gnome,gir

From b47c4680dba9295ba359fe64b971440b0b61ca03 Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Thu, 14 Sep 2017 04:22:36 -0500
Subject: [PATCH 153/154] Get most tests passing

---
 installed-tests/js/testEverythingBasic.js  |  6 +++---
 installed-tests/js/testExceptions.js       | 26 +++++++++++++-------------
 installed-tests/js/testGDBus.js            |  4 ++--
 installed-tests/js/testImporter.js         |  8 ++++----
 installed-tests/js/testPackage.js          |  2 +-
 installed-tests/js/testSignals.js          |  4 ++--
 installed-tests/js/testSystem.js           |  2 +-
 installed-tests/scripts/testCommandLine.sh | 14 +++++++-------
 installed-tests/scripts/testWarnings.sh    |  4 ++--
 modules/_legacy.js                         |  2 +-
 10 files changed, 36 insertions(+), 36 deletions(-)

diff --git a/installed-tests/js/testEverythingBasic.js b/installed-tests/js/testEverythingBasic.js
index ad6dd266..5e95166f 100644
--- a/installed-tests/js/testEverythingBasic.js
+++ b/installed-tests/js/testEverythingBasic.js
@@ -87,7 +87,7 @@ describe('Life, the Universe and Everything', function () {
                 pending("This test doesn't work");
 
             if (bytes === '64')
-                GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+                GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
                     "*cannot be safely stored*");
 
             let val = Limits[bytes][limit];
@@ -112,9 +112,9 @@ describe('Life, the Universe and Everything', function () {
         });
 
         it('warns when conversion is lossy', function () {
-            GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+            GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
                 "*cannot be safely stored*");
-            GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+            GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
                 "*cannot be safely stored*");
             void GLib.MAXINT64;
             void GLib.MAXUINT64;
diff --git a/installed-tests/js/testExceptions.js b/installed-tests/js/testExceptions.js
index 5c5e05f3..c6388bb7 100644
--- a/installed-tests/js/testExceptions.js
+++ b/installed-tests/js/testExceptions.js
@@ -37,7 +37,7 @@ describe('Exceptions', function () {
     // FIXME: In the next cases the errors aren't thrown but logged
 
     it('are logged from constructor', function () {
-        GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+        GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
             'JS ERROR: Error: set*');
 
         new Foo({ prop: 'bar' });
@@ -53,7 +53,7 @@ describe('Exceptions', function () {
         bar.bind_property('prop',
             foo, 'prop',
             GObject.BindingFlags.DEFAULT);
-        GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+        GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
             'JS ERROR: Error: set*');
 
         // wake up the binding so that g_object_set() is called on foo
@@ -70,7 +70,7 @@ describe('Exceptions', function () {
         foo.bind_property('prop',
             bar, 'prop',
             GObject.BindingFlags.DEFAULT);
-        GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+        GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
             'JS ERROR: Error: get*');
 
         // wake up the binding so that g_object_get() is called on foo
@@ -88,7 +88,7 @@ describe('logError', function () {
     });
 
     it('logs a warning for a GError', function () {
-        GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+        GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
             'JS ERROR: Gio.IOErrorEnum: *');
         try {
             let file = Gio.file_new_for_path("\\/,.^!@&$_don't exist");
@@ -99,7 +99,7 @@ describe('logError', function () {
     });
 
     it('logs a warning with a message if given', function marker() {
-        GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+        GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
             'JS ERROR: Gio.IOErrorEnum: a message\nmarker@*');
         try {
             throw new Gio.IOErrorEnum({ message: 'a message', code: 0 });
@@ -109,19 +109,19 @@ describe('logError', function () {
     });
 
     it('also logs an error for a created GError that is not thrown', function marker() {
-        GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+        GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
             'JS ERROR: Gio.IOErrorEnum: a message\nmarker@*');
         logError(new Gio.IOErrorEnum({ message: 'a message', code: 0 }));
     });
 
     it('logs an error with no stack trace for an error created with the GLib.Error constructor', function () {
-        GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+        GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
             'JS ERROR: Gio.IOErrorEnum: a message');
         logError(new GLib.Error(Gio.IOErrorEnum, 0, 'a message'));
     });
 
     it('logs the quark for a JS-created GError type', function () {
-        GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+        GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
             'JS ERROR: GLib.Error my-error: a message');
         logError(new GLib.Error(GLib.quark_from_string('my-error'), 0, 'a message'));
     });
@@ -129,7 +129,7 @@ describe('logError', function () {
     // Now with prefix
 
     it('logs an error with a prefix if given', function () {
-        GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+        GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
             'JS ERROR: prefix: Gio.IOErrorEnum: *');
         try {
             let file = Gio.file_new_for_path("\\/,.^!@&$_don't exist");
@@ -140,7 +140,7 @@ describe('logError', function () {
     });
 
     it('logs an error with prefix and message', function marker() {
-        GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+        GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
             'JS ERROR: prefix: Gio.IOErrorEnum: a message\nmarker@*');
         try {
             throw new Gio.IOErrorEnum({ message: 'a message', code: 0 });
@@ -150,19 +150,19 @@ describe('logError', function () {
     });
 
     it('logs a non-thrown error with prefix', function marker() {
-        GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+        GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
             'JS ERROR: prefix: Gio.IOErrorEnum: a message\nmarker@*');
         logError(new Gio.IOErrorEnum({ message: 'a message', code: 0 }), 'prefix');
     });
 
     it('logs a GLib.Error with prefix', function () {
-        GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+        GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
             'JS ERROR: prefix: Gio.IOErrorEnum: a message');
         logError(new GLib.Error(Gio.IOErrorEnum, 0, 'a message'), 'prefix');
     });
 
     it('logs a JS-created GLib.Error with prefix', function () {
-        GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+        GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
             'JS ERROR: prefix: GLib.Error my-error: a message');
         logError(new GLib.Error(GLib.quark_from_string('my-error'), 0, 'a message'), 'prefix');
     });
diff --git a/installed-tests/js/testGDBus.js b/installed-tests/js/testGDBus.js
index 11cd7394..53c0daf8 100644
--- a/installed-tests/js/testGDBus.js
+++ b/installed-tests/js/testGDBus.js
@@ -258,7 +258,7 @@ describe('Exported DBus object', function () {
     /* excp must be exactly the exception thrown by the remote method
        (more or less) */
     it('can handle an exception thrown by a remote method', function () {
-        GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+        GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
             'JS ERROR: Exception in method call: alwaysThrowException: *');
 
         proxy.alwaysThrowExceptionRemote({}, function(result, excp) {
@@ -269,7 +269,7 @@ describe('Exported DBus object', function () {
     });
 
     it('can still destructure the return value when an exception is thrown', function () {
-        GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+        GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
             'JS ERROR: Exception in method call: alwaysThrowException: *');
 
         // This test will not fail, but instead if the functionality is not
diff --git a/installed-tests/js/testImporter.js b/installed-tests/js/testImporter.js
index e46781f5..783381ee 100644
--- a/installed-tests/js/testImporter.js
+++ b/installed-tests/js/testImporter.js
@@ -170,12 +170,12 @@ describe('Importer', function () {
             LexicalScope = imports.lexicalScope;
         });
 
-        it('will log a compatibility warning when accessed', function () {
+        /*it('will log a compatibility warning when accessed', function () {
             const GLib = imports.gi.GLib;
-            GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+            GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
                 "Some code accessed the property 'b' on the module " +
                 "'lexicalScope'.*");
-            GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+            GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
                 "Some code accessed the property 'c' on the module " +
                 "'lexicalScope'.*");
 
@@ -185,7 +185,7 @@ describe('Importer', function () {
             // g_test_assert_expected_messages() is a macro, not introspectable
             GLib.test_assert_expected_messages_internal('Gjs',
                 'testImporter.js', 179, '');
-        });
+        });*/
 
         it('can be accessed', function () {
             expect(LexicalScope.a).toEqual(1);
diff --git a/installed-tests/js/testPackage.js b/installed-tests/js/testPackage.js
index bcaf3db4..377ed8a4 100644
--- a/installed-tests/js/testPackage.js
+++ b/installed-tests/js/testPackage.js
@@ -62,7 +62,7 @@ describe('Package module', function () {
     });
 
     it('doesn\'t find a non-existent interface method', function () {
-        expect(Pkg.checkSymbol('GIMarshallingTests', '1.0', 'Interface.test_int42_in')).toEqual(false);
+        expect(Pkg.checkSymbol('GIMarshallingTests', '1.0', 'Interface.test_int42_291in342')).toEqual(false);
     });
 
     it('finds an enum value', function () {
diff --git a/installed-tests/js/testSignals.js b/installed-tests/js/testSignals.js
index 58d35309..c87a20d7 100644
--- a/installed-tests/js/testSignals.js
+++ b/installed-tests/js/testSignals.js
@@ -99,7 +99,7 @@ function testSignals(klass) {
             bar2 = jasmine.createSpy('bar');
             foo.connect('bar', bar);
             foo.connect('bar', bar2);
-            GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+            GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
                                      'JS ERROR: Exception in callback for signal: *');
             foo.emit('bar');
         });
@@ -110,7 +110,7 @@ function testSignals(klass) {
         });
 
         it('does not disconnect the callback', function () {
-            GLib.test_expect_message('Gjs', GLib.LogLevelFlags.LEVEL_WARNING,
+            GLib.test_expect_message('Cjs', GLib.LogLevelFlags.LEVEL_WARNING,
                                      'JS ERROR: Exception in callback for signal: *');
             foo.emit('bar');
             expect(bar).toHaveBeenCalledTimes(2);
diff --git a/installed-tests/js/testSystem.js b/installed-tests/js/testSystem.js
index 1211de48..8071ae7a 100644
--- a/installed-tests/js/testSystem.js
+++ b/installed-tests/js/testSystem.js
@@ -12,7 +12,7 @@ describe('System.addressOf()', function () {
 describe('System.version', function () {
     it('gives a plausible number', function () {
         expect(System.version).not.toBeLessThan(14700);
-        expect(System.version).toBeLessThan(20000);
+        expect(System.version).toBeLessThan(40000);
     });
 });
 
diff --git a/installed-tests/scripts/testCommandLine.sh b/installed-tests/scripts/testCommandLine.sh
index df9c6e6c..b86550c0 100755
--- a/installed-tests/scripts/testCommandLine.sh
+++ b/installed-tests/scripts/testCommandLine.sh
@@ -1,9 +1,9 @@
 #!/bin/sh
 
 if test "$GJS_USE_UNINSTALLED_FILES" = "1"; then
-    gjs="$LOG_COMPILER $LOG_FLAGS $TOP_BUILDDIR/gjs-console"
+    gjs="$LOG_COMPILER $LOG_FLAGS $TOP_BUILDDIR/cjs-console"
 else
-    gjs="$LOG_COMPILER $LOG_FLAGS gjs-console"
+    gjs="$LOG_COMPILER $LOG_FLAGS cjs-console"
 fi
 
 # This JS script should exit immediately with code 42. If that is not working,
@@ -72,7 +72,7 @@ report_xfail () {
     fi
 }
 
-# Test that System.exit() works in gjs-console
+# Test that System.exit() works in cjs-console
 $gjs -c 'imports.system.exit(0)'
 report "System.exit(0) should exit successfully"
 $gjs -c 'imports.system.exit(42)'
@@ -128,11 +128,11 @@ report "--help after -c should not print anything"
 # "$gjs" help.js --help -I sentinel
 # report_xfail "-I after script file should not be added to search path"
 # fi
-$gjs help.js --help -I sentinel 2>&1 | grep -q 'Gjs-WARNING.*--include-path'
+$gjs help.js --help -I sentinel 2>&1 | grep -q 'Cjs-WARNING.*--include-path'
 report "-I after script should succeed but give a warning"
-$gjs -c 'imports.system.exit(0)' --coverage-prefix=foo --coverage-output=foo 2>&1 | grep -q 'Gjs-WARNING.*--coverage-prefix'
+$gjs -c 'imports.system.exit(0)' --coverage-prefix=foo --coverage-output=foo 2>&1 | grep -q 'Cjs-WARNING.*--coverage-prefix'
 report "--coverage-prefix after script should succeed but give a warning"
-$gjs -c 'imports.system.exit(0)' --coverage-prefix=foo --coverage-output=foo 2>&1 | grep -q 'Gjs-WARNING.*--coverage-output'
+$gjs -c 'imports.system.exit(0)' --coverage-prefix=foo --coverage-output=foo 2>&1 | grep -q 'Cjs-WARNING.*--coverage-output'
 report "--coverage-output after script should succeed but give a warning"
 rm -f foo/coverage.lcov
 
@@ -158,7 +158,7 @@ report "interpreter should run queued promise jobs before finishing"
 test -n "${output##*Should not be printed*}"
 report "interpreter should stop running jobs when one calls System.exit()"
 
-$gjs -c "Promise.resolve().then(() => { throw new Error(); });" 2>&1 | grep -q 'Gjs-WARNING.*Unhandled promise rejection.*[sS]tack trace'
+$gjs -c "Promise.resolve().then(() => { throw new Error(); });" 2>&1 | grep -q 'Cjs-WARNING.*Unhandled promise rejection.*[sS]tack trace'
 report "unhandled promise rejection should be reported"
 test -z $($gjs awaitcatch.js)
 report "catching an await expression should not cause unhandled rejection"
diff --git a/installed-tests/scripts/testWarnings.sh b/installed-tests/scripts/testWarnings.sh
index 804cfb6e..43332339 100755
--- a/installed-tests/scripts/testWarnings.sh
+++ b/installed-tests/scripts/testWarnings.sh
@@ -1,9 +1,9 @@
 #!/bin/sh
 
 if test "$GJS_USE_UNINSTALLED_FILES" = "1"; then
-    gjs="$LOG_COMPILER $LOG_FLAGS $TOP_BUILDDIR/gjs-console"
+    gjs="$LOG_COMPILER $LOG_FLAGS $TOP_BUILDDIR/cjs-console"
 else
-    gjs="$LOG_COMPILER $LOG_FLAGS gjs-console"
+    gjs="$LOG_COMPILER $LOG_FLAGS cjs-console"
 fi
 
 total=0
diff --git a/modules/_legacy.js b/modules/_legacy.js
index a89420c4..31995ae7 100644
--- a/modules/_legacy.js
+++ b/modules/_legacy.js
@@ -670,7 +670,7 @@ function defineGtkLegacyObjects(GObject, Gtk) {
             this.parent(params);
 
             if (cssName)
-                Gtk.Widget.set_css_name.call(this, cssName);
+                //Gtk.Widget.set_css_name.call(this, cssName);
 
             if (template) {
                 if (typeof template == 'string' &&

From d34f98a15baf19bcbc49c448d8101bfd438cc053 Mon Sep 17 00:00:00 2001
From: Jason Hicks <jaszhix@gmail.com>
Date: Thu, 14 Sep 2017 04:25:02 -0500
Subject: [PATCH 154/154] Fix usage of g_idle_add for resolving promises

Changed to g_idle_add_full with a 0ms priority. Promises should not take
200ms to resolve. This can add up and unnecessarily inflates the process
time for asynchronous tasks.
---
 cjs/context.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/cjs/context.cpp b/cjs/context.cpp
index 29a4bdac..7937b608 100644
--- a/cjs/context.cpp
+++ b/cjs/context.cpp
@@ -508,8 +508,10 @@ _gjs_context_enqueue_job(GjsContext      *gjs_context,
     if (!gjs_context->job_queue->append(job))
         return false;
     if (!gjs_context->idle_drain_handler)
+        /*Modified for CJS, Promises shouldn't take 200ms to resolve. When several
+        promises are queued up, this artifically inflates resolve time. */
         gjs_context->idle_drain_handler =
-            g_idle_add(drain_job_queue_idle_handler, gjs_context);
+            g_idle_add_full(0, drain_job_queue_idle_handler, gjs_context, NULL);
 
     return true;
 }
